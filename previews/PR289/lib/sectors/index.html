<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symmetry sectors · TensorKit.jl</title><meta name="title" content="Symmetry sectors · TensorKit.jl"/><meta property="og:title" content="Symmetry sectors · TensorKit.jl"/><meta property="twitter:title" content="Symmetry sectors · TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Introduction</a></li><li><a class="tocitem" href="../../man/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../man/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../man/sectors/">Sectors, graded spaces and fusion trees</a></li><li><a class="tocitem" href="../../man/tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Symmetry sectors</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#Useful-constants"><span>Useful constants</span></a></li><li><a class="tocitem" href="#Methods-for-characterizing-and-manipulating-Sector-objects"><span>Methods for characterizing and manipulating <code>Sector</code> objects</span></a></li></ul></li><li><a class="tocitem" href="../fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Symmetry sectors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symmetry sectors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/lib/sectors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symmetry-sectors"><a class="docs-heading-anchor" href="#Symmetry-sectors">Symmetry sectors</a><a id="Symmetry-sectors-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-sectors" title="Permalink"></a></h1><h2 id="Type-hierarchy"><a class="docs-heading-anchor" href="#Type-hierarchy">Type hierarchy</a><a id="Type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy" title="Permalink"></a></h2><p>The fundamental abstract supertype for symmetry sectors is <code>Sector</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Sector" href="#TensorKitSectors.Sector"><code>TensorKitSectors.Sector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Sector</code></pre><p>Abstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes <code>I &lt;: Sector</code> as the set of labels of a <code>GradedSpace</code>.</p><p>Every new <code>I &lt;: Sector</code> should implement the following methods:</p><ul><li><code>unit(::Type{I})</code>: unit element of <code>I</code>. If there are multiple, implement <code>allunits(::Type{I})</code>   instead.</li><li><code>dual(a::I)</code>: <span>$a̅$</span>, conjugate or dual label of <span>$a$</span></li><li><code>⊗(a::I, b::I)</code>: iterable with unique fusion outputs of <span>$a ⊗ b$</span>   (i.e. don&#39;t repeat in case of multiplicities)</li><li><code>Nsymbol(a::I, b::I, c::I)</code>: number of times <code>c</code> appears in <code>a ⊗ b</code>, i.e. the   multiplicity</li><li><code>FusionStyle(::Type{I})</code>: <code>UniqueFusion()</code>, <code>SimpleFusion()</code> or   <code>GenericFusion()</code></li><li><code>BraidingStyle(::Type{I})</code>: <code>Bosonic()</code>, <code>Fermionic()</code>, <code>Anyonic()</code>, ...</li><li><code>Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)</code>: F-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li><li><code>Rsymbol(a::I, b::I, c::I)</code>: R-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li></ul><p>and optionally</p><ul><li><code>dim(a::I)</code>: quantum dimension of sector <code>a</code></li><li><code>frobenius_schur_indicator(a::I)</code>: Frobenius-Schur indicator of <code>a</code> (1, 0, -1)</li><li><code>frobenius_schur_phase(a::I)</code>: Frobenius-Schur phase of <code>a</code> (±1)</li><li><code>sectorscalartype(::Type{I})</code>: scalar type of F- and R-symbols</li><li><code>Bsymbol(a::I, b::I, c::I)</code>: B-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li><li><code>twist(a::I)</code> -&gt; twist of sector <code>a</code></li></ul><p>Furthermore, <code>iterate</code> and <code>Base.IteratorSize</code> should be made to work for the singleton type <a href="#TensorKitSectors.SectorValues"><code>SectorValues{I}</code></a>.</p><p>To help with the implementation of <code>⊗(a::I, b::I)</code> as an iterator, the provided <code>struct</code> type <a href="#TensorKitSectors.SectorProductIterator"><code>SectorProductIterator{I}</code></a> can be used, which stores <code>a</code> and <code>b</code> and requires the implementation of <code>Base.iterate(::SectorProductIterator{I}, state...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L1-L38">source</a></section></article><p>Various concrete subtypes of <code>Sector</code> are provided within the TensorKitSectors library:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Trivial" href="#TensorKitSectors.Trivial"><code>TensorKitSectors.Trivial</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Trivial &lt;: Sector
Trivial()</code></pre><p>Singleton type to represent the trivial sector, i.e. the trivial representation of the trivial group. This is equivalent to <code>Rep[ℤ₁]</code>, or the unit object of the category <code>Vect</code> of ordinary vector spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/trivial.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.AbstractIrrep" href="#TensorKitSectors.AbstractIrrep"><code>TensorKitSectors.AbstractIrrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractIrrep{G &lt;: Group} &lt;: Sector</code></pre><p>Abstract supertype for sectors which corresponds to irreps (irreducible representations) of a group <code>G</code>. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.</p><p>Actual concrete implementations of those irreps can be obtained as <code>Irrep[G]</code>, or via their actual name, which generically takes the form <code>(asciiG)Irrep</code>, i.e. the ASCII spelling of the group name followed by <code>Irrep</code>.</p><p>All irreps have <a href="#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> equal to <code>Bosonic()</code> and thus trivial twists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/irreps.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.ZNIrrep" href="#TensorKitSectors.ZNIrrep"><code>TensorKitSectors.ZNIrrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ZNIrrep{N, T &lt;: Unsigned} &lt;: AbstractIrrep{ℤ{N}}
ZNIrrep{N}(n::Integer)
Irrep[ℤ{N}](n::Integer)</code></pre><p>Represents irreps of the group <span>$ℤ_N$</span> for some value of <code>N</code>. For <code>N</code> equals <code>2</code>, <code>3</code> or <code>4</code>, <code>ℤ{N}</code> can be replaced by <a href="@ref"><code>ℤ₂</code></a>, <a href="@ref"><code>ℤ₃</code></a>, and <a href="@ref"><code>ℤ₄</code></a>. An arbitrary <code>Integer</code> <code>n</code> can be provided to the constructor, but only the value <code>mod(n, N)</code> is relevant.</p><p>The type of the stored integer <code>T</code> can either be explicitly provided, or will automatically be determined to be the smallest unsigned integer type that fits all possible irreps for the given <code>N</code>.</p><p>See also <a href="#TensorKitSectors.charge"><code>charge</code></a> and <a href="#TensorKitSectors.modulus"><code>modulus</code></a> to extract the relevant data.</p><p><strong>Fields</strong></p><ul><li><code>n::T</code>: the integer label of the irrep, modulo <code>N</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/znirrep.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.DNIrrep" href="#TensorKitSectors.DNIrrep"><code>TensorKitSectors.DNIrrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DNIrrep{N} &lt;: AbstractIrrep{Dihedral{N}}
DNIrrep{N}(n::Integer, isodd::Bool=false)
Irrep[Dihedral{N}](n::Integer, isodd::Bool=false)</code></pre><p>Represents irreps of the dihedral group <span>$D_N = Z_N ⋊ C$</span> (<span>$Z_N$</span> and charge conjugation or reflection).</p><p><strong>Properties</strong></p><ul><li><code>j::Int</code>: the value of the <span>$Z_N$</span> charge.</li><li><code>isodd::Bool</code>: the representation of charge conjugation.</li></ul><p>Combined these take the values <span>$+0, -0, 1, ..., (N - 1) / 2$</span> for odd <span>$N$</span>, and <span>$+0, -0, 1, ..., N / 2 - 1, +(N/2), -(N/2)$</span> for even <span>$N$</span>, where the <span>$+$</span> (<span>$-$</span>) refer to the even (odd) one-dimensional irreps, while the others are two-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/dnirrep.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.U1Irrep" href="#TensorKitSectors.U1Irrep"><code>TensorKitSectors.U1Irrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct U1Irrep &lt;: AbstractIrrep{U₁}
U1Irrep(charge::Real)
Irrep[U₁](charge::Real)</code></pre><p>Represents irreps of the group <span>$U₁$</span>. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of <span>$U₁$</span> subgroups of <span>$SU₂$</span>, such as the <span>$S^z$</span> of spin-1/2 system. Hence, the charge is stored as a <code>HalfInt</code> from the package HalfIntegers.jl, but can be entered as arbitrary <code>Real</code>. The sequence of the charges is: 0, 1/2, -1/2, 1, -1, ...</p><p><strong>Fields</strong></p><ul><li><code>charge::HalfInt</code>: the label of the irrep, which can be any half integer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/u1irrep.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.SU2Irrep" href="#TensorKitSectors.SU2Irrep"><code>TensorKitSectors.SU2Irrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SU2Irrep &lt;: AbstractIrrep{SU₂}
SU2Irrep(j::Real)
Irrep[SU₂](j::Real)</code></pre><p>Represents irreps of the group <span>$SU₂$</span>. The irrep is labelled by a half integer <code>j</code> which can be entered as an abitrary <code>Real</code>, but is stored as a <code>HalfInt</code> from the HalfIntegers.jl package.</p><p><strong>Fields</strong></p><ul><li><code>j::HalfInt</code>: the label of the irrep, which can be any non-negative half integer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/su2irrep.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.CU1Irrep" href="#TensorKitSectors.CU1Irrep"><code>TensorKitSectors.CU1Irrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CU1Irrep &lt;: AbstractIrrep{CU₁}
CU1Irrep(j, s = ifelse(j&gt;zero(j), 2, 0))
Irrep[CU₁](j, s = ifelse(j&gt;zero(j), 2, 0))</code></pre><p>Represents irreps of the group <span>$U₁ ⋊ C$</span> (<span>$U₁$</span> and charge conjugation or reflection), which is also known as just <code>O₂</code>. </p><p><strong>Fields</strong></p><ul><li><code>j::HalfInt</code>: the value of the <span>$U₁$</span> charge.</li><li><code>s::Int</code>: the representation of charge conjugation.</li></ul><p>They can take values:</p><ul><li>if <code>j == 0</code>, <code>s = 0</code> (trivial charge conjugation) or   <code>s = 1</code> (non-trivial charge conjugation)</li><li>if <code>j &gt; 0</code>, <code>s = 2</code> (two-dimensional representation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/cu1irrep.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.AbstractGroupElement" href="#TensorKitSectors.AbstractGroupElement"><code>TensorKitSectors.AbstractGroupElement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractGroupElement{G &lt;: Group} &lt;: Sector</code></pre><p>Abstract supertype for sectors which corresponds to group elements of a group <code>G</code>.</p><p>Actual concrete implementations of those irreps can be obtained as <code>Element[G]</code>, or via their actual name, which generically takes the form <code>(asciiG)Element</code>, i.e. the ASCII spelling of the group name followed by <code>Element</code>.</p><p>All group elements have <a href="#TensorKitSectors.FusionStyle"><code>FusionStyle</code></a> equal to <code>UniqueFusion()</code>. Furthermore, the <a href="#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> is set to <code>NoBraiding()</code>, although this can be overridden by a concrete implementation of <code>AbstractGroupElement</code>.</p><p>For the fusion structure, a specific <code>SomeGroupElement &lt;: AbstractGroupElement{SomeGroup}</code> should only implement the following methods</p><pre><code class="language-julia hljs">Base.:*(c1::GroupElement, c2::GroupElement) -&gt; GroupElement
Base.one(::Type{GroupElement}) -&gt; GroupElement
Base.inv(c::GroupElement) -&gt; GroupElement
# and optionally
TensorKitSectors.cocycle(c1::GroupElement, c2::GroupElement, c3::GroupElement) -&gt; Number</code></pre><p>The methods <code>conj</code>, <code>dual</code>, <code>⊗</code>, <code>Nsymbol</code>, <code>Fsymbol</code>, <code>dim</code>, <code>Asymbol</code>, <code>Bsymbol</code> and <code>frobenius_schur_phase</code> will then be automatically defined. If no <code>cocycle</code> method is defined, the cocycle will be assumed to be trivial, i.e. equal to <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groupelements.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.ZNElement" href="#TensorKitSectors.ZNElement"><code>TensorKitSectors.ZNElement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ZNElement{N, p} &lt;: AbstractGroupElement{ℤ{N}}
ZNElement{N, p}(n::Integer)
GroupElement[ℤ{N}, p](n::Integer)</code></pre><p>Represents an element of the group <span>$ℤ_N$</span> for some value of <code>N &lt; 64</code>. (We need <code>2 * (N - 1) &lt;= 127</code> in order for <code>a ⊗ b</code> to work correctly.) For <code>N</code> equals <code>2</code>, <code>3</code> or <code>4</code>, <code>ℤ{N}</code> can be replaced by <code>ℤ₂</code>, <code>ℤ₃</code>, <code>ℤ₄</code>. An arbitrary <code>Integer</code> <code>n</code> can be provided to the constructor, but only the value <code>mod(n, N)</code> is relevant. The second type parameter <code>p</code> should also be specified as an integer <code>0 &lt;= p &lt; N</code> and specifies the 3-cocycle, which is then being given by</p><pre><code class="language-julia hljs">cocycle(a, b, c) = cispi(2 * p * a.n * (b.n + c.n - mod(b.n + c.n, N)) / N))</code></pre><p>If <code>p</code> is not specified, it defaults to <code>0</code>, i.e. the trivial cocycle.</p><p><strong>Fields</strong></p><ul><li><code>n::Int8</code>: the integer label of the element, modulo <code>N</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groupelements.jl#L90-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.FermionParity" href="#TensorKitSectors.FermionParity"><code>TensorKitSectors.FermionParity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FermionParity &lt;: Sector
FermionParity(isodd::Bool)</code></pre><p>Represents sectors with fermion parity. The fermion parity is a <span>$ℤ₂$</span> quantum number that yields an additional sign when two odd fermions are exchanged, corresponding to a <a href="#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> that is <code>Fermionic()</code>.</p><p><strong>Fields</strong></p><ul><li><code>isodd::Bool</code>: indicates whether the fermion parity is odd (<code>true</code>) or even (<code>false</code>).</li></ul><p>See also: <a href="#TensorKitSectors.FermionNumber"><code>FermionNumber</code></a>, <a href="#TensorKitSectors.FermionSpin"><code>FermionSpin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/fermions.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.FermionNumber" href="#TensorKitSectors.FermionNumber"><code>TensorKitSectors.FermionNumber</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const FermionNumber = U1Irrep ⊠ FermionParity
FermionNumber(a::Int)</code></pre><p>Represents the fermion number as the direct product of a <span>$U₁$</span> irrep <code>a</code> and a fermion parity, with the restriction that the fermion parity is odd if and only if <code>a</code> is odd.</p><p>See also: <a href="#TensorKitSectors.U1Irrep"><code>U1Irrep</code></a>, <a href="#TensorKitSectors.FermionParity"><code>FermionParity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/fermions.jl#L74-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.FermionSpin" href="#TensorKitSectors.FermionSpin"><code>TensorKitSectors.FermionSpin</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const FermionSpin = SU2Irrep ⊠ FermionParity
FermionSpin(j::Real)</code></pre><p>Represents the fermion spin as the direct product of a <span>$SU₂$</span> irrep <code>j</code> and a fermion parity, with the restriction that the fermion parity is odd if <code>2 * j</code> is odd.</p><p>See also: <a href="#TensorKitSectors.SU2Irrep"><code>SU2Irrep</code></a>, <a href="#TensorKitSectors.FermionParity"><code>FermionParity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/fermions.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.FibonacciAnyon" href="#TensorKitSectors.FibonacciAnyon"><code>TensorKitSectors.FibonacciAnyon</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FibonacciAnyon &lt;: Sector
FibonacciAnyon(s::Symbol)</code></pre><p>Represents the anyons of the Fibonacci modular fusion category. It can take two values, corresponding to the trivial sector <code>FibonacciAnyon(:I)</code> and the non-trivial sector <code>FibonacciAnyon(:τ)</code> with fusion rules <span>$τ ⊗ τ = 1 ⊕ τ$</span>.</p><p><strong>Fields</strong></p><ul><li><code>isunit::Bool</code>: indicates whether the sector corresponds to the trivial anyon <code>:I</code> (<code>true</code>), or the non-trivial anyon <code>:τ</code> (<code>false</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/anyons.jl#L39-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.IsingAnyon" href="#TensorKitSectors.IsingAnyon"><code>TensorKitSectors.IsingAnyon</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IsingAnyon &lt;: Sector
IsingAnyon(s::Symbol)</code></pre><p>Represents the anyons of the Ising modular fusion category. It can take three values, corresponding to the trivial sector <code>IsingAnyon(:I)</code> and the non-trivial sectors <code>IsingAnyon(:σ)</code> and <code>IsingAnyon(:ψ)</code>, with fusion rules <span>$ψ ⊗ ψ = 1$</span>, <span>$σ ⊗ ψ = σ$</span>, and <span>$σ ⊗ σ = 1 ⊕ ψ$</span>.</p><p><strong>Fields</strong></p><ul><li><code>s::Symbol</code>: the label of the represented anyon, which can be <code>:I</code>, <code>:σ</code>, or <code>:ψ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/anyons.jl#L155-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.PlanarTrivial" href="#TensorKitSectors.PlanarTrivial"><code>TensorKitSectors.PlanarTrivial</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PlanarTrivial &lt;: Sector
PlanarTrivial()</code></pre><p>Represents a trivial anyon sector, i.e. a trivial sector without braiding. This is mostly useful for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/anyons.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.IsingBimodule" href="#TensorKitSectors.IsingBimodule"><code>TensorKitSectors.IsingBimodule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IsingBimodule &lt;: Sector</code></pre><p>Type to represent the simple objects in the Ising category reinterpreted as a bimodule category composed of two copies of the category 𝒞 = 𝒟 = Irrep[ℤ₂], the two simple objects of which can be identified with the Ising anyons {I, ψ}, and the bimodule categories ℳ = ℳᵒᵖ = Vec, with a single simple object that can be identified with the Ising anyon σ. This constitutes the easiest example of a multifusion category and is implemented here for testing purposes and to illustrate how to implement such categories in TensorKitSectors.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/multifusion.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.TimeReversed" href="#TensorKitSectors.TimeReversed"><code>TensorKitSectors.TimeReversed</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TimeReversed{I &lt;: Sector}
TimeReversed(a::I) where {I &lt;: Sector}</code></pre><p>Represents the time-reversed version of the sector <code>I</code>, i.e. the sector with the same fusion rules and <code>F</code>-symbols, but with the inverse braiding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/timereversed.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.ProductSector" href="#TensorKitSectors.ProductSector"><code>TensorKitSectors.ProductSector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ProductSector{T &lt;: SectorTuple}
ProductSector((s₁, s₂, ...))</code></pre><p>Represents the Deligne tensor product of sectors. The type parameter <code>T</code> is a tuple of the component sectors. The recommended way to construct a <code>ProductSector</code> is using the <a href="#TensorKitSectors.deligneproduct-Tuple{Sector, Sector}"><code>deligneproduct</code></a> (<code>⊠</code>) operator on the components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/product.jl#L5-L12">source</a></section></article><p>Several more concrete sector types can be found in other packages such as <a href="https://github.com/QuantumKitHub/SUNRepresentations.jl">SUNRepresentations.jl</a>, <a href="https://github.com/lkdvos/CategoryData.jl">CategoryData.jl</a>, <a href="https://github.com/lkdvos/QWignerSymbols.jl">QWignerSymbols.jl</a>, ...:</p><p>Some of these types are parameterized by a type parameter that represents a group. We therefore also provide a number of types to represent groups:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Group" href="#TensorKitSectors.Group"><code>TensorKitSectors.Group</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Group</code></pre><p>Abstract supertype for representing different types of groups. Groups can be used to define Sector subtypes, either via their irreducible representations, or via their group elements, and typically appear as type parameter. As such, they are not meant to be instantiated and are defined as abstract types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.AbelianGroup" href="#TensorKitSectors.AbelianGroup"><code>TensorKitSectors.AbelianGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbelianGroup &lt;: Group</code></pre><p>Abstract supertype for representing different types of Abelian groups. Abelian groups have both irreps and group elements that have several simplified properties, that can be defined in general.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Cyclic" href="#TensorKitSectors.Cyclic"><code>TensorKitSectors.Cyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Cyclic{N} &lt;: AbelianGroup</code></pre><p>Type to represent the cyclic group of order <code>N</code>, i.e. the multiplicative group of roots of unity of order <code>N</code>, which is a discrete abelian group. The cyclic group of order <code>N</code> is isomorphic to the additive group <code>ℤ{N}</code>, and we define the latter as a type alias <code>const ℤ{N} = Cyclic{N}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.U₁" href="#TensorKitSectors.U₁"><code>TensorKitSectors.U₁</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type U₁ &lt;: AbelianGroup</code></pre><p>Type to represent the group <span>$U(1)$</span> of complex numbers of unit modulus, which is a compact Abelian Lie group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.CU₁" href="#TensorKitSectors.CU₁"><code>TensorKitSectors.CU₁</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type CU₁ &lt;: Group</code></pre><p>Type to represent the group of U₁ in combination with charge conjugation, i.e. the group generated by U₁ and an additional element that acts as complex conjugation on U₁. This group is isomorphic to the orthogonal group O₂ of real orthogonal 2×2 matrices, and can be seen as the semidirect product U₁ ⋊ ℤ₂. This is a compact non-Abelian group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.SU" href="#TensorKitSectors.SU"><code>TensorKitSectors.SU</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SU{N} &lt;: Group</code></pre><p>Type to represent the special unitary group <span>$SU(N)$</span>, which is a compact non-Abelian Lie group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Dihedral" href="#TensorKitSectors.Dihedral"><code>TensorKitSectors.Dihedral</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Dihedral{N} &lt;: Group</code></pre><p>Type to represent the dihedral group of order <code>2N</code>, which is the symmetry group of a regular polygon with <code>N</code> sides, and is a discrete non-Abelian group. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.ProductGroup" href="#TensorKitSectors.ProductGroup"><code>TensorKitSectors.ProductGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ProductGroup{T &lt;: Tuple{Vararg{Group}}} &lt;: Group</code></pre><p>Type to represent the direct product of a tuple of groups. This is typically constructed via the <a href="#TensorKitSectors.:×"><code>×</code></a> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L89-L94">source</a></section></article><p>The following types are used to characterise different properties of the different types of sectors:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.FusionStyle" href="#TensorKitSectors.FusionStyle"><code>TensorKitSectors.FusionStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type FusionStyle
FusionStyle(::Sector)
FusionStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the fusion behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>UniqueFusion()</code>: single fusion output when fusing two sectors;</li><li><code>SimpleFusion()</code>: multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of <span>$SU(2)$</span>);</li><li><code>GenericFusion()</code>: multiple outputs that can occur more than once (e.g. irreps   of <span>$SU(3)$</span>).</li></ul><p>There is an abstract supertype <code>MultipleFusion</code> of which both <code>SimpleFusion</code> and <code>GenericFusion</code> are subtypes. Furthermore, there is a type alias <code>MultiplicityFreeFusion</code> for those fusion types which do not require muliplicity labels, i.e. <code>MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L282-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.BraidingStyle" href="#TensorKitSectors.BraidingStyle"><code>TensorKitSectors.BraidingStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type BradingStyle
BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(I::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>I</code>, which can be either</p><ul><li><code>NoBraiding()</code>: no braiding structure</li><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R^{ab}_c$</span> phase or matrix (depending on <code>SimpleFusion</code> or   <code>GenericFusion</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L466-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.UnitStyle" href="#TensorKitSectors.UnitStyle"><code>TensorKitSectors.UnitStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type UnitStyle
UnitStyle(::Sector)
UnitStyle(I::Type{&lt;:Sector})</code></pre><p>Trait to describe the semisimplicity of the unit sector of type <code>I</code>. This can be either</p><ul><li><code>SimpleUnit()</code>: the unit is simple (e.g. fusion categories);</li><li><code>GenericUnit()</code>: the unit is semisimple.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L321-L330">source</a></section></article><p>Finally, the following auxiliary types are defined to facilitate the implementation of some of the methods on sectors:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.SectorValues" href="#TensorKitSectors.SectorValues"><code>TensorKitSectors.SectorValues</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SectorValues{I &lt;: Sector}</code></pre><p>Singleton type to represent an iterator over the possible values of type <code>I</code>, whose instance is obtained as <code>values(I)</code>. For a new <code>I::Sector</code>, the following should be defined</p><ul><li><code>Base.iterate(::SectorValues{I}[, state])</code>: iterate over the values</li><li><code>Base.IteratorSize(::Type{SectorValues{I}})</code>: <code>HasLength()</code>, <code>SizeUnknown()</code>   or <code>IsInfinite()</code> depending on whether the number of values of type <code>I</code> is finite   (and sufficiently small) or infinite; for a large number of values, <code>SizeUnknown()</code> is   recommended because this will trigger the use of <code>GenericGradedSpace</code>.</li></ul><p>If <code>IteratorSize(I) == HasLength()</code>, also the following must be implemented:</p><ul><li><code>Base.length(::SectorValues{I})</code>: the number of different values</li><li><code>Base.getindex(::SectorValues{I}, i::Int)</code>: a mapping between an index <code>i</code> and an   instance of <code>I</code>. A fallback implementation exists that returns the <code>i</code>th value   of the <code>SectorValues</code> iterator.</li><li><code>findindex(::SectorValues{I}, c::I)</code>: reverse mapping between a value <code>c::I</code> and an   index <code>i::Integer ∈ 1:length(values(I))</code>. A fallback implementation exists that   linearly searches through the <code>SectorValues</code> iterator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L51-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.SectorProductIterator" href="#TensorKitSectors.SectorProductIterator"><code>TensorKitSectors.SectorProductIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SectorProductIterator{I &lt;: Sector}
SectorProductIterator(a::I, b::I) where {I &lt;: Sector}</code></pre><p>Custom iterator to represent the (unique) fusion outputs of <span>$a ⊗ b$</span>.</p><p>Custom sectors that aim to use this have to provide the following functionality:</p><ul><li><code>Base.iterate(::SectorProductIterator{I}, state...) where {I &lt;: Sector}</code>: iterate over   the fusion outputs of <code>a ⊗ b</code></li></ul><p>If desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define <code>Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength()</code>, in which case <code>Base.length(::SectorProductIterator{I})</code> has to be implemented.</p><p>See also <a href="#TensorKitSectors.:⊗"><code>⊗</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L224-L240">source</a></section></article><h2 id="Useful-constants"><a class="docs-heading-anchor" href="#Useful-constants">Useful constants</a><a id="Useful-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-constants" title="Permalink"></a></h2><p>The following constants are defined to facilitate obtaining the type associated with the group elements or the irreducible representations of a given group:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Irrep" href="#TensorKitSectors.Irrep"><code>TensorKitSectors.Irrep</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Irrep</code></pre><p>A constant of a singleton type used as <code>Irrep[G]</code> with <code>G &lt;: Group</code> a type of group, to construct or obtain a concrete subtype of <code>AbstractIrrep{G}</code> that implements the data structure used to represent irreducible representations of the group <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/irreps.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.GroupElement" href="#TensorKitSectors.GroupElement"><code>TensorKitSectors.GroupElement</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const GroupElement</code></pre><p>A constant of a singleton type used as <code>GroupElement[G]</code> or <code>GroupElement[G, ω]</code> with <code>G &lt;: Group</code> a type of group, to construct or obtain a concrete subtype of <code>AbstractElement{G}</code> that implements the data structure used to represent elements of the group <code>G</code>, possibly with a second argument <code>ω</code> that specifies the associated 3-cocycle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groupelements.jl#L60-L67">source</a></section></article><h2 id="Methods-for-characterizing-and-manipulating-Sector-objects"><a class="docs-heading-anchor" href="#Methods-for-characterizing-and-manipulating-Sector-objects">Methods for characterizing and manipulating <code>Sector</code> objects</a><a id="Methods-for-characterizing-and-manipulating-Sector-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-characterizing-and-manipulating-Sector-objects" title="Permalink"></a></h2><p>The following methods can be used to obtain properties such as topological data of sector objects, or to manipulate them or create related sectors:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.unit" href="#TensorKitSectors.unit"><code>TensorKitSectors.unit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unit(::Sector) -&gt; Sector
unit(::Type{&lt;:Sector}) -&gt; Sector</code></pre><p>Return the unit element of this type of sector, provided it is unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.isunit" href="#TensorKitSectors.isunit"><code>TensorKitSectors.isunit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isunit(a::Sector) -&gt; Bool</code></pre><p>Return whether sector <code>a</code> is a unit element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.leftunit" href="#TensorKitSectors.leftunit"><code>TensorKitSectors.leftunit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leftunit(a::Sector) -&gt; Sector</code></pre><p>Return the left unit element corresponding to <code>a</code>; this is necessary for multifusion categories, where the unit may not be unique. See also <a href="#TensorKitSectors.rightunit"><code>rightunit</code></a> and <a href="#TensorKitSectors.unit"><code>unit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.rightunit" href="#TensorKitSectors.rightunit"><code>TensorKitSectors.rightunit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rightunit(a::Sector) -&gt; Sector</code></pre><p>Return the right unit element corresponding to <code>a</code>; this is necessary for multifusion categories, where the unit may not be unique. See also <a href="#TensorKitSectors.leftunit"><code>leftunit</code></a> and <a href="#TensorKitSectors.unit"><code>unit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L145-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.allunits" href="#TensorKitSectors.allunits"><code>TensorKitSectors.allunits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allunits(I::Type{&lt;:Sector}) -&gt; Tuple{I}</code></pre><p>Return a tuple with all units of the sector type <code>I</code>. For fusion categories, this will contain only one element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.dual-Tuple{Sector}" href="#TensorKitSectors.dual-Tuple{Sector}"><code>TensorKitSectors.dual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dual(a::Sector) -&gt; Sector</code></pre><p>Return the dual label of <code>a</code>, i.e. the unique label <code>ā = dual(a)</code> such that  <code>Nsymbol(a, ā, leftunit(a)) == 1</code> and <code>Nsymbol(ā, a, rightunit(a)) == 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Nsymbol" href="#TensorKitSectors.Nsymbol"><code>TensorKitSectors.Nsymbol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Nsymbol(a::I, b::I, c::I) where {I &lt;: Sector} -&gt; Integer</code></pre><p>Return an <code>Integer</code> representing the number of times <code>c</code> appears in the fusion product <code>a ⊗ b</code>. Could be a <code>Bool</code> if <code>FusionStyle(I) == UniqueFusion()</code> or <code>SimpleFusion()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L273-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.:⊗" href="#TensorKitSectors.:⊗"><code>TensorKitSectors.:⊗</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊗(a::I, b::I...) where {I &lt;: Sector}
otimes(a::I, b::I...) where {I &lt;: Sector}</code></pre><p>Return an iterable of elements of <code>c::I</code> that appear in the fusion product <code>a ⊗ b</code>.</p><p>Note that every element <code>c</code> should appear at most once, fusion degeneracies (if <code>FusionStyle(I) == GenericFusion()</code>) should be accessed via <code>Nsymbol(a, b, c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L194-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Fsymbol" href="#TensorKitSectors.Fsymbol"><code>TensorKitSectors.Fsymbol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I &lt;: Sector}</code></pre><p>Return the F-symbol <span>$F^{abc}_d$</span> that associates the two different fusion orders of sectors <code>a</code>, <code>b</code> and <code>c</code> into an ouput sector <code>d</code>, using either an intermediate sector <span>$a ⊗ b → e$</span> or <span>$b ⊗ c → f$</span>:</p><pre><code class="language-julia hljs">a-&lt;-μ-&lt;-e-&lt;-ν-&lt;-d                                     a-&lt;-λ-&lt;-d
    ∨       ∨       -&gt; Fsymbol(a,b,c,d,e,f)[μ,ν,κ,λ]      ∨
    b       c                                             f
                                                          v
                                                      b-&lt;-κ
                                                          ∨
                                                          c</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion</code> or <code>SimpleFusion</code>, the F-symbol is a number. Otherwise it is a rank 4 array of size <code>(Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L352-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Rsymbol" href="#TensorKitSectors.Rsymbol"><code>TensorKitSectors.Rsymbol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rsymbol(a::I, b::I, c::I) where {I &lt;: Sector}</code></pre><p>Returns the R-symbol <span>$R^{ab}_c$</span> that maps between <span>$c → a ⊗ b$</span> and <span>$c → b ⊗ a$</span> as in</p><pre><code class="language-julia hljs">a -&lt;-μ-&lt;- c                                 b -&lt;-ν-&lt;- c
     ∨        -&gt; Rsymbol(a, b, c)[μ, ν]          v
     b                                           a</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion()</code> or <code>SimpleFusion()</code>, the R-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a, b, c) == Nsymbol(b, a, c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L506-L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.Bsymbol" href="#TensorKitSectors.Bsymbol"><code>TensorKitSectors.Bsymbol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bsymbol(a::I, b::I, c::I) where {I &lt;: Sector}</code></pre><p>Return the value of <span>$B^{ab}_c$</span> which appears in transforming a splitting vertex into a fusion vertex using the transformation</p><pre><code class="language-julia hljs">a -&lt;-μ-&lt;- c                                                    a -&lt;-ν-&lt;- c
     ∨       -&gt; √(dim(c) / dim(a)) * Bsymbol(a, b, c)[μ, ν]         ∧
     b                                                            dual(b)</code></pre><p>If <code>FusionStyle(I)</code> is <code>UniqueFusion()</code> or <code>SimpleFusion()</code>, the B-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a, b, c) == Nsymbol(c, dual(b), a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L437-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.dim-Tuple{Sector}" href="#TensorKitSectors.dim-Tuple{Sector}"><code>TensorKitSectors.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(a::Sector)</code></pre><p>Return the (quantum) dimension of the sector <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.frobenius_schur_phase" href="#TensorKitSectors.frobenius_schur_phase"><code>TensorKitSectors.frobenius_schur_phase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frobenius_schur_phase(a::Sector)</code></pre><p>Return the Frobenius-Schur phase <span>$κₐ$</span> of a sector <span>$a$</span>, which is a complex phase that appears in the context of bending lines and is obtained from <span>$F^{a a̅ a}_a$</span>. When <code>a == dual(a)</code>, it is restricted to <span>$κₐ ∈ \{1, -1\}$</span> and coincides with the group-theoretic version <a href="#TensorKitSectors.frobenius_schur_indicator"><code>frobenius_schur_indicator</code></a>. When <code>a != dual(a)</code>, the value of <span>$κₐ$</span> can be gauged to be <code>1</code>, though is not required to be.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L392-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.frobenius_schur_indicator" href="#TensorKitSectors.frobenius_schur_indicator"><code>TensorKitSectors.frobenius_schur_indicator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frobenius_schur_indicator(a::Sector)</code></pre><p>Return the Frobenius-Schur indicator of a sector <span>$νₐ ∈ \{1, 0, -1\}$</span>, which distinguishes between real, complex and quaternionic representations.</p><p>See also <a href="#TensorKitSectors.frobenius_schur_phase"><code>frobenius_schur_phase</code></a> for the category-theoretic version that appears in the context of line bending.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L409-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.twist-Tuple{Sector}" href="#TensorKitSectors.twist-Tuple{Sector}"><code>TensorKitSectors.twist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twist(a::Sector)</code></pre><p>Return the twist of a sector <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L523-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isreal-Tuple{Type{&lt;:Sector}}" href="#Base.isreal-Tuple{Type{&lt;:Sector}}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isreal(::Type{&lt;:Sector}) -&gt; Bool</code></pre><p>Return whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.sectorscalartype" href="#TensorKitSectors.sectorscalartype"><code>TensorKitSectors.sectorscalartype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sectorscalartype(I::Type{&lt;:Sector}) -&gt; Type</code></pre><p>Return the scalar type of the topological data (Fsymbol, Rsymbol) of the sector <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.deligneproduct-Tuple{Sector, Sector}" href="#TensorKitSectors.deligneproduct-Tuple{Sector, Sector}"><code>TensorKitSectors.deligneproduct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊠(s₁::Sector, s₂::Sector)
deligneproduct(s₁::Sector, s₂::Sector)</code></pre><p>Given two sectors <code>s₁</code> and <code>s₂</code>, which label an isomorphism class of simple objects in a fusion category <span>$C₁$</span> and <span>$C₂$</span>, <code>s1 ⊠ s2</code> (obtained as <code>\boxtimes+TAB</code>) labels the isomorphism class of simple objects in the Deligne tensor product category <span>$C₁ ⊠ C₂$</span>.</p><p>The Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have <code>Irrep[G₁] ⊠ Irrep[G₂] == Irrep[G₁ × G₂]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/product.jl#L243-L253">source</a></section></article><p>We have also the following methods that are specific to certain types of sectors and serve as accessors to their fields:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.charge" href="#TensorKitSectors.charge"><code>TensorKitSectors.charge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">charge(c::ZNIrrep) -&gt; Int</code></pre><p>The charge label of the irrep <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/znirrep.jl#L41-L45">source</a></section><section><div><pre><code class="language-julia hljs">charge(c::U1Irrep) -&gt; HalfInt</code></pre><p>The charge label of the irrep <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/u1irrep.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.modulus" href="#TensorKitSectors.modulus"><code>TensorKitSectors.modulus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modulus(c::ZNIrrep{N}) -&gt; N
modulus(::Type{&lt;:ZNIrrep{N}}) -&gt; N</code></pre><p>The order of the cyclic group, or the modulus of the charge labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/irreps/znirrep.jl#L32-L37">source</a></section></article><p>Furthermore, we also have one specific method acting on groups, represented as types</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.:×" href="#TensorKitSectors.:×"><code>TensorKitSectors.:×</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">×(G::Vararg{Type{&lt;:Group}}) -&gt; ProductGroup{Tuple{G...}}
times(G::Vararg{Type{&lt;:Group}}) -&gt; ProductGroup{Tuple{G...}}</code></pre><p>Construct the direct product of a (list of) groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/groups.jl#L97-L102">source</a></section></article><p>Because we sometimes want to customize the string representation of our sector types, we also have the following method:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.type_repr" href="#TensorKitSectors.type_repr"><code>TensorKitSectors.type_repr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">type_repr(T::Type)</code></pre><p>Return a string representation of the type <code>T</code>, which is used to modify the default way in which <code>Sector</code> subtypes are displayed in other objects that depend on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/sectors.jl#L41-L46">source</a></section></article><p>Finally, we provide functionality to compile all revelant methods for a sector:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.precompile_sector" href="#TensorKitSectors.precompile_sector"><code>TensorKitSectors.precompile_sector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precompile_sector(I::Type{&lt;:Sector})</code></pre><p>Precompile common methods for the given sector type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.1/src/precompile.jl#L1-L5">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/tensors/">« Tensors and the <code>TensorMap</code> type</a><a class="docs-footer-nextpage" href="../fusiontrees/">Fusion trees »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 21 October 2025 22:42">Tuesday 21 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
