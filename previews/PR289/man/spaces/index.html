<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vector spaces ¬∑ TensorKit.jl</title><meta name="title" content="Vector spaces ¬∑ TensorKit.jl"/><meta property="og:title" content="Vector spaces ¬∑ TensorKit.jl"/><meta property="twitter:title" content="Vector spaces ¬∑ TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Vector spaces</a><ul class="internal"><li><a class="tocitem" href="#ss_fields"><span>Fields</span></a></li><li><a class="tocitem" href="#ss_elementaryspaces"><span>Elementary spaces</span></a></li><li><a class="tocitem" href="#Operations-with-elementary-spaces"><span>Operations with elementary spaces</span></a></li><li><a class="tocitem" href="#ss_compositespaces"><span>Composite spaces</span></a></li><li><a class="tocitem" href="#ss_spaceops"><span>More operations with vector spaces</span></a></li><li><a class="tocitem" href="#ss_homspaces"><span>Space of morphisms</span></a></li></ul></li><li><a class="tocitem" href="../sectors/">Sectors, graded spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors</a></li><li><a class="tocitem" href="../../lib/fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Vector spaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vector spaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/man/spaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="s_spaces"><a class="docs-heading-anchor" href="#s_spaces">Vector spaces</a><a id="s_spaces-1"></a><a class="docs-heading-anchor-permalink" href="#s_spaces" title="Permalink"></a></h1><p>From the <a href="../intro/#s_intro">Introduction</a>, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type <a href="../../lib/spaces/#TensorKit.VectorSpace"><code>VectorSpace</code></a></p><pre><code class="language-julia hljs">abstract type VectorSpace end</code></pre><p>Technically speaking, this name does not capture the full generality that TensorKit.jl supports, as instances of subtypes of <code>VectorSpace</code> can encode general objects in linear monoidal categories, which are not necessarily vector spaces. However, in order not to make the remaining discussion to abstract or complicated, we will simply use the nomenclature of vector spaces. In particular, we define two abstract subtypes</p><pre><code class="language-julia hljs">abstract type ElementarySpace &lt;: VectorSpace end
const IndexSpace = ElementarySpace

abstract type CompositeSpace{S&lt;:ElementarySpace} &lt;: VectorSpace end</code></pre><p>Here, <a href="../../lib/spaces/#TensorKit.ElementarySpace"><code>ElementarySpace</code></a> is a super type for all vector spaces (objects) that can be associated with the individual indices of a tensor, as hinted to by its alias <code>IndexSpace</code>.</p><p>On the other hand, subtypes of <a href="../../lib/spaces/#TensorKit.CompositeSpace"><code>CompositeSpace{S}</code></a> where <code>S&lt;:ElementarySpace</code> are composed of a number of elementary spaces of type <code>S</code>. So far, there is a single concrete type <a href="../../lib/spaces/#TensorKit.ProductSpace"><code>ProductSpace{S,N}</code></a> that represents the tensor product of <code>N</code> vector spaces of a homogeneous type <code>S</code>. Its properties are discussed in the section on <a href="#ss_compositespaces">Composite spaces</a>, together with possible extensions for the future.</p><p>Throughout TensorKit.jl, the function <a href="../../lib/tensors/#TensorKit.spacetype-Union{Tuple{Type{&lt;:AbstractTensorMap{&lt;:Any, S}}}, Tuple{S}} where S"><code>spacetype</code></a> returns the type of <code>ElementarySpace</code> associated with e.g. a composite space or a tensor. It works both on instances and in the type domain. Its use will be illustrated below.</p><h2 id="ss_fields"><a class="docs-heading-anchor" href="#ss_fields">Fields</a><a id="ss_fields-1"></a><a class="docs-heading-anchor-permalink" href="#ss_fields" title="Permalink"></a></h2><p>Vector spaces (and linear categories more generally) are defined over a field of scalars <span>$ùîΩ$</span>. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via</p><pre><code class="language-julia hljs">abstract type Field end

struct RealNumbers &lt;: Field end
struct ComplexNumbers &lt;: Field end

const ‚Ñù = RealNumbers()
const ‚ÑÇ = ComplexNumbers()</code></pre><p>Note that <code>‚Ñù</code> and <code>‚ÑÇ</code> can be typed as <code>\bbR</code>+TAB and <code>\bbC</code>+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia&#39;s <code>Number</code> hierarchy is to introduce some syntactic sugar without committing type piracy. In particular, we now have</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 3 ‚àà ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5.0 ‚àà ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5.0 + 1.0 * im ‚àà ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Float64 ‚äÜ ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ComplexF64 ‚äÜ ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù ‚äÜ ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ ‚äÜ ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>and furthermore ‚Äîprobably more usefully‚Äî <code>‚Ñù^n</code> and <code>‚ÑÇ^n</code> create specific elementary vector spaces as described in the next section. The underlying field of a vector space or tensor <code>a</code> can be obtained with <a href="../../lib/spaces/#TensorKit.field"><code>field(a)</code></a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKit.field-man-spaces" href="#TensorKit.field-man-spaces"><code>TensorKit.field</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">field(a) -&gt; Type{ùîΩ&lt;:Field}
field(::Type{T}) -&gt; Type{ùîΩ&lt;:Field}</code></pre><p>Return the type of field over which object <code>a</code> (e.g. a vector space or a tensor) is defined. This also works in type domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/vectorspaces.jl#L43-L49">source</a></section></article><h2 id="ss_elementaryspaces"><a class="docs-heading-anchor" href="#ss_elementaryspaces">Elementary spaces</a><a id="ss_elementaryspaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_elementaryspaces" title="Permalink"></a></h2><p>As mentioned at the beginning of this section, vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of <code>ElementarySpace</code>. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that associated vector spaces, such as the dual space, are objects of the same concrete type (i.e. with the same type parameters in case of a parametric type). In particular, every <code>ElementarySpace</code> should implement the following methods</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.dim-Tuple{ElementarySpace}-man-spaces" href="#TensorKitSectors.dim-Tuple{ElementarySpace}-man-spaces"><code>TensorKitSectors.dim</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(V::VectorSpace) -&gt; Int</code></pre><p>Return the total dimension of the vector space <code>V</code> as an Int.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/vectorspaces.jl#L62-L66">source</a></section><section><div><pre><code class="language-julia hljs">dim(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) where {S&lt;:ElementarySpace}
-&gt; Int</code></pre><p>Return the total degeneracy dimension corresponding to a tuple of sectors for each of the spaces in the tensor product, obtained as <code>prod(dims(P, s))</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/productspace.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKit.field-Tuple{ElementarySpace}-man-spaces" href="#TensorKit.field-Tuple{ElementarySpace}-man-spaces"><code>TensorKit.field</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">field(a) -&gt; Type{ùîΩ&lt;:Field}
field(::Type{T}) -&gt; Type{ùîΩ&lt;:Field}</code></pre><p>Return the type of field over which object <code>a</code> (e.g. a vector space or a tensor) is defined. This also works in type domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/vectorspaces.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKitSectors.dual-Tuple{S} where S&lt;:ElementarySpace-man-spaces" href="#TensorKitSectors.dual-Tuple{S} where S&lt;:ElementarySpace-man-spaces"><code>TensorKitSectors.dual</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dual(V::VectorSpace) -&gt; VectorSpace</code></pre><p>Return the dual space of <code>V</code>; also obtained via <code>V&#39;</code>. This should satisfy <code>dual(dual(V)) == V</code>. It is assumed that <code>typeof(V) == typeof(V&#39;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/vectorspaces.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{S} where S&lt;:ElementarySpace-man-spaces" href="#Base.conj-Tuple{S} where S&lt;:ElementarySpace-man-spaces"><code>Base.conj</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(V::S) where {S&lt;:ElementarySpace} -&gt; S</code></pre><p>Return the conjugate space of <code>V</code>. This should satisfy <code>conj(conj(V)) == V</code>.</p><p>For <code>field(V)==‚Ñù</code>, <code>conj(V) == V</code>. It is assumed that <code>typeof(V) == typeof(conj(V))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/vectorspaces.jl#L221-L227">source</a></section></article><p>For convenience, the dual of a space <code>V</code> can also be obtained as <code>V&#39;</code>. Furthermore, it is sometimes necessary to test whether a space is a dual or conjugate space, for which the methods <a href="../../lib/spaces/#TensorKit.isdual"><code>isdual(::ElementarySpace)</code></a> and <a href="@ref"><code>isconj(::ElementarySpace)</code></a> should be implemented.</p><p>We furthermore define a trait type</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TensorKit.InnerProductStyle-man-spaces" href="#TensorKit.InnerProductStyle-man-spaces"><code>TensorKit.InnerProductStyle</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InnerProductStyle(V::VectorSpace) -&gt; ::InnerProductStyle
InnerProductStyle(S::Type{&lt;:VectorSpace}) -&gt; ::InnerProductStyle</code></pre><p>Return the type of inner product for vector spaces, which can be either</p><ul><li><code>NoInnerProduct()</code>: no mapping from <code>dual(V)</code> to <code>conj(V)</code>, i.e. no metric</li><li>subtype of <code>HasInnerProduct</code>: a metric exists, but no further support is implemented.</li><li><code>EuclideanInnerProduct()</code>: the metric is the identity, such that dual and conjugate spaces are isomorphic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/e8d596d77b34c421fbcc855afafe0fc7f33c9ac0/src/spaces/vectorspaces.jl#L252-L260">source</a></section></article><p>to denote for a vector space <code>V</code> whether it has an inner product and thus a canonical mapping from <code>dual(V)</code> to <code>V</code> (for real fields <code>ùîΩ ‚äÜ ‚Ñù</code>) or from <code>dual(V)</code> to <code>conj(V)</code> (for complex fields). This mapping is provided by the metric, but no further support for working with vector spaces with general metrics is currently implemented.</p><p>A number of concrete elementary spaces are implemented in TensorKit.jl. There is concrete type <code>GeneralSpace</code> which is completely characterized by its field <code>ùîΩ</code>, its dimension and whether its the dual and/or complex conjugate of <span>$ùîΩ^d$</span>.</p><pre><code class="language-julia hljs">struct GeneralSpace{ùîΩ} &lt;: ElementarySpace
    d::Int
    dual::Bool
    conj::Bool
end</code></pre><p>However, as the <code>InnerProductStyle</code> of <code>GeneralSpace</code> is currently set to <code>NoInnerProduct()</code>, this type of vector space is currently quite limited, though it supports constructing tensors and contracting them. However, most tensor factorizations will depend on the presence of an Euclidean inner product.</p><p>Spaces with the <code>EuclideanInnerProduct()</code> style, i.e. with a standard Euclidean metric, have the natural isomorphisms <code>dual(V) == V</code> (for <code>ùîΩ == ‚Ñù</code>) or <code>dual(V) == conj(V)</code> (for <code>ùîΩ == ‚ÑÇ</code>). In the language of the appendix on <a href="../../appendix/categories/#s_categories">categories</a>, this trait represents <a href="../../appendix/categories/#ss_adjoints">dagger or unitary categories</a>, and these vector spaces support an <code>adjoint</code> operation.</p><p>In particular, two concrete types are provided:</p><pre><code class="language-julia hljs">struct CartesianSpace &lt;: ElementarySpace
    d::Int
end
struct ComplexSpace &lt;: ElementarySpace
  d::Int
  dual::Bool
end</code></pre><p>They represent the Euclidean spaces <span>$‚Ñù^d$</span> or <span>$‚ÑÇ^d$</span> without further inner structure. They can be created using the syntax <code>CartesianSpace(d) == ‚Ñù^d</code> and <code>ComplexSpace(d) == ‚ÑÇ^d</code>, or <code>ComplexSpace(d, true) == ComplexSpace(d; dual = true) == (‚ÑÇ^d)&#39;</code> for the dual space of the latter. Note that the brackets are required because of the precedence rules, since <code>d&#39; == d</code> for <code>d::Integer</code>.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(‚Ñù^10)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚Ñù^10)&#39; == ‚Ñù^10</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚ÑÇ^5))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚ÑÇ^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚Ñù^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(‚ÑÇ^5) == (‚ÑÇ^5)&#39; == conj(‚ÑÇ^5) == ComplexSpace(5; dual = true)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(‚ÑÇ^5)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; InnerProductStyle(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">EuclideanInnerProduct()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; InnerProductStyle(‚ÑÇ^5)</code><code class="nohighlight hljs ansi" style="display:block;">EuclideanInnerProduct()</code></pre><div class="admonition is-info" id="Note-244b275fc92895ee"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-244b275fc92895ee" title="Permalink"></a></header><div class="admonition-body"><p>For <code>‚ÑÇ^n</code> the dual space is equal (or naturally isomorphic) to the conjugate space, but not to the space itself. This means that even for <code>‚ÑÇ^n</code>, arrows matter in the diagrammatic notation for categories or for tensors, and in particular that a contraction between two tensor indices will check that one is living in the space and the other in the dual space. This is in contrast with several other software packages, especially in the context of tensor networks, where arrows are only introduced when discussing symmetries. We believe that our more puristic approach can be useful to detect errors (e.g. unintended contractions). Only with <code>‚Ñù^n</code> will their be no distinction between a space and its dual. When creating tensors with indices in <code>‚Ñù^n</code> that have complex data, a one-time warning will be printed, but most operations should continue to work nonetheless.</p></div></div><p>One more important concrete implementation of <code>ElementarySpace</code> with a <code>EuclideanInnerProduct()</code> is the <a href="../../lib/spaces/#TensorKit.GradedSpace"><code>GradedSpace</code></a> type, which is used to represent a graded complex vector space, where the grading is provided by the irreducible representations of a group, or more generally, the simple objects of a unitary fusion category. We refer to the subsection on <a href="../sectors/#ss_rep">graded spaces</a> on the <a href="../sectors/#s_sectorsrepfusion">next page</a> for further information about <code>GradedSpace</code>.</p><h2 id="Operations-with-elementary-spaces"><a class="docs-heading-anchor" href="#Operations-with-elementary-spaces">Operations with elementary spaces</a><a id="Operations-with-elementary-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-with-elementary-spaces" title="Permalink"></a></h2><p>Instances of <code>ElementarySpace</code> support a number of useful operations. Firstly, we define the direct sum of two vector spaces <code>V1</code> and <code>V2</code> of the same <code>spacetype</code> (and with the same value of <code>isdual</code>) as <a href="../../lib/spaces/#TensorKit.:‚äï"><code>V1 ‚äï V2</code></a>, where <code>‚äï</code> is obtained by typing <code>\oplus</code>+TAB. <a href="../../lib/spaces/#TensorKit.zerospace"><code>zerospace(V)</code></a> corresponds to the identity or zero element with respect to this direct sum operation, i.e. it corresponds to a zero-dimensional space. Furthermore, <a href="../../lib/spaces/#TensorKit.unitspace"><code>unitspace(V)</code></a> applied to an elementary space returns a one-dimensional space, that is isomorphic to the scalar field underlying the space itself. Finally, we have also introduced the non-standard convention <code>V1 ‚äñ V2</code> (obtained by typing <code>\ominus</code>+TAB.) in order to obtain a space that is isomorphic to the quotient space of <code>V1</code> by <code>V2</code>, or thus, a particular choice of complement of <code>V2</code> in <code>V1</code> such that <code>V1 == V2 ‚äï (V1 ‚äñ V2)</code> is satisfied. </p><p>Some examples illustrate this better.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù^5 ‚äï ‚Ñù^3</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï (‚ÑÇ^3)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;Direct sum of a vector space and its dual does not exist&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; zerospace(‚ÑÇ^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unitspace(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï unitspace(ComplexSpace)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unitspace((‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5) ‚äï unitspace((‚ÑÇ^5))</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5)&#39; ‚äï unitspace((‚ÑÇ^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;Direct sum of a vector space and its dual does not exist&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚Ñù^5) ‚äñ (‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5) ‚äñ (‚ÑÇ^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5)&#39; ‚äñ (‚ÑÇ^3)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 == ((‚ÑÇ^5) ‚äñ (‚ÑÇ^3)) ‚äï (‚ÑÇ^3) == (‚ÑÇ^3) ‚äï ((‚ÑÇ^5) ‚äñ (‚ÑÇ^3))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Note, finally, that we have defined <code>oplus</code> and <code>ominus</code> as ASCII alternatives for <code>‚äï</code> and <code>‚äñ</code> respectively.</p><p>A second type of operation with elementary spaces is the function <a href="../../lib/spaces/#TensorKit.flip"><code>flip(V::ElementarySpace)</code></a>, which returns a space that is isomorphic to <code>V</code> but has <code>isdual(flip(V)) == isdual(V&#39;)</code>, i.e., if <code>V</code> is a normal space, then <code>flip(V)</code> is a dual space. <code>flip(V)</code> is different from <code>dual(V)</code> in the case of <a href="../../lib/spaces/#TensorKit.GradedSpace"><code>GradedSpace</code></a>. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from <code>V1</code> to <code>flip(V1)</code>.</p><p>While we provide some trivial examples here, we refer to the section on <a href="../sectors/#ss_rep">graded spaces</a> for examples where <code>flip</code> acts non-trivially and produces results that are different than <code>dual</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4) ‚âÖ ‚ÑÇ^4</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4) == ‚ÑÇ^4</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>Finally, we provide two methods <a href="../../lib/spaces/#TensorKit.infimum"><code>infimum(V1, V2)</code></a> and <a href="../../lib/spaces/#TensorKit.supremum"><code>supremum(V1, V2)</code></a> for elementary spaces <code>V1</code> and <code>V2</code> with the same <code>spacetype</code> and value of <code>isdual</code>. The former returns the &quot;largest&quot; elementary space <code>V::ElementarySpace</code> with the same value of <code>isdual</code> such that we can construct surjective morphisms from both <code>V1</code> and <code>V2</code> to <code>V</code>. Similarly, the latter returns the &quot;smallest&quot; elementary space <code>W::ElementarySpace</code> with the same value of <code>isdual</code> such that we can construct injective morphisms from both <code>V1</code> and <code>V2</code> to <code>W</code>. For <code>CartesianSpace</code> and <code>ComplexSpace</code>, this simply amounts to the space with minimal or maximal dimension, but it is again more interesting in the case of <a href="../../lib/spaces/#TensorKit.GradedSpace"><code>GradedSpace</code></a>, as discussed on the <a href="@ref ss_">next page</a>. It is that case where <code>infimum(V1, V2)</code> might be different from either <code>V1</code> or <code>V2</code>, and similar for <code>supremum(V1, V2)</code>, which justifies the choice of these names over simply <code>min</code> and <code>max</code>. Also note that these methods are a direct consequence of the partial order that we can define between vector spaces of the same <code>spacetype</code> more generally, as discussed below in the subsection <a href="#ss_spaceops">&quot;More operations with vector spaces&quot;</a>.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(‚Ñù^5, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(‚ÑÇ^5, ‚ÑÇ^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(‚ÑÇ^5, (‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;Supremum of space and dual space does not exist&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum((‚ÑÇ^5)&#39;, (‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^5)&#39;</code></pre><h2 id="ss_compositespaces"><a class="docs-heading-anchor" href="#ss_compositespaces">Composite spaces</a><a id="ss_compositespaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_compositespaces" title="Permalink"></a></h2><p>Composite spaces are vector spaces that are built up out of individual elementary vector spaces of the same type. The most prominent (and currently only) example is a tensor product of <code>N</code> elementary spaces of the same type <code>S</code>, which is implemented as</p><pre><code class="language-julia hljs">struct ProductSpace{S&lt;:ElementarySpace, N} &lt;: CompositeSpace{S}
    spaces::NTuple{N, S}
end</code></pre><p>Given some <code>V1::S</code>, <code>V2::S</code>, <code>V3::S</code> of the same type <code>S&lt;:ElementarySpace</code>, we can easily construct <code>ProductSpace{S,3}((V1, V2, V3))</code> as <code>ProductSpace(V1, V2, V3)</code> or using <code>V1 ‚äó V2 ‚äó V3</code>, where <code>‚äó</code> is simply obtained by typing <code>\otimes</code>+TAB. In fact, for convenience, also the regular multiplication operator <code>*</code> acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚ÑÇ^2</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 ‚äó V2 ‚äó V1&#39; == V1 * V2 * V1&#39; == ProductSpace(V1, V2, V1&#39;) == ProductSpace(V1, V2) ‚äó V1&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1^3</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">(2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1 ‚äó V2 ‚äó V1&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó (‚ÑÇ^3)&#39; ‚äó (‚ÑÇ^2)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(ProductSpace{ComplexSpace,3})</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code></pre><p>Here, the newly introduced function <code>dims</code> maps <code>dim</code> to the individual spaces in a <code>ProductSpace</code> and returns the result as a tuple. The rationale for the dual space of a <code>ProductSpace</code> being the tensor product of the dual spaces in reverse order is explained in the subsection on <a href="../../appendix/categories/#ss_dual">duality</a> in the appendix on <a href="../../appendix/categories/#s_categories">category theory</a>.</p><p>Following Julia&#39;s Base library, the function <code>one</code> applied to an instance of <code>ProductSpace{S,N}</code> or of <code>S&lt;:ElementarySpace</code> itself returns the multiplicative identity for these objects. Similar to Julia Base, <code>one</code> also works in the type domain. The multiplicative identity for vector spaces corresponds to the (monoidal) unit, which is represented as <code>ProductSpace{S,0}(())</code> and simply printed as <code>one(S)</code> for the specific type <code>S</code>. Note, however, that <code>one(S)</code> is strictly speaking only the multiplicative identity when multiplied with <code>ProductSpace{S,N}</code> instances. For elementary spaces <code>V::S</code>, <code>V ‚äó one(V)</code> will yield <code>ProductSpace{S,1}(V)</code> and not <code>V</code> itself. However, even though <code>V ‚äó one(V)</code> is not strictly equal to <code>V</code>, the object <code>ProductSpace(V)</code>, which can also be created as <code>‚äó(V)</code>, does mathematically encapsulate the same vector space as <code>V</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(V1)</code><code class="nohighlight hljs ansi" style="display:block;">one(ComplexSpace)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(one(V1))</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace{ComplexSpace, 0}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 * one(V1) == ProductSpace(V1) == ‚äó(V1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 * one(V1) == V1</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = V1 * V2;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(P)</code><code class="nohighlight hljs ansi" style="display:block;">one(ComplexSpace)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(typeof(P))</code><code class="nohighlight hljs ansi" style="display:block;">one(ComplexSpace)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P * one(P) == P == one(P) ‚äó P</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>In the future, other <code>CompositeSpace</code> types could be added. For example, the wave function of an <code>N</code>-particle quantum system in first quantization would require the introduction of a <code>SymmetricSpace{S,N}</code> or a <code>AntiSymmetricSpace{S,N}</code> for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of <code>V^N</code>, where <code>V::S</code> represents the Hilbert space of the single particle system. Other scientific fields, like general relativity, might also benefit from tensors living in subspace with certain symmetries under specific index permutations.</p><h2 id="ss_spaceops"><a class="docs-heading-anchor" href="#ss_spaceops">More operations with vector spaces</a><a id="ss_spaceops-1"></a><a class="docs-heading-anchor-permalink" href="#ss_spaceops" title="Permalink"></a></h2><p>Vector spaces of the same <code>spacetype</code> can be given a partial order, based on whether there exist injective morphisms (a.k.a <em>monomorphisms</em>) or surjective morphisms (a.k.a. <em>epimorphisms</em>) between them. In particular, we define <code>ismonomorphic(V1, V2)</code>, with Unicode synonym <code>V1 ‚âæ V2</code> (obtained as <code>\precsim+TAB</code>), to express whether there exist monomorphisms in <code>V1‚ÜíV2</code>. Similarly, we define <code>isepimorphic(V1, V2)</code>, with Unicode synonym <code>V1 ‚âø V2</code> (obtained as <code>\succsim+TAB</code>), to express whether there exist epimorphisms in <code>V1‚ÜíV2</code>. Finally, we define <code>isisomorphic(V1, V2)</code>, with Unicode alternative <code>V1 ‚âÖ V2</code> (obtained as <code>\cong+TAB</code>), to express whether there exist isomorphism in <code>V1‚ÜíV2</code>. In particular <code>V1 ‚âÖ V2</code> if and only if <code>V1 ‚âæ V2 &amp;&amp; V1 ‚âø V2</code>.</p><p>For completeness, we also export the strict comparison operators <code>‚â∫</code> and <code>‚âª</code>  (<code>\prec+TAB</code> and <code>\succ+TAB</code>), with definitions</p><pre><code class="language-julia hljs">‚â∫(V1::VectorSpace, V2::VectorSpace) = V1 ‚âæ V2 &amp;&amp; !(V1 ‚âø V2)
‚âª(V1::VectorSpace, V2::VectorSpace) = V1 ‚âø V2 &amp;&amp; !(V1 ‚âæ V2)</code></pre><p>However, as we expect these to be less commonly used, no ASCII alternative is provided.</p><p>In the context of <code>InnerProductStyle(V) &lt;: EuclideanInnerProduct</code>, <code>V1 ‚âæ V2</code> implies that there exists isometries <span>$W:V1 ‚Üí V2$</span> such that <span>$W^‚Ä† ‚àò W = \mathrm{id}_{V1}$</span>, while <code>V1 ‚âÖ V2</code> implies that there exist unitaries <span>$U:V1‚ÜíV2$</span> such that <span>$U^‚Ä† ‚àò U = \mathrm{id}_{V1}$</span> and <span>$U ‚àò U^‚Ä† = \mathrm{id}_{V2}$</span>.</p><p>Note that spaces that are isomorphic are not necessarily equal. One can be a dual space, and the other a normal space, or one can be an instance of <code>ProductSpace</code>, while the other is an <code>ElementarySpace</code>. There will exist (infinitely) many isomorphisms between the corresponding spaces, but in general none of those will be canonical.</p><p>There are also a number of convenience functions to create isomorphic spaces. The function <code>fuse(V1, V2, ...)</code> or <code>fuse(V1 ‚äó V2 ‚äó ...)</code> returns an elementary space that is isomorphic to <code>V1 ‚äó V2 ‚äó ...</code>.</p><h2 id="ss_homspaces"><a class="docs-heading-anchor" href="#ss_homspaces">Space of morphisms</a><a id="ss_homspaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_homspaces" title="Permalink"></a></h2><p>As mentioned in the introduction, we define tensor maps as linear maps from a <code>ProductSpace</code> domain to a <code>ProductSpace</code> codomain. The set of all tensor maps with a fixed domain and codomain constitutes a vector space, which we represent with the <code>HomSpace</code> type.</p><pre><code class="language-julia hljs">struct HomSpace{S&lt;:ElementarySpace, P1&lt;:CompositeSpace{S}, P2&lt;:CompositeSpace{S}}
    codomain::P1
    domain::P2
end</code></pre><p>Aside from the standard constructor, a <code>HomSpace</code> instance can be created as either <code>domain ‚Üí codomain</code> or <code>codomain ‚Üê domain</code> (where the arrows are obtained as <code>\to+TAB</code> or <code>\leftarrow+TAB</code>, and as <code>\rightarrow+TAB</code> respectively). The reason for first listing the codomain and than the domain will become clear in the <a href="../tensors/#s_tensors">section on tensor maps</a>.</p><p>Note that <code>HomSpace</code> is not a subtype of <code>VectorSpace</code>, i.e. we restrict the latter to encode all spaces and generalizations thereof (i.e. objects in linear monoidal categories) that are associated with the indices and the domain and codomain of a tensor map. Even when these generalizations are no longer strictly vector spaces and have unconventional properties (such as non-integer dimensions), the space of tensor maps (homomorphisms) between a given domain and codomain, represented by a <code>HomSpace</code> instance, is always a vector space in the strict mathematical sense (with in particular an integer dimension). Because <code>HomSpace</code> and the different subtypes of <code>VectorSpace</code> represent very different mathematical concepts that do not directly interact, we have chosen to keep them separate in the type hierarchy.</p><p>Furthermore, on these <code>HomSpace</code> instances, we define a number of useful methods that are a precursor to the corresponding methods that we will define to manipulate the actual tensors, as illustrated in the following example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üí ‚ÑÇ^3 ‚äó dual(‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(W)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(W)</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^3)&#39; ‚äó (‚ÑÇ^2)&#39;) ‚Üê (‚ÑÇ^4 ‚äó (‚ÑÇ^3)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; adjoint(W)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê (‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(W)</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(typeof(W))</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[1]</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[2]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[3]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[4]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W)</code><code class="nohighlight hljs ansi" style="display:block;">72</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(W)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(W)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numin(W)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numout(W)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numind(W)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numind(W) == numin(W) + numout(W)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; permute(W, ((2, 3), (1, 4)))</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^4)&#39; ‚äó (‚ÑÇ^2)&#39;) ‚Üê ((‚ÑÇ^3)&#39; ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(W, 3)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê ((‚ÑÇ^2)&#39; ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; insertleftunit(W, 3)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê (‚ÑÇ^1 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; insertrightunit(W, 2)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39; ‚äó ‚ÑÇ^1) ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; removeunit(insertrightunit(W, 2), 3)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; TensorKit.compose(W, adjoint(W))</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê (‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;)</code></pre><p>Note that indexing <code>W</code> follows an order that first targets the spaces in the codomain, followed by the dual of the spaces in the domain. This particular convention is useful in combination with the instances of type <a href="../../lib/tensors/#TensorKit.TensorMap"><code>TensorMap</code></a>, which represent the actual morphisms living in such a <code>HomSpace</code>. Also note that <code>dim(W)</code> is here given by the product of the dimensions of the individual spaces, but that this is no longer true once symmetries are involved. At any time will <code>dim(::HomSpace)</code> represent the number of linearly independent morphisms in this space, or thus, the number of independent components that a corresponding <code>TensorMap</code> object will have.</p><p>A complete list of methods defined on <code>HomSpace</code> instances together with the corresponding documentation is provided in the <a href="../../lib/spaces/#s_libvectorspaces">library section on Vector spaces</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">¬´ Tutorial</a><a class="docs-footer-nextpage" href="../sectors/">Sectors, graded spaces and fusion trees ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 21 October 2025 22:42">Tuesday 21 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
