<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensors ¬∑ TensorKit.jl</title><meta name="title" content="Tensors ¬∑ TensorKit.jl"/><meta property="og:title" content="Tensors ¬∑ TensorKit.jl"/><meta property="twitter:title" content="Tensors ¬∑ TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Introduction</a></li><li><a class="tocitem" href="../../man/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../man/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../man/symmetries/">Symmetries</a></li><li><a class="tocitem" href="../../man/sectors/">Sectors</a></li><li><a class="tocitem" href="../../man/gradedspaces/">Graded spaces</a></li><li><a class="tocitem" href="../../man/fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../../man/tensors/">Constructing tensors and the <code>TensorMap</code> type</a></li><li><a class="tocitem" href="../../man/tensormanipulations/">Manipulating tensors</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../sectors/">Symmetry sectors</a></li><li><a class="tocitem" href="../fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li class="is-active"><a class="tocitem" href>Tensors</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#TensorMap-constructors"><span><code>TensorMap</code> constructors</span></a></li><li><a class="tocitem" href="#AbstractTensorMap-properties-and-data-access"><span><code>AbstractTensorMap</code> properties and data access</span></a></li><li><a class="tocitem" href="#AbstractTensorMap-operations"><span><code>AbstractTensorMap</code> operations</span></a></li><li><a class="tocitem" href="#TensorMap-factorizations"><span><code>TensorMap</code> factorizations</span></a></li></ul></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/symmetric_tutorial/">A symmetric tensor deep dive: constructing your first tensor map</a></li><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li><li><a class="tocitem" href="../../Changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Tensors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tensors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/lib/tensors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tensors"><a class="docs-heading-anchor" href="#Tensors">Tensors</a><a id="Tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Tensors" title="Permalink"></a></h1><h2 id="Type-hierarchy"><a class="docs-heading-anchor" href="#Type-hierarchy">Type hierarchy</a><a id="Type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy" title="Permalink"></a></h2><p>The abstract supertype of all tensors in TensorKit is given by <code>AbstractTensorMap</code>:</p><article><details class="docstring" open="true"><summary id="TensorKit.AbstractTensorMap"><a class="docstring-binding" href="#TensorKit.AbstractTensorMap"><code>TensorKit.AbstractTensorMap</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractTensorMap{T&lt;:Number, S&lt;:IndexSpace, N‚ÇÅ, N‚ÇÇ} end</code></pre><p>Abstract supertype of all tensor maps, i.e. linear maps between tensor products of vector spaces of type <code>S&lt;:IndexSpace</code>, with element type <code>T</code>. An <code>AbstractTensorMap</code> maps from an input space of type <code>ProductSpace{S, N‚ÇÇ}</code> to an output space of type <code>ProductSpace{S, N‚ÇÅ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L5-L11">source</a></section></details></article><p>The following concrete subtypes are provided within the TensorKit library:</p><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap"><a class="docstring-binding" href="#TensorKit.TensorMap"><code>TensorKit.TensorMap</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TensorMap{T, S&lt;:IndexSpace, N‚ÇÅ, N‚ÇÇ, A&lt;:DenseVector{T}} &lt;: AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}</code></pre><p>Specific subtype of <a href="#TensorKit.AbstractTensorMap"><code>AbstractTensorMap</code></a> for representing tensor maps (morphisms in a tensor category), where the data is stored in a dense vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L4-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.DiagonalTensorMap"><a class="docstring-binding" href="#TensorKit.DiagonalTensorMap"><code>TensorKit.DiagonalTensorMap</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiagonalTensorMap{T}(undef, domain::S) where {T,S&lt;:IndexSpace}
# expert mode: select storage type `A`
DiagonalTensorMap{T,S,A}(undef, domain::S) where {T,S&lt;:IndexSpace,A&lt;:DenseVector{T}}</code></pre><p>Construct a <code>DiagonalTensorMap</code> with uninitialized data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/diagonal.jl#L35-L41">source</a></section><section><div><pre><code class="language-julia hljs">DiagonalTensorMap(s::SectorVector)</code></pre><p>Construct a <code>DiagonalTensorMap</code> directly from a <code>SectorVector</code>, from which the codomain (assumed non-dual) is inferred automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/diagonal.jl#L91-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.AdjointTensorMap"><a class="docstring-binding" href="#TensorKit.AdjointTensorMap"><code>TensorKit.AdjointTensorMap</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct AdjointTensorMap{T, S, N‚ÇÅ, N‚ÇÇ, TT&lt;:AbstractTensorMap} &lt;: AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}</code></pre><p>Specific subtype of <a href="#TensorKit.AbstractTensorMap"><code>AbstractTensorMap</code></a> that is a lazy wrapper for representing the adjoint of an instance of <a href="#TensorKit.AbstractTensorMap"><code>AbstractTensorMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/adjoint.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.BraidingTensor"><a class="docstring-binding" href="#TensorKit.BraidingTensor"><code>TensorKit.BraidingTensor</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BraidingTensor{T,S&lt;:IndexSpace} &lt;: AbstractTensorMap{T, S, 2, 2}
BraidingTensor(V1::S, V2::S, adjoint::Bool=false) where {S&lt;:IndexSpace}</code></pre><p>Specific subtype of <a href="#TensorKit.AbstractTensorMap"><code>AbstractTensorMap</code></a> for representing the braiding tensor that braids the first input over the second input; its inverse can be obtained as the adjoint.</p><p>It holds that <code>domain(BraidingTensor(V1, V2)) == V1 ‚äó V2</code> and <code>codomain(BraidingTensor(V1, V2)) == V2 ‚äó V1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/braidingtensor.jl#L4-L13">source</a></section></details></article><p>Of those, <code>TensorMap</code> provides the generic instantiation of our tensor concept. It supports various constructors, which are discussed in the next subsection.</p><p>Furthermore, some aliases are provided for convenience:</p><article><details class="docstring" open="true"><summary id="TensorKit.AbstractTensor"><a class="docstring-binding" href="#TensorKit.AbstractTensor"><code>TensorKit.AbstractTensor</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractTensor{T,S,N} = AbstractTensorMap{T,S,N,0}</code></pre><p>Abstract supertype of all tensors, i.e. elements in the tensor product space of type <code>ProductSpace{S, N}</code>, with element type <code>T</code>.</p><p>An <code>AbstractTensor{T, S, N}</code> is actually a special case <code>AbstractTensorMap{T, S, N, 0}</code>, i.e. a tensor map with only non-trivial output spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L14-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.Tensor"><a class="docstring-binding" href="#TensorKit.Tensor"><code>TensorKit.Tensor</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Tensor{T, S, N, A&lt;:DenseVector{T}} = TensorMap{T, S, N, 0, A}</code></pre><p>Specific subtype of <a href="#TensorKit.AbstractTensor"><code>AbstractTensor</code></a> for representing tensors whose data is stored in a dense vector.</p><p>A <code>Tensor{T, S, N, A}</code> is actually a special case <code>TensorMap{T, S, N, 0, A}</code>, i.e. a tensor map with only a non-trivial output space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L40-L48">source</a></section></details></article><h2 id="TensorMap-constructors"><a class="docs-heading-anchor" href="#TensorMap-constructors"><code>TensorMap</code> constructors</a><a id="TensorMap-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#TensorMap-constructors" title="Permalink"></a></h2><h3 id="General-constructors"><a class="docs-heading-anchor" href="#General-constructors">General constructors</a><a id="General-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#General-constructors" title="Permalink"></a></h3><p>A <code>TensorMap</code> with undefined data can be constructed by specifying its domain and codomain:</p><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Union{Tuple{T}, Tuple{UndefInitializer, TensorMapSpace}} where T"><a class="docstring-binding" href="#TensorKit.TensorMap-Union{Tuple{T}, Tuple{UndefInitializer, TensorMapSpace}} where T"><code>TensorKit.TensorMap</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap{T}(undef, codomain::ProductSpace{S, N‚ÇÅ}, domain::ProductSpace{S, N‚ÇÇ}) where {T, S, N‚ÇÅ, N‚ÇÇ}
TensorMap{T}(undef, codomain ‚Üê domain)
TensorMap{T}(undef, domain ‚Üí codomain)</code></pre><p>Construct a <code>TensorMap</code> with uninitialized data with elements of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L82-L88">source</a></section></details></article><p>The resulting object can then be filled with data using the <code>setindex!</code> method as discussed below, using functions such as <code>VectorInterface.zerovector!</code>, <code>rand!</code> or <code>fill!</code>, or it can be used as an output argument in one of the many methods that accept output arguments, or in an <code>@tensor output[...] = ...</code> expression.</p><p>Alternatively, a <code>TensorMap</code> can be constructed by specifying its data, codomain and domain in one of the following ways:</p><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Tuple{AbstractDict{&lt;:Sector, &lt;:AbstractMatrix}, TensorMapSpace}"><a class="docstring-binding" href="#TensorKit.TensorMap-Tuple{AbstractDict{&lt;:Sector, &lt;:AbstractMatrix}, TensorMapSpace}"><code>TensorKit.TensorMap</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap(data::AbstractDict{&lt;:Sector, &lt;:AbstractMatrix}, codomain::ProductSpace, domain::ProductSpace)
TensorMap(data, codomain ‚Üê domain)
TensorMap(data, domain ‚Üí codomain)</code></pre><p>Construct a <code>TensorMap</code> by explicitly specifying its block data.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractDict{&lt;:Sector, &lt;:AbstractMatrix}</code>: dictionary containing the block data for each coupled sector <code>c</code> as a matrix of size <code>(blockdim(codomain, c), blockdim(domain, c))</code>.</li><li><code>codomain::ProductSpace{S, N‚ÇÅ}</code>: the codomain as a <code>ProductSpace</code> of <code>N‚ÇÅ</code> spaces of type <code>S &lt;: ElementarySpace</code>.</li><li><code>domain::ProductSpace{S, N‚ÇÇ}</code>: the domain as a <code>ProductSpace</code> of <code>N‚ÇÇ</code> spaces of type <code>S &lt;: ElementarySpace</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L242-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Tuple{AbstractArray, TensorMapSpace}"><a class="docstring-binding" href="#TensorKit.TensorMap-Tuple{AbstractArray, TensorMapSpace}"><code>TensorKit.TensorMap</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap(data::AbstractArray, codomain::ProductSpace{S,N‚ÇÅ}, domain::ProductSpace{S,N‚ÇÇ};
                tol=sqrt(eps(real(float(eltype(data)))))) where {S&lt;:ElementarySpace,N‚ÇÅ,N‚ÇÇ}
TensorMap(data, codomain ‚Üê domain; tol=sqrt(eps(real(float(eltype(data))))))
TensorMap(data, domain ‚Üí codomain; tol=sqrt(eps(real(float(eltype(data))))))</code></pre><p>Construct a <code>TensorMap</code> from a plain multidimensional array.</p><p><strong>Arguments</strong></p><ul><li><code>data::DenseArray</code>: tensor data as a plain array.</li><li><code>codomain::ProductSpace{S,N‚ÇÅ}</code>: the codomain as a <code>ProductSpace</code> of <code>N‚ÇÅ</code> spaces of type <code>S&lt;:ElementarySpace</code>.</li><li><code>domain::ProductSpace{S,N‚ÇÇ}</code>: the domain as a <code>ProductSpace</code> of <code>N‚ÇÇ</code> spaces of type <code>S&lt;:ElementarySpace</code>.</li><li><code>tol=sqrt(eps(real(float(eltype(data)))))::Float64</code>: </li></ul><p>Here, <code>data</code> can be specified in three ways:</p><ol><li><code>data</code> can be a <code>DenseVector</code> of length <code>dim(codomain ‚Üê domain)</code>; in that case it represents the actual independent entries of the tensor map. An instance will be created that directly references <code>data</code>.</li><li><code>data</code> can be an <code>AbstractMatrix</code> of size <code>(dim(codomain), dim(domain))</code></li><li><code>data</code> can be an <code>AbstractArray</code> of rank <code>N‚ÇÅ + N‚ÇÇ</code> with a size matching that of the domain and codomain spaces, i.e. <code>size(data) == (dims(codomain)..., dims(domain)...)</code></li></ol><p>In cases 2 and 3, the <code>TensorMap</code> constructor will reconstruct the tensor data such that the resulting tensor <code>t</code> satisfies <code>data == convert(Array, t)</code>, up to an error specified by <code>tol</code>. For the case where <code>sectortype(S) == Trivial</code> and <code>data isa DenseArray</code>, the <code>data</code> array is simply reshaped into a vector and used as in case 1 so that the memory will still be shared. In other cases, new memory will be allocated.</p><p>Note that in the case of <code>N‚ÇÅ + N‚ÇÇ = 1</code>, case 3 also amounts to <code>data</code> being a vector, whereas when <code>N‚ÇÅ + N‚ÇÇ == 2</code>, case 2 and case 3 both require <code>data</code> to be a matrix. Such ambiguous cases are resolved by checking the size of <code>data</code> in an attempt to support all possible cases.</p><div class="admonition is-info" id="Note-b15342ce4624b8db"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b15342ce4624b8db" title="Permalink"></a></header><div class="admonition-body"><p>This constructor for case 2 and 3 only works for <code>sectortype</code> values for which conversion to a plain array is possible, and only in the case where the <code>data</code> actually respects the specified symmetry structure, up to a tolerance <code>tol</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L159-L196">source</a></section></details></article><p>Finally, we also support the following <code>Array</code>-like constructors</p><article><details class="docstring" open="true"><summary id="Base.zeros-Tuple{Type, TensorMapSpace}"><a class="docstring-binding" href="#Base.zeros-Tuple{Type, TensorMapSpace}"><code>Base.zeros</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">zeros([T=Float64,], codomain::ProductSpace{S,N‚ÇÅ}, domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T}
zeros([T=Float64,], codomain ‚Üê domain)</code></pre><p>Create a <code>TensorMap</code> with element type <code>T</code>, of all zeros with spaces specified by <code>codomain</code> and <code>domain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L285-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.ones-Tuple{Type, TensorMapSpace}"><a class="docstring-binding" href="#Base.ones-Tuple{Type, TensorMapSpace}"><code>Base.ones</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ones([T=Float64,], codomain::ProductSpace{S,N‚ÇÅ}, domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T}
ones([T=Float64,], codomain ‚Üê domain)</code></pre><p>Create a <code>TensorMap</code> with element type <code>T</code>, of all ones with spaces specified by <code>codomain</code> and <code>domain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L293-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{Type, TensorMapSpace}"><a class="docstring-binding" href="#Base.rand-Tuple{Type, TensorMapSpace}"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rand([rng=default_rng()], [TorA=Float64], codomain::ProductSpace{S,N‚ÇÅ},
             domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T} -&gt; t
rand([rng=default_rng()], [TorA=Float64], codomain ‚Üê domain) -&gt; t</code></pre><p>Generate a tensor <code>t</code> with entries generated by <code>rand</code>. The type <code>TorA</code> can be used to control the element type and data type generated. For example, if <code>TorA</code> is a <code>CuVector{ComplexF32}</code> or <code>ROCVector{Float64}</code>, then the final output <code>TensorMap</code> will have that as its storage type.</p><p>See also <a href="#Random.rand!"><code>Random.rand!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L353-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.randn-Tuple{Type, TensorMapSpace}"><a class="docstring-binding" href="#Base.randn-Tuple{Type, TensorMapSpace}"><code>Base.randn</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">randn([rng=default_rng()], [TorA=Float64], codomain::ProductSpace{S,N‚ÇÅ},
             domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T} -&gt; t
randn([rng=default_rng()], [TorA=Float64], codomain ‚Üê domain) -&gt; t</code></pre><p>Generate a tensor <code>t</code> with entries generated by <code>randn</code>. The type <code>TorA</code> can be used to control the element type and data type generated. For example, if <code>TorA</code> is a <code>CuVector{ComplexF32}</code> or <code>ROCVector{Float64}</code>, then the final output <code>TensorMap</code> will have that as its storage type.</p><p>See also <a href="#Random.randn!"><code>Random.randn!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L353-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Random.randexp-Tuple{Type, TensorMapSpace}"><a class="docstring-binding" href="#Random.randexp-Tuple{Type, TensorMapSpace}"><code>Random.randexp</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">randexp([rng=default_rng()], [TorA=Float64], codomain::ProductSpace{S,N‚ÇÅ},
             domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T} -&gt; t
randexp([rng=default_rng()], [TorA=Float64], codomain ‚Üê domain) -&gt; t</code></pre><p>Generate a tensor <code>t</code> with entries generated by <code>randexp</code>. The type <code>TorA</code> can be used to control the element type and data type generated. For example, if <code>TorA</code> is a <code>CuVector{ComplexF32}</code> or <code>ROCVector{Float64}</code>, then the final output <code>TensorMap</code> will have that as its storage type.</p><p>See also <a href="#Random.randexp!"><code>Random.randexp!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L353-L365">source</a></section></details></article><p>as well as a <code>similar</code> constructor</p><article><details class="docstring" open="true"><summary id="Base.similar-Tuple{AbstractTensorMap, Vararg{Any}}"><a class="docstring-binding" href="#Base.similar-Tuple{AbstractTensorMap, Vararg{Any}}"><code>Base.similar</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">similar(t::AbstractTensorMap, [AorT=storagetype(t)], [V=space(t)])
similar(t::AbstractTensorMap, [AorT=storagetype(t)], codomain, domain)</code></pre><p>Creates an uninitialized mutable tensor with the given scalar or storagetype <code>AorT</code> and structure <code>V</code> or <code>codomain ‚Üê domain</code>, based on the source tensormap. The second and third arguments are both optional, defaulting to the given tensor&#39;s <code>storagetype</code> and <code>space</code>. The structure may be specified either as a single <code>HomSpace</code> argument or as <code>codomain</code> and <code>domain</code>.</p><p>By default, this will result in <code>TensorMap{T}(undef, V)</code> when custom objects do not specialize this method.</p><p>See also <a href="@ref"><code>similar_diagonal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L623-L637">source</a></section></details></article><h3 id="Specific-constructors"><a class="docs-heading-anchor" href="#Specific-constructors">Specific constructors</a><a id="Specific-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-constructors" title="Permalink"></a></h3><p>Additionally, the following methods can be used to construct specific <code>TensorMap</code> instances.</p><article><details class="docstring" open="true"><summary id="TensorKit.id"><a class="docstring-binding" href="#TensorKit.id"><code>TensorKit.id</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">id([T::Type=Float64,] V::TensorSpace) -&gt; TensorMap
id!(t::AbstractTensorMap) -&gt; AbstractTensorMap</code></pre><p>Construct the identity endomorphism on space <code>V</code>, i.e. return a <code>t::TensorMap</code> with <code>domain(t) == codomain(t) == V</code>, where either <code>scalartype(t) = T</code> if <code>T</code> is a <code>Number</code> type or <code>storagetype(t) = T</code> if <code>T</code> is a <code>DenseVector</code> type.</p><p>See also <a href="@ref"><code>one!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/linalg.jl#L66-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.isomorphism"><a class="docstring-binding" href="#TensorKit.isomorphism"><code>TensorKit.isomorphism</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isomorphism([T::Type=Float64,] codomain::TensorSpace, domain::TensorSpace) -&gt; TensorMap
isomorphism([T::Type=Float64,] codomain ‚Üê domain) -&gt; TensorMap
isomorphism([T::Type=Float64,] domain ‚Üí codomain) -&gt; TensorMap
isomorphism!(t::AbstractTensorMap) -&gt; AbstractTensorMap</code></pre><p>Construct a specific isomorphism between the codomain and the domain, i.e. return a <code>t::TensorMap</code> where either <code>scalartype(t) = T</code> if <code>T</code> is a <code>Number</code> type or <code>storagetype(t) = T</code> if <code>T</code> is a <code>DenseVector</code> type. If the spaces are not isomorphic, an error will be thrown.</p><div class="admonition is-info" id="Note-2edab6ac0c0ceca5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2edab6ac0c0ceca5" title="Permalink"></a></header><div class="admonition-body"><p>There is no canonical choice for a specific isomorphism, but the current choice is such that <code>isomorphism(cod, dom) == inv(isomorphism(dom, cod))</code>.</p></div></div><p>See also <a href="#TensorKit.unitary"><code>unitary</code></a> when <code>InnerProductStyle(cod) === EuclideanInnerProduct()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/linalg.jl#L86-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.unitary"><a class="docstring-binding" href="#TensorKit.unitary"><code>TensorKit.unitary</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unitary([T::Type=Float64,] codomain::TensorSpace, domain::TensorSpace) -&gt; TensorMap
unitary([T::Type=Float64,] codomain ‚Üê domain) -&gt; TensorMap
unitary([T::Type=Float64,] domain ‚Üí codomain) -&gt; TensorMap
unitary!(t::AbstractTensorMap) -&gt; AbstractTensorMap</code></pre><p>Construct a specific unitary morphism between the codomain and the domain, i.e. return a <code>t::TensorMap</code> where either <code>scalartype(t) = T</code> if <code>T</code> is a <code>Number</code> type or <code>storagetype(t) = T</code> if <code>T</code> is a <code>DenseVector</code> type. If the spaces are not isomorphic, or the spacetype does not have a Euclidean inner product, an error will be thrown.</p><div class="admonition is-info" id="Note-a1dcee79989ea0f1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a1dcee79989ea0f1" title="Permalink"></a></header><div class="admonition-body"><p>There is no canonical choice for a specific unitary, but the current choice is such that <code>unitary(cod, dom) == inv(unitary(dom, cod)) = adjoint(unitary(dom, cod))</code>.</p></div></div><p>See also <a href="#TensorKit.isomorphism"><code>isomorphism</code></a> and <a href="#TensorKit.isometry"><code>isometry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/linalg.jl#L113-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.isometry"><a class="docstring-binding" href="#TensorKit.isometry"><code>TensorKit.isometry</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isometry([T::Type=Float64,] codomain::TensorSpace, domain::TensorSpace) -&gt; TensorMap
isometry([T::Type=Float64,] codomain ‚Üê domain) -&gt; TensorMap
isometry([T::Type=Float64,] domain ‚Üí codomain) -&gt; TensorMap
isometry!(t::AbstractTensorMap) -&gt; AbstractTensorMap</code></pre><p>Construct a specific isometry between the codomain and the domain, i.e. return a <code>t::TensorMap</code> where either <code>scalartype(t) = T</code> if <code>T</code> is a <code>Number</code> type or <code>storagetype(t) = T</code> if <code>T</code> is a <code>DenseVector</code> type. The isometry <code>t</code> then satisfies <code>t&#39; * t = id(domain)</code> and <code>(t * t&#39;)^2 = t * t&#39;</code>. If the spaces do not allow for such an  isometric inclusion, an error will be thrown.</p><p>See also <a href="#TensorKit.isomorphism"><code>isomorphism</code></a> and <a href="#TensorKit.unitary"><code>unitary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/linalg.jl#L136-L149">source</a></section></details></article><h2 id="AbstractTensorMap-properties-and-data-access"><a class="docs-heading-anchor" href="#AbstractTensorMap-properties-and-data-access"><code>AbstractTensorMap</code> properties and data access</a><a id="AbstractTensorMap-properties-and-data-access-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTensorMap-properties-and-data-access" title="Permalink"></a></h2><p>The following methods exist to obtain type information:</p><article><details class="docstring" open="true"><summary id="Base.eltype-Union{Tuple{Type{&lt;:AbstractTensorMap{T}}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.eltype-Union{Tuple{Type{&lt;:AbstractTensorMap{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eltype(::AbstractTensorMap) -&gt; Type{T}
eltype(::Type{&lt;:AbstractTensorMap}) -&gt; Type{T}</code></pre><p>Return the scalar or element type <code>T</code> of a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L27-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.spacetype-Union{Tuple{Type{&lt;:AbstractTensorMap{&lt;:Any, S}}}, Tuple{S}} where S"><a class="docstring-binding" href="#TensorKit.spacetype-Union{Tuple{Type{&lt;:AbstractTensorMap{&lt;:Any, S}}}, Tuple{S}} where S"><code>TensorKit.spacetype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spacetype(a) -&gt; Type{S &lt;: IndexSpace}
spacetype(::Type) -&gt; Type{S &lt;: IndexSpace}</code></pre><p>Return the type of the elementary space <code>S</code> of object <code>a</code> (e.g. a tensor). Also works in type domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/spaces/vectorspaces.jl#L378-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.sectortype-Union{Tuple{Type{TT}}, Tuple{TT}} where TT&lt;:AbstractTensorMap"><a class="docstring-binding" href="#TensorKit.sectortype-Union{Tuple{Type{TT}}, Tuple{TT}} where TT&lt;:AbstractTensorMap"><code>TensorKit.sectortype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sectortype(a) -&gt; Type{&lt;:Sector}
sectortype(::Type) -&gt; Type{&lt;:Sector}</code></pre><p>Return the type of sector over which object <code>a</code> (e.g. a representation space or a tensor) is defined. Also works in type domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/spaces/vectorspaces.jl#L340-L346">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.field-Union{Tuple{Type{TT}}, Tuple{TT}} where TT&lt;:AbstractTensorMap"><a class="docstring-binding" href="#TensorKit.field-Union{Tuple{Type{TT}}, Tuple{TT}} where TT&lt;:AbstractTensorMap"><code>TensorKit.field</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">field(a) -&gt; Type{ùîΩ &lt;: Field}
field(::Type{T}) -&gt; Type{ùîΩ &lt;: Field}</code></pre><p>Return the type of field over which object <code>a</code> (e.g. a vector space or a tensor) is defined. This also works in type domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/spaces/vectorspaces.jl#L43-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.storagetype"><a class="docstring-binding" href="#TensorKit.storagetype"><code>TensorKit.storagetype</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">storagetype(t::AbstractTensorMap) -&gt; Type{A&lt;:AbstractVector}
storagetype(T::Type{&lt;:AbstractTensorMap}) -&gt; Type{A&lt;:AbstractVector}</code></pre><p>Return the type of vector that stores the data of a tensor. If this is not overloaded for a given tensor type, the default value of <code>storagetype(scalartype(t))</code> is returned.</p><p>See also <a href="@ref"><code>similarstoragetype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L43-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.blocktype"><a class="docstring-binding" href="#TensorKit.blocktype"><code>TensorKit.blocktype</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">blocktype(t)</code></pre><p>Return the type of the matrix blocks of a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L442-L446">source</a></section></details></article><p>To obtain information about the indices, you can use:</p><article><details class="docstring" open="true"><summary id="TensorKit.space-Tuple{AbstractTensorMap, Int64}"><a class="docstring-binding" href="#TensorKit.space-Tuple{AbstractTensorMap, Int64}"><code>TensorKit.space</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">space(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}) -&gt; HomSpace{S,N‚ÇÅ,N‚ÇÇ}
space(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, i::Int) -&gt; S</code></pre><p>The index information of a tensor, i.e. the <code>HomSpace</code> of its domain and codomain. If <code>i</code> is specified, return the <code>i</code>-th index space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L198-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.domain"><a class="docstring-binding" href="#TensorKit.domain"><code>TensorKit.domain</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">domain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}) -&gt; ProductSpace{S,N‚ÇÇ}
domain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, i::Int) -&gt; S</code></pre><p>Return the domain of a tensor, i.e. the product space of the input spaces. If <code>i</code> is specified, return the <code>i</code>-th input space. Implementations should provide <code>domain(t)</code>.</p><p>See also <a href="#TensorKit.codomain"><code>codomain</code></a> and <a href="../spaces/#TensorKit.space"><code>space</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L220-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.codomain"><a class="docstring-binding" href="#TensorKit.codomain"><code>TensorKit.codomain</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">codomain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}) -&gt; ProductSpace{S,N‚ÇÅ}
codomain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, i::Int) -&gt; S</code></pre><p>Return the codomain of a tensor, i.e. the product space of the output spaces. If <code>i</code> is specified, return the <code>i</code>-th output space. Implementations should provide <code>codomain(t)</code>.</p><p>See also <a href="#TensorKit.domain"><code>domain</code></a> and <a href="../spaces/#TensorKit.space"><code>space</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L206-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.numin"><a class="docstring-binding" href="#TensorKit.numin"><code>TensorKit.numin</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numin(x) -&gt; Int
numin(T::Type) -&gt; Int</code></pre><p>Return the length of the domain, i.e. the number of input spaces. By default, this is implemented in the type domain.</p><p>See also <a href="#TensorKit.numout"><code>numout</code></a> and <a href="#TensorKit.numind"><code>numind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L248-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.numout"><a class="docstring-binding" href="#TensorKit.numout"><code>TensorKit.numout</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numout(x) -&gt; Int
numout(T::Type) -&gt; Int</code></pre><p>Return the length of the codomain, i.e. the number of output spaces. By default, this is implemented in the type domain.</p><p>See also <a href="#TensorKit.numin"><code>numin</code></a> and <a href="#TensorKit.numind"><code>numind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L234-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.numind"><a class="docstring-binding" href="#TensorKit.numind"><code>TensorKit.numind</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numind(x) -&gt; Int
numind(T::Type) -&gt; Int
order(x) = numind(x)</code></pre><p>Return the total number of input and output spaces, i.e. <code>numin(x) + numout(x)</code>. Alternatively, the alias <code>order</code> can also be used.</p><p>See also <a href="#TensorKit.numout"><code>numout</code></a> and <a href="#TensorKit.numin"><code>numin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L262-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.codomainind"><a class="docstring-binding" href="#TensorKit.codomainind"><code>TensorKit.codomainind</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">codomainind(x) -&gt; Tuple{Int}</code></pre><p>Return all indices of the codomain.</p><p>See also <a href="#TensorKit.domainind"><code>domainind</code></a> and <a href="#TensorKit.allind"><code>allind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L276-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.domainind"><a class="docstring-binding" href="#TensorKit.domainind"><code>TensorKit.domainind</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">domainind(x) -&gt; Tuple{Int}</code></pre><p>Return all indices of the domain.</p><p>See also <a href="#TensorKit.codomainind"><code>codomainind</code></a> and <a href="#TensorKit.allind"><code>allind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L285-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.allind"><a class="docstring-binding" href="#TensorKit.allind"><code>TensorKit.allind</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">allind(x) -&gt; Tuple{Int}</code></pre><p>Return all indices, i.e. the indices of both domain and codomain.</p><p>See also <a href="#TensorKit.codomainind"><code>codomainind</code></a> and <a href="#TensorKit.domainind"><code>domainind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L294-L300">source</a></section></details></article><p>In <code>TensorMap</code> instances, all data is gathered in a single <code>AbstractVector</code>, which has an internal structure into blocks associated to total coupled charge, within which live subblocks associated with the different possible fusion-splitting tree pairs.</p><p>To obtain information about the structure of the data, you can use:</p><article><details class="docstring" open="true"><summary id="TensorKit.fusionblockstructure-Tuple{AbstractTensorMap}"><a class="docstring-binding" href="#TensorKit.fusionblockstructure-Tuple{AbstractTensorMap}"><code>TensorKit.fusionblockstructure</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fusionblockstructure(t::AbstractTensorMap) -&gt; TensorStructure</code></pre><p>Return the necessary structure information to decompose a tensor in blocks labeled by coupled sectors and in subblocks labeled by a splitting-fusion tree couple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L327-L332">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.dim-Tuple{AbstractTensorMap}"><a class="docstring-binding" href="#TensorKitSectors.dim-Tuple{AbstractTensorMap}"><code>TensorKitSectors.dim</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dim(t::AbstractTensorMap) -&gt; Int</code></pre><p>The total number of free parameters of a tensor, discounting the entries that are fixed by symmetry. This is also the dimension of the <code>HomSpace</code> on which the <code>TensorMap</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L335-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.blocksectors-Tuple{AbstractTensorMap}"><a class="docstring-binding" href="#TensorKit.blocksectors-Tuple{AbstractTensorMap}"><code>TensorKit.blocksectors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blocksectors(t::AbstractTensorMap)</code></pre><p>Return an iterator over all coupled sectors of a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L345-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.hasblock-Tuple{AbstractTensorMap, Sector}"><a class="docstring-binding" href="#TensorKit.hasblock-Tuple{AbstractTensorMap, Sector}"><code>TensorKit.hasblock</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hasblock(t::AbstractTensorMap, c::Sector) -&gt; Bool</code></pre><p>Verify whether a tensor has a block corresponding to a coupled sector <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L352-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.fusiontrees-Tuple{AbstractTensorMap}"><a class="docstring-binding" href="#TensorKit.fusiontrees-Tuple{AbstractTensorMap}"><code>TensorKit.fusiontrees</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fusiontrees(t::AbstractTensorMap)</code></pre><p>Return an iterator over all splitting - fusion tree pairs of a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L393-L397">source</a></section></details></article><p>Data can be accessed (and modified) in a number of ways. To access the full matrix block associated with the coupled charges, you can use:</p><article><details class="docstring" open="true"><summary id="TensorKit.block"><a class="docstring-binding" href="#TensorKit.block"><code>TensorKit.block</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">block(t::AbstractTensorMap, c::Sector)</code></pre><p>Return the matrix block of a tensor corresponding to a coupled sector <code>c</code>.</p><p>See also <a href="#TensorKit.blocks"><code>blocks</code></a>, <a href="../spaces/#TensorKit.blocksectors-Union{Tuple{ProductSpace{S, N}}, Tuple{N}, Tuple{S}} where {S, N}"><code>blocksectors</code></a>, <a href="../spaces/#TensorKit.blockdim"><code>blockdim</code></a> and <a href="../spaces/#TensorKit.hasblock"><code>hasblock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L434-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.blocks"><a class="docstring-binding" href="#TensorKit.blocks"><code>TensorKit.blocks</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">blocks(t::AbstractTensorMap)</code></pre><p>Return an iterator over all blocks of a tensor, i.e. all coupled sectors and their corresponding matrix blocks.</p><p>See also <a href="#TensorKit.block"><code>block</code></a>, <a href="../spaces/#TensorKit.blocksectors-Union{Tuple{ProductSpace{S, N}}, Tuple{N}, Tuple{S}} where {S, N}"><code>blocksectors</code></a>, <a href="../spaces/#TensorKit.blockdim"><code>blockdim</code></a> and <a href="../spaces/#TensorKit.hasblock"><code>hasblock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L419-L426">source</a></section></details></article><p>To access the reduced tensor elements associated to fusion tree pairs, you can use:</p><article><details class="docstring" open="true"><summary id="TensorKit.subblock"><a class="docstring-binding" href="#TensorKit.subblock"><code>TensorKit.subblock</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subblock(t::AbstractTensorMap, (f‚ÇÅ, f‚ÇÇ)::Tuple{FusionTree,FusionTree})
subblock(t::AbstractTensorMap, sectors::Tuple{Vararg{Sector}})</code></pre><p>Return a view into the data of <code>t</code> corresponding to the splitting - fusion tree pair <code>(f‚ÇÅ, f‚ÇÇ)</code>. In particular, this is an <code>AbstractArray{T}</code> with <code>T = scalartype(t)</code>, of size <code>(dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(codomain(t), f‚ÇÇ.uncoupled)...)</code>.</p><p>Whenever <code>FusionStyle(sectortype(t)) isa UniqueFusion</code> , it is also possible to provide only the external <code>sectors</code>, in which case the fusion tree pair will be constructed automatically.</p><p>In general, new tensor types should provide an implementation of this function for the fusion tree signature.</p><p>See also <a href="#TensorKit.subblocks"><code>subblocks</code></a> and <a href="../fusiontrees/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{NTuple{N, I}, I, NTuple{N, Bool}}} where {N, I&lt;:Sector}"><code>fusiontrees</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L472-L482">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.subblocks"><a class="docstring-binding" href="#TensorKit.subblocks"><code>TensorKit.subblocks</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subblocks(t::AbstractTensorMap)</code></pre><p>Return an iterator over all subblocks of a tensor, i.e. all fusiontrees and their corresponding tensor subblocks.</p><p>See also <a href="#TensorKit.subblock"><code>subblock</code></a>, <a href="../fusiontrees/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{NTuple{N, I}, I, NTuple{N, Bool}}} where {N, I&lt;:Sector}"><code>fusiontrees</code></a>, and <a href="@ref"><code>hassubblock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L453-L460">source</a></section></details></article><p>To access the data associated with a specific fusion tree pair, you can use:</p><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{AbstractTensorMap, FusionTree, FusionTree}"><a class="docstring-binding" href="#Base.getindex-Tuple{AbstractTensorMap, FusionTree, FusionTree}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(t::AbstractTensorMap, sectors::Tuple{Vararg{Sector}})
t[sectors]
Base.getindex(t::AbstractTensorMap, f‚ÇÅ::FusionTree, f‚ÇÇ::FusionTree)
t[f‚ÇÅ, f‚ÇÇ]</code></pre><p>Return a view into the data of <code>t</code> corresponding to the splitting - fusion tree pair <code>(f‚ÇÅ, f‚ÇÇ)</code>. In particular, this is an <code>AbstractArray{T}</code> with <code>T = scalartype(t)</code>, of size <code>(dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(codomain(t), f‚ÇÇ.uncoupled)...)</code>.</p><p>Whenever <code>FusionStyle(sectortype(t)) isa UniqueFusion</code> , it is also possible to provide only the external <code>sectors</code>, in which case the fusion tree pair will be constructed automatically.</p><div class="admonition is-warning" id="Warning-de0f9b38524ef89e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-de0f9b38524ef89e" title="Permalink"></a></header><div class="admonition-body"><p>Contrary to Julia&#39;s array types, the default behavior is to return a view into the tensor data. As a result, modifying the view will modify the data in the tensor.</p></div></div><p>See also <a href="#TensorKit.subblock"><code>subblock</code></a>, <a href="#TensorKit.subblocks"><code>subblocks</code></a> and <a href="../fusiontrees/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{NTuple{N, I}, I, NTuple{N, Bool}}} where {N, I&lt;:Sector}"><code>fusiontrees</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L532-L545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Tuple{AbstractTensorMap, Any, FusionTree, FusionTree}"><a class="docstring-binding" href="#Base.setindex!-Tuple{AbstractTensorMap, Any, FusionTree, FusionTree}"><code>Base.setindex!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.setindex!(t::AbstractTensorMap, v, sectors::Tuple{Vararg{Sector}})
t[sectors] = v
Base.setindex!(t::AbstractTensorMap, v, f‚ÇÅ::FusionTree, f‚ÇÇ::FusionTree)
t[f‚ÇÅ, f‚ÇÇ] = v</code></pre><p>Copies <code>v</code> into the data slice of <code>t</code> corresponding to the splitting - fusion tree pair <code>(f‚ÇÅ, f‚ÇÇ)</code>. By default, <code>v</code> can be any object that can be copied into the view associated with <code>t[f‚ÇÅ, f‚ÇÇ]</code>.</p><p>See also <a href="#TensorKit.subblock"><code>subblock</code></a>, <a href="#TensorKit.subblocks"><code>subblocks</code></a> and <a href="../fusiontrees/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{NTuple{N, I}, I, NTuple{N, Bool}}} where {N, I&lt;:Sector}"><code>fusiontrees</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L553-L563">source</a></section></details></article><p>For a tensor <code>t</code> with <code>FusionStyle(sectortype(t)) isa UniqueFusion</code>, fusion trees are completely determined by the outcoming sectors, and the data can be accessed in a more straightforward way:</p><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{I}, Tuple{AbstractTensorMap, Tuple{I, Vararg{I}}}} where I&lt;:Sector"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{I}, Tuple{AbstractTensorMap, Tuple{I, Vararg{I}}}} where I&lt;:Sector"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(t::AbstractTensorMap, sectors::Tuple{Vararg{Sector}})
t[sectors]
Base.getindex(t::AbstractTensorMap, f‚ÇÅ::FusionTree, f‚ÇÇ::FusionTree)
t[f‚ÇÅ, f‚ÇÇ]</code></pre><p>Return a view into the data of <code>t</code> corresponding to the splitting - fusion tree pair <code>(f‚ÇÅ, f‚ÇÇ)</code>. In particular, this is an <code>AbstractArray{T}</code> with <code>T = scalartype(t)</code>, of size <code>(dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(codomain(t), f‚ÇÇ.uncoupled)...)</code>.</p><p>Whenever <code>FusionStyle(sectortype(t)) isa UniqueFusion</code> , it is also possible to provide only the external <code>sectors</code>, in which case the fusion tree pair will be constructed automatically.</p><div class="admonition is-warning" id="Warning-de0f9b38524ef89e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-de0f9b38524ef89e" title="Permalink"></a></header><div class="admonition-body"><p>Contrary to Julia&#39;s array types, the default behavior is to return a view into the tensor data. As a result, modifying the view will modify the data in the tensor.</p></div></div><p>See also <a href="#TensorKit.subblock"><code>subblock</code></a>, <a href="#TensorKit.subblocks"><code>subblocks</code></a> and <a href="../fusiontrees/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{NTuple{N, I}, I, NTuple{N, Bool}}} where {N, I&lt;:Sector}"><code>fusiontrees</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L532-L545">source</a></section></details></article><p>For tensor <code>t</code> with <code>sectortype(t) == Trivial</code>, the data can be accessed and manipulated directly as multidimensional arrays:</p><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{AbstractTensorMap}"><a class="docstring-binding" href="#Base.getindex-Tuple{AbstractTensorMap}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(t::AbstractTensorMap)
t[]</code></pre><p>Return a view into the data of <code>t</code> as a <code>StridedViews.StridedView</code> of size <code>dims(t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L607-L612">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{AbstractTensorMap, Vararg{Union{Colon, AbstractRange{&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}"><a class="docstring-binding" href="#Base.getindex-Tuple{AbstractTensorMap, Vararg{Union{Colon, AbstractRange{&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(t::AbstractTensorMap, indices::Vararg{Int})
t[indices]</code></pre><p>Return a view into the data slice of <code>t</code> corresponding to <code>indices</code>, by slicing the <code>StridedViews.StridedView</code> into the full data array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L579-L585">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Tuple{AbstractTensorMap, Any, Vararg{Union{Colon, AbstractRange{&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}"><a class="docstring-binding" href="#Base.setindex!-Tuple{AbstractTensorMap, Any, Vararg{Union{Colon, AbstractRange{&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}"><code>Base.setindex!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.setindex!(t::AbstractTensorMap, v, indices::Vararg{Int})
t[indices] = v</code></pre><p>Assigns <code>v</code> to the data slice of <code>t</code> corresponding to <code>indices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/abstracttensor.jl#L592-L597">source</a></section></details></article><p>The tensor data can also be filled with random numbers via</p><article><details class="docstring" open="true"><summary id="Random.rand!"><a class="docstring-binding" href="#Random.rand!"><code>Random.rand!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rand!([rng=default_rng()], t::AbstractTensorMap) -&gt; t</code></pre><p>Fill the tensor <code>t</code> with entries generated by <code>rand!</code>.</p><p>See also <a href="#Base.rand-Tuple{Type, TensorMapSpace}"><code>Random.rand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L354-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Random.randn!"><a class="docstring-binding" href="#Random.randn!"><code>Random.randn!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">randn!([rng=default_rng()], t::AbstractTensorMap) -&gt; t</code></pre><p>Fill the tensor <code>t</code> with entries generated by <code>randn!</code>.</p><p>See also <a href="#Base.randn-Tuple{Type, TensorMapSpace}"><code>Random.randn</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L354-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Random.randexp!"><a class="docstring-binding" href="#Random.randexp!"><code>Random.randexp!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">randexp!([rng=default_rng()], t::AbstractTensorMap) -&gt; t</code></pre><p>Fill the tensor <code>t</code> with entries generated by <code>randexp!</code>.</p><p>See also <a href="#Random.randexp-Tuple{Type, TensorMapSpace}"><code>Random.randexp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensor.jl#L354-L360">source</a></section></details></article><h2 id="AbstractTensorMap-operations"><a class="docs-heading-anchor" href="#AbstractTensorMap-operations"><code>AbstractTensorMap</code> operations</a><a id="AbstractTensorMap-operations-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTensorMap-operations" title="Permalink"></a></h2><p>The operations that can be performed on an <code>AbstractTensorMap</code> can be organized into the following categories:</p><ul><li><p><em>vector operations</em>: these do not change the <code>space</code> or index structure of a tensor and can be straightforwardly implemented on on the full data.   All the methods described in <a href="https://github.com/Jutho/VectorInterface.jl">VectorInterface.jl</a> are supported.   For compatibility reasons, we also provide implementations for equivalent methods from LinearAlgebra.jl, such as <code>axpy!</code>, <code>axpby!</code>.</p></li><li><p><em>index manipulations</em>: these change (permute) the index structure of a tensor, which affects the data in a way that is fully determined by the categorical data of the <code>sectortype</code> of the tensor .</p></li><li><p><em>(planar) contractions</em> and <em>(planar) traces</em> (i.e., contractions with identity tensors).   Tensor contractions correspond to a combination of some index manipulations followed by a composition or multiplication of the tensors in their role as linear maps.   Tensor contractions are however of such importance and frequency that they require a dedicated implementation.</p></li><li><p><em>tensor factorizations</em>, which relies on their identification of tensors with linear maps between tensor spaces.   The factorizations are applied as ordinary matrix factorizations to the matrix blocks associated with the coupled charges.</p></li></ul><h3 id="Index-manipulations"><a class="docs-heading-anchor" href="#Index-manipulations">Index manipulations</a><a id="Index-manipulations-1"></a><a class="docs-heading-anchor-permalink" href="#Index-manipulations" title="Permalink"></a></h3><p>A general index manipulation of a <code>TensorMap</code> object can be built up by considering some transformation of the fusion trees, along with a permutation of the stored data. They come in three flavours, which are either of the type <code>transform(!)</code> which are exported, or of the type <code>add_transform!</code>, for additional expert-mode options that allows for addition and scaling, as well as the selection of a custom backend.</p><article><details class="docstring" open="true"><summary id="TensorKit.permute-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><a class="docstring-binding" href="#TensorKit.permute-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><code>TensorKit.permute</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">permute(tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple; copy::Bool = false) -&gt; tdst::TensorMap</code></pre><p>Return tensor <code>tdst</code> obtained by permuting the indices of <code>tsrc</code>. The codomain and domain of <code>tdst</code> correspond to the indices in <code>p‚ÇÅ</code> and <code>p‚ÇÇ</code> of <code>tsrc</code> respectively.</p><p>If <code>copy = false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>To permute into an existing destination, see <a href="#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}">permute!</a> and <a href="#TensorKit.add_permute!"><code>add_permute!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L64-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.braid-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}, NTuple{N, Int64} where N}"><a class="docstring-binding" href="#TensorKit.braid-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}, NTuple{N, Int64} where N}"><code>TensorKit.braid</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">braid(tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple, levels::IndexTuple;
      copy::Bool = false)
    -&gt; tdst::TensorMap</code></pre><p>Return tensor <code>tdst</code> obtained by braiding the indices of <code>tsrc</code>. The codomain and domain of <code>tdst</code> correspond to the indices in <code>p‚ÇÅ</code> and <code>p‚ÇÇ</code> of <code>tsrc</code> respectively. Here, <code>levels</code> is a tuple of length <code>numind(tsrc)</code> that assigns a level or height to the indices of <code>tsrc</code>, which determines whether they will braid over or under any other index with which they have to change places.</p><p>If <code>copy=false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>To braid into an existing destination, see <a href="#TensorKit.braid!">braid!</a> and <a href="#TensorKit.add_braid!"><code>add_braid!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L137-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.transpose-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><a class="docstring-binding" href="#Base.transpose-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><code>Base.transpose</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transpose(tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple;
          copy::Bool=false)
    -&gt; tdst::TensorMap</code></pre><p>Return tensor <code>tdst</code> obtained by transposing the indices of <code>tsrc</code>. The codomain and domain of <code>tdst</code> correspond to the indices in <code>p‚ÇÅ</code> and <code>p‚ÇÇ</code> of <code>tsrc</code> respectively. The new index positions should be attainable without any indices crossing each other, i.e., the permutation <code>(p‚ÇÅ..., reverse(p‚ÇÇ)...)</code> should constitute a cyclic permutation of <code>(codomainind(tsrc)..., reverse(domainind(tsrc))...)</code>.</p><p>If <code>copy=false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>To permute into an existing destination, see <a href="#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}">permute!</a> and <a href="#TensorKit.add_permute!"><code>add_permute!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L186-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.repartition-Tuple{AbstractTensorMap, Int64, Int64}"><a class="docstring-binding" href="#TensorKit.repartition-Tuple{AbstractTensorMap, Int64, Int64}"><code>TensorKit.repartition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">repartition(
    tsrc::AbstractTensorMap{T, S}, N‚ÇÅ::Int, N‚ÇÇ::Int; copy::Bool=false
) where {T, S} -&gt; tdst::AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}</code></pre><p>Return tensor <code>tdst</code> obtained by repartitioning the indices of <code>t</code>. The codomain and domain of <code>tdst</code> correspond to the first <code>N‚ÇÅ</code> and last <code>N‚ÇÇ</code> spaces of <code>t</code>, respectively.</p><p>If <code>copy=false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>To repartition into an existing destination, see <a href="#TensorKit.repartition!">repartition!</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L239-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.flip-Tuple{AbstractTensorMap, Any}"><a class="docstring-binding" href="#TensorKit.flip-Tuple{AbstractTensorMap, Any}"><code>TensorKit.flip</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flip(t::AbstractTensorMap, I) -&gt; t‚Ä≤::AbstractTensorMap</code></pre><p>Return a new tensor that is isomorphic to <code>t</code> but where the arrows on the indices <code>i</code> that satisfy <code>i ‚àà I</code> are flipped, i.e. <code>space(t‚Ä≤, i) = flip(space(t, i))</code>.</p><div class="admonition is-info" id="Note-a5a4fa4b07325234"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a5a4fa4b07325234" title="Permalink"></a></header><div class="admonition-body"><p>The isomorphism that <code>flip</code> applies to each of the indices <code>i ‚àà I</code> is such that flipping two indices that are afterwards contracted within an <code>@tensor</code> contraction will yield the same result as without flipping those indices first. However, <code>flip</code> is not involutory, i.e. <code>flip(flip(t, I), I) != t</code> in general. To obtain the original tensor, one can use the <code>inv</code> keyword, i.e. it holds that <code>flip(flip(t, I), I; inv=true) == t</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L26-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.twist-Tuple{AbstractTensorMap, Int64}"><a class="docstring-binding" href="#TensorKitSectors.twist-Tuple{AbstractTensorMap, Int64}"><code>TensorKitSectors.twist</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">twist(tsrc::AbstractTensorMap, i::Int; inv::Bool = false, copy::Bool = false) -&gt; tdst
twist(tsrc::AbstractTensorMap, inds; inv::Bool = false, copy::Bool = false) -&gt; tdst</code></pre><p>Apply a twist to the <code>i</code>th index of <code>tsrc</code> and return the result as a new tensor. If <code>inv = true</code>, use the inverse twist. If <code>copy = false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>See <a href="#TensorKit.twist!"><code>twist!</code></a> for storing the result in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L312-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.insertleftunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><a class="docstring-binding" href="#TensorKit.insertleftunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>TensorKit.insertleftunit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">insertleftunit(tsrc::AbstractTensorMap, i=numind(t) + 1;
               conj=false, dual=false, copy=false) -&gt; tdst</code></pre><p>Insert a trivial vector space, isomorphic to the underlying field, at position <code>i</code>, which can be specified as an <code>Int</code> or as <code>Val(i)</code> for improved type stability. More specifically, adds a left monoidal unit or its dual.</p><p>If <code>copy=false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>See also <a href="#TensorKit.insertrightunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>insertrightunit</code></a>, <a href="#TensorKit.removeunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>removeunit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L330-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.insertrightunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><a class="docstring-binding" href="#TensorKit.insertrightunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>TensorKit.insertrightunit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">insertrightunit(tsrc::AbstractTensorMap, i=numind(t);
                conj=false, dual=false, copy=false) -&gt; tdst</code></pre><p>Insert a trivial vector space, isomorphic to the underlying field, after position <code>i</code>, which can be specified as an <code>Int</code> or as <code>Val(i)</code> for improved type stability. More specifically, adds a right monoidal unit or its dual.</p><p>If <code>copy=false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>See also <a href="#TensorKit.insertleftunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>insertleftunit</code></a>, <a href="#TensorKit.removeunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>removeunit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L359-L371">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.removeunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><a class="docstring-binding" href="#TensorKit.removeunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>TensorKit.removeunit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">removeunit(tsrc::AbstractTensorMap, i; copy=false) -&gt; tdst</code></pre><p>This removes a trivial tensor product factor at position <code>1 ‚â§ i ‚â§ N</code>, where <code>i</code> can be specified as an <code>Int</code> or as <code>Val(i)</code> for improved type stability. For this to work, that factor has to be isomorphic to the field of scalars.</p><p>If <code>copy=false</code>, <code>tdst</code> might share data with <code>tsrc</code> whenever possible. Otherwise, a copy is always made.</p><p>This operation undoes the work of <a href="#TensorKit.insertleftunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>insertleftunit</code></a>  and <a href="#TensorKit.insertrightunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i"><code>insertrightunit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L388-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><a class="docstring-binding" href="#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><code>Base.permute!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">permute!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple)
    -&gt; tdst</code></pre><p>Write into <code>tdst</code> the result of permuting the indices of <code>tsrc</code>. The codomain and domain of <code>tdst</code> correspond to the indices in <code>p‚ÇÅ</code> and <code>p‚ÇÇ</code> of <code>tsrc</code> respectively.</p><p>See <a href="../fusiontrees/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute</code></a> for creating a new tensor and <a href="#TensorKit.add_permute!"><code>add_permute!</code></a> for a more general version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L49-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.braid!"><a class="docstring-binding" href="#TensorKit.braid!"><code>TensorKit.braid!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">braid!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap,
       (p‚ÇÅ, p‚ÇÇ)::Index2Tuple, levels::Tuple)
    -&gt; tdst</code></pre><p>Write into <code>tdst</code> the result of braiding the indices of <code>tsrc</code>. The codomain and domain of <code>tdst</code> correspond to the indices in <code>p‚ÇÅ</code> and <code>p‚ÇÇ</code> of <code>tsrc</code> respectively. Here, <code>levels</code> is a tuple of length <code>numind(tsrc)</code> that assigns a level or height to the indices of <code>tsrc</code>, which determines whether they will braid over or under any other index with which they have to change places.</p><p>See <a href="../fusiontrees/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>braid</code></a> for creating a new tensor and <a href="#TensorKit.add_braid!"><code>add_braid!</code></a> for a more general version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L119-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.transpose!"><a class="docstring-binding" href="#LinearAlgebra.transpose!"><code>LinearAlgebra.transpose!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transpose!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap,
           (p‚ÇÅ, p‚ÇÇ)::Index2Tuple)
    -&gt; tdst</code></pre><p>Write into <code>tdst</code> the result of transposing the indices of <code>tsrc</code>. The codomain and domain of <code>tdst</code> correspond to the indices in <code>p‚ÇÅ</code> and <code>p‚ÇÇ</code> of <code>tsrc</code> respectively. The new index positions should be attainable without any indices crossing each other, i.e., the permutation <code>(p‚ÇÅ..., reverse(p‚ÇÇ)...)</code> should constitute a cyclic permutation of <code>(codomainind(tsrc)..., reverse(domainind(tsrc))...)</code>.</p><p>See <a href="../fusiontrees/#Base.transpose-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I}, FusionTree{I}, NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}} where {I&lt;:Sector, N‚ÇÅ, N‚ÇÇ}"><code>transpose</code></a> for creating a new tensor and <a href="#TensorKit.add_transpose!"><code>add_transpose!</code></a> for a more general version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L168-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.repartition!"><a class="docstring-binding" href="#TensorKit.repartition!"><code>TensorKit.repartition!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">repartition!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap) -&gt; tdst</code></pre><p>Write into <code>tdst</code> the result of repartitioning the indices of <code>tsrc</code>. This is just a special case of a transposition that only changes the number of in- and outgoing indices.</p><p>See <a href="../fusiontrees/#TensorKit.repartition-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I, N‚ÇÅ}, FusionTree{I, N‚ÇÇ}, Int64}} where {I&lt;:Sector, N‚ÇÅ, N‚ÇÇ}"><code>repartition</code></a> for creating a new tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L221-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.twist!"><a class="docstring-binding" href="#TensorKit.twist!"><code>TensorKit.twist!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">twist!(t::AbstractTensorMap, i::Int; inv::Bool=false) -&gt; t
twist!(t::AbstractTensorMap, inds; inv::Bool=false) -&gt; t</code></pre><p>Apply a twist to the <code>i</code>th index of <code>t</code>, or all indices in <code>inds</code>, storing the result in <code>t</code>. If <code>inv=true</code>, use the inverse twist.</p><p>See <a href="../sectors/#TensorKitSectors.twist-Tuple{Sector}"><code>twist</code></a> for creating a new tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L282-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.add_permute!"><a class="docstring-binding" href="#TensorKit.add_permute!"><code>TensorKit.add_permute!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_permute!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,
             Œ±::Number, Œ≤::Number, backend::AbstractBackend...)</code></pre><p>Return the updated <code>tdst</code>, which is the result of adding <code>Œ± * tsrc</code> to <code>tdst</code> after permuting  the indices of <code>tsrc</code> according to <code>(p‚ÇÅ, p‚ÇÇ)</code>.</p><p>See also <a href="../fusiontrees/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute</code></a>, <a href="#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><code>permute!</code></a>, <a href="#TensorKit.add_braid!"><code>add_braid!</code></a>, <a href="#TensorKit.add_transpose!"><code>add_transpose!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L451-L459">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.add_braid!"><a class="docstring-binding" href="#TensorKit.add_braid!"><code>TensorKit.add_braid!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_braid!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,
           levels::IndexTuple, Œ±::Number, Œ≤::Number, backend::AbstractBackend...)</code></pre><p>Return the updated <code>tdst</code>, which is the result of adding <code>Œ± * tsrc</code> to <code>tdst</code> after braiding the indices of <code>tsrc</code> according to <code>(p‚ÇÅ, p‚ÇÇ)</code> and <code>levels</code>.</p><p>See also <a href="../fusiontrees/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>braid</code></a>, <a href="#TensorKit.braid!"><code>braid!</code></a>, <a href="#TensorKit.add_permute!"><code>add_permute!</code></a>, <a href="#TensorKit.add_transpose!"><code>add_transpose!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L469-L477">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.add_transpose!"><a class="docstring-binding" href="#TensorKit.add_transpose!"><code>TensorKit.add_transpose!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_transpose!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,
               Œ±::Number, Œ≤::Number, backend::AbstractBackend...)</code></pre><p>Return the updated <code>tdst</code>, which is the result of adding <code>Œ± * tsrc</code> to <code>tdst</code> after transposing the indices of <code>tsrc</code> according to <code>(p‚ÇÅ, p‚ÇÇ)</code>.</p><p>See also <a href="../fusiontrees/#Base.transpose-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I}, FusionTree{I}, NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}} where {I&lt;:Sector, N‚ÇÅ, N‚ÇÇ}"><code>transpose</code></a>, <a href="#LinearAlgebra.transpose!"><code>transpose!</code></a>, <a href="#TensorKit.add_permute!"><code>add_permute!</code></a>, <a href="#TensorKit.add_braid!"><code>add_braid!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/indexmanipulations.jl#L490-L498">source</a></section></details></article><h3 id="Tensor-map-composition,-traces,-contractions-and-tensor-products"><a class="docs-heading-anchor" href="#Tensor-map-composition,-traces,-contractions-and-tensor-products">Tensor map composition, traces, contractions and tensor products</a><a id="Tensor-map-composition,-traces,-contractions-and-tensor-products-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-map-composition,-traces,-contractions-and-tensor-products" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="TensorKit.compose-Tuple{AbstractTensorMap, AbstractTensorMap}"><a class="docstring-binding" href="#TensorKit.compose-Tuple{AbstractTensorMap, AbstractTensorMap}"><code>TensorKit.compose</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compose(t1::AbstractTensorMap, t2::AbstractTensorMap) -&gt; AbstractTensorMap</code></pre><p>Return the <code>AbstractTensorMap</code> that implements the composition of the two tensor maps <code>t1</code> and <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/linalg.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.trace_permute!"><a class="docstring-binding" href="#TensorKit.trace_permute!"><code>TensorKit.trace_permute!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trace_permute!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap,
               (p‚ÇÅ, p‚ÇÇ)::Index2Tuple, (q‚ÇÅ, q‚ÇÇ)::Index2Tuple,
               Œ±::Number, Œ≤::Number, backend=TO.DefaultBackend())</code></pre><p>Return the updated <code>tdst</code>, which is the result of adding <code>Œ± * tsrc</code> to <code>tdst</code> after permuting the indices of <code>tsrc</code> according to <code>(p‚ÇÅ, p‚ÇÇ)</code> and furthermore tracing the indices in <code>q‚ÇÅ</code> and <code>q‚ÇÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensoroperations.jl#L190-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.contract!"><a class="docstring-binding" href="#TensorKit.contract!"><code>TensorKit.contract!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">contract!(C::AbstractTensorMap,
          A::AbstractTensorMap, (oindA, cindA)::Index2Tuple,
          B::AbstractTensorMap, (cindB, oindB)::Index2Tuple,
          (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,
          Œ±::Number, Œ≤::Number,
          backend, allocator)</code></pre><p>Return the updated <code>C</code>, which is the result of adding <code>Œ± * A * B</code> to <code>C</code> after permuting the indices of <code>A</code> and <code>B</code> according to <code>(oindA, cindA)</code> and <code>(cindB, oindB)</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/tensoroperations.jl#L267-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKitSectors.:‚äó-Tuple{AbstractTensorMap, AbstractTensorMap}"><a class="docstring-binding" href="#TensorKitSectors.:‚äó-Tuple{AbstractTensorMap, AbstractTensorMap}"><code>TensorKitSectors.:‚äó</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">‚äó(t1::AbstractTensorMap, t2::AbstractTensorMap, ...) -&gt; TensorMap
otimes(t1::AbstractTensorMap, t2::AbstractTensorMap, ...) -&gt; TensorMap</code></pre><p>Compute the tensor product between two <code>AbstractTensorMap</code> instances, which results in a new <code>TensorMap</code> instance whose codomain is <code>codomain(t1) ‚äó codomain(t2)</code> and whose domain is <code>domain(t1) ‚äó domain(t2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/tensors/linalg.jl#L550-L557">source</a></section></details></article><h2 id="TensorMap-factorizations"><a class="docs-heading-anchor" href="#TensorMap-factorizations"><code>TensorMap</code> factorizations</a><a id="TensorMap-factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#TensorMap-factorizations" title="Permalink"></a></h2><p>The factorization methods are powered by <a href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl">MatrixAlgebraKit.jl</a> and all follow the same strategy. The idea is that the <code>TensorMap</code> is interpreted as a linear map based on the current partition of indices between <code>domain</code> and <code>codomain</code>, and then the entire range of MatrixAlgebraKit functions can be called. Factorizing a tensor according to a different partition of the indices is possible by prepending the factorization step with an explicit call to <a href="../fusiontrees/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute</code></a> or <a href="../fusiontrees/#Base.transpose-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I}, FusionTree{I}, NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}} where {I&lt;:Sector, N‚ÇÅ, N‚ÇÇ}"><code>transpose</code></a>.</p><p>For the full list of factorizations, see <a href="https://quantumkithub.github.io/MatrixAlgebraKit.jl/stable/user_interface/decompositions/#Decompositions">Decompositions</a>.</p><p>Additionally, it is possible to obtain truncated versions of some of these factorizations through the <a href="@ref"><code>MatrixAlgebraKit.TruncationStrategy</code></a> objects.</p><p>The exact truncation strategy can be controlled through the strategies defined in <a href="https://quantumkithub.github.io/MatrixAlgebraKit.jl/stable/user_interface/truncations/#Truncations">Truncations</a>, but for <code>TensorMap</code>s there is also the special-purpose scheme:</p><article><details class="docstring" open="true"><summary id="TensorKit.Factorizations.truncspace"><a class="docstring-binding" href="#TensorKit.Factorizations.truncspace"><code>TensorKit.Factorizations.truncspace</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">truncspace(space::ElementarySpace; by=abs, rev::Bool=true)</code></pre><p>Truncation strategy to keep the first values for each sector when sorted according to <code>by</code> and <code>rev</code>, such that the resulting vector space is no greater than <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/d1877d0b53394ed105dccef5e4a7c5d5f135711d/src/factorizations/truncation.jl#L17-L22">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spaces/">¬´ Vector spaces</a><a class="docs-footer-nextpage" href="../../index/">Index ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Thursday 26 February 2026 12:25">Thursday 26 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
