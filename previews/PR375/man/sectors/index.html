<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sectors · TensorKit.jl</title><meta name="title" content="Sectors · TensorKit.jl"/><meta property="og:title" content="Sectors · TensorKit.jl"/><meta property="twitter:title" content="Sectors · TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../symmetries/">Symmetries</a></li><li class="is-active"><a class="tocitem" href>Sectors</a><ul class="internal"><li><a class="tocitem" href="#ss_sectorinterface"><span>Minimal sector interface</span></a></li><li><a class="tocitem" href="#ss_sectoradditional"><span>Additional methods</span></a></li><li><a class="tocitem" href="#ss_sectoradditionaltools"><span>Additional tools</span></a></li><li><a class="tocitem" href="#ss_groups"><span>Group representations</span></a></li><li><a class="tocitem" href="#ss_productsectors"><span>Combining different sectors</span></a></li><li><a class="tocitem" href="#ss_newsectors"><span>Defining a new type of sector</span></a></li><li><a class="tocitem" href="#ss_fermions"><span>Fermionic sectors</span></a></li><li><a class="tocitem" href="#Anyons"><span>Anyons</span></a></li><li><a class="tocitem" href="#ss_generalsectors"><span>Further generalizations</span></a></li></ul></li><li><a class="tocitem" href="../gradedspaces/">Graded spaces</a></li><li><a class="tocitem" href="../fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../tensors/">Constructing tensors and the <code>TensorMap</code> type</a></li><li><a class="tocitem" href="../tensormanipulations/">Manipulating tensors</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors</a></li><li><a class="tocitem" href="../../lib/fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/symmetric_tutorial/">A symmetric tensor deep dive: constructing your first tensor map</a></li><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li><li><a class="tocitem" href="../../Changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Sectors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sectors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/man/sectors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ss_sectors"><a class="docs-heading-anchor" href="#ss_sectors">Sectors</a><a id="ss_sectors-1"></a><a class="docs-heading-anchor-permalink" href="#ss_sectors" title="Permalink"></a></h1><p>The first ingredient in order to define and construct symmetric tensors, is a framework to define symmetry sectors and their assocated fusion rules and topological data. <a href="https://github.com/QuantumKitHub/TensorKitSectors.jl">TensorKitSectors.jl</a> defines an abstract supertype <code>Sector</code> that all sectors will be subtypes of</p><article><details class="docstring"><summary id="TensorKitSectors.Sector-man-sectors"><a class="docstring-binding" href="#TensorKitSectors.Sector-man-sectors"><code>TensorKitSectors.Sector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Sector</code></pre><p>Abstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes <code>I &lt;: Sector</code> as the set of labels of a <code>GradedSpace</code>.</p><p>Every new <code>I &lt;: Sector</code> should implement the following methods:</p><ul><li><code>unit(::Type{I})</code>: unit element of <code>I</code>. If there are multiple, implement <code>allunits(::Type{I})</code>   instead.</li><li><code>dual(a::I)</code>: <span>$a̅$</span>, conjugate or dual label of <span>$a$</span></li><li><code>⊗(a::I, b::I)</code>: iterable with unique fusion outputs of <span>$a ⊗ b$</span>   (i.e. don&#39;t repeat in case of multiplicities)</li><li><code>Nsymbol(a::I, b::I, c::I)</code>: number of times <code>c</code> appears in <code>a ⊗ b</code>, i.e. the   multiplicity</li><li><code>FusionStyle(::Type{I})</code>: <code>UniqueFusion()</code>, <code>SimpleFusion()</code> or   <code>GenericFusion()</code></li><li><code>BraidingStyle(::Type{I})</code>: <code>Bosonic()</code>, <code>Fermionic()</code>, <code>Anyonic()</code>, ...</li><li><code>Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)</code>: F-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or rank-4 array (in case of <code>GenericFusion</code>)</li><li><code>Rsymbol(a::I, b::I, c::I)</code>: R-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li><li><code>isless(a::I, b::I)</code>: defines a canonical ordering of sectors</li><li><code>hash(a::I)</code>: hash function for sectors</li></ul><p>and optionally</p><ul><li><code>dim(a::I)</code>: quantum dimension of sector <code>a</code></li><li><code>frobenius_schur_indicator(a::I)</code>: Frobenius-Schur indicator of <code>a</code> (1, 0, -1)</li><li><code>frobenius_schur_phase(a::I)</code>: Frobenius-Schur phase of <code>a</code> (±1)</li><li><code>sectorscalartype(::Type{I})</code>: scalar type of F- and R-symbols</li><li><code>Bsymbol(a::I, b::I, c::I)</code>: B-symbol: scalar (in case of   <code>UniqueFusion</code>/<code>SimpleFusion</code>) or matrix (in case of <code>GenericFusion</code>)</li><li><code>twist(a::I)</code> -&gt; twist of sector <code>a</code></li></ul><p>Furthermore, <code>iterate</code> and <code>Base.IteratorSize</code> should be made to work for the singleton type <a href="../../lib/sectors/#TensorKitSectors.SectorValues"><code>SectorValues{I}</code></a>.</p><p>To help with the implementation of <code>⊗(a::I, b::I)</code> as an iterator, the provided <code>struct</code> type <a href="../../lib/sectors/#TensorKitSectors.SectorProductIterator"><code>SectorProductIterator{I}</code></a> can be used, which stores <code>a</code> and <code>b</code> and requires the implementation of <code>Base.iterate(::SectorProductIterator{I}, state...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.6/src/sectors.jl#L1-L40">source</a></section></details></article><p>Any concrete subtype of <code>Sector</code> should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category. Throughout TensorKit.jl, the method <a href="../../lib/spaces/#TensorKit.sectortype"><code>sectortype</code></a> can be used to query the subtype of <code>Sector</code> associated with a particular object, i.e. a vector space, fusion tree, tensor map, or a sector. It works on both instances and in the type domain, and its use will be illustrated further on.</p><h2 id="ss_sectorinterface"><a class="docs-heading-anchor" href="#ss_sectorinterface">Minimal sector interface</a><a id="ss_sectorinterface-1"></a><a class="docs-heading-anchor-permalink" href="#ss_sectorinterface" title="Permalink"></a></h2><p>The minimal data to completely specify a type of sector closely matches the <a href="../../appendix/categories/#ss_topologicalfusion">topological data</a> of a <a href="../../appendix/categories/#ss_fusion">fusion category</a> as reviewed in the appendix on <a href="../../appendix/categories/#s_categories">category theory</a>, and is given by:</p><ul><li>The fusion rules, i.e. <span>$a ⊗ b = ⨁ N^{ab}_{c} c$</span>, implemented as the function <a href="../../lib/sectors/#TensorKitSectors.Nsymbol"><code>Nsymbol(a, b, c)</code></a>.</li><li>The list of fusion outputs from <span>$a ⊗ b$</span>; while this information is contained in <span>$N^{ab}_c$</span>, it might be costly or impossible to iterate over all possible values of <code>c</code> and test <code>Nsymbol(a,b,c)</code>; instead we require for <a href="../../lib/sectors/#TensorKitSectors.:⊗"><code>a ⊗ b</code></a>, or equivalently, <code>otimes(a, b)</code>, to return an iterable object (e.g. tuple or array, but see <a href="#ss_sectoradditionaltools">below</a> for a dedicated iterator struct) that generates all <em>unique</em> <code>c</code> for which <span>$N^{ab}_c ≠ 0$</span> (so only once for all <span>$c$</span> with <span>$N^{ab}_c ≥ 1$</span>).</li><li>The identity object <code>u</code>, such that <span>$a ⊗ u = a = u ⊗ a$</span>, implemented as the function <a href="../../lib/sectors/#TensorKitSectors.unit"><code>unit(a)</code></a> (and also in type domain), but <code>one(a)</code> from Julia Base also works as an alias to <code>unit(a)</code>.</li><li>The dual or conjugate object <span>$\overline{a}$</span> for which <span>$N^{a\bar{a}}_{u} = 1$</span>, implemented as the function <a href="../../lib/sectors/#TensorKitSectors.dual-Tuple{Sector}"><code>dual(a)</code></a>.   Because we restrict to unitary categories, <code>conj(a)</code> from the Julia <code>Base</code> library is also defined as an alias to <code>dual(a)</code>.</li><li>The F-symbol or recoupling coefficients <span>$[F^{abc}_{d}]^f_e$</span>; implemented as the function <a href="../../lib/sectors/#TensorKitSectors.Fsymbol"><code>Fsymbol(a, b, c, d, e, f)</code></a>.</li><li>If the category is braided (see below), the R-symbol <span>$R^{ab}_c$</span>; implemented as the function <a href="../../lib/sectors/#TensorKitSectors.Rsymbol"><code>Rsymbol(a, b, c)</code></a>.</li></ul><p>Furthermore, sectors should provide information about the structure of their fusion rules. For irreps of Abelian groups, we have that for every <span>$a$</span> and <span>$b$</span>, there exists a unique <span>$c$</span> such that <span>$a ⊗ b = c$</span>, i. . there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. In all other cases, there is at least one pair of (<span>$a$</span>, <span>$b$</span>) exists such that <span>$a ⊗ b$</span> has multiple fusion outputs. This is often referred to as non-abelian fusion, and is the case for the irreps of a non-abelian group or some more general fusion category. We however still distinguish between the case where all entries of <span>$N^{ab}_c ≦ 1$</span>, i.e. they are zero or one. In that case, <span>$[F^{abc}_{d}]^f_e$</span> and <span>$R^{ab}_c$</span> are scalars. If some <span>$N^{ab}_c &gt; 1$</span>, it means that the same sector <span>$c$</span> can appear more than once in the fusion product of <span>$a$</span> and <span>$b$</span>, and we need to introduce some multiplicity label <span>$μ$</span> for the different copies, and <span>$[F^{abc}_{d}]^f_e$</span> and <span>$R^{ab}_c$</span> are respectively four- and two-dimensional arrays labelled by these multiplicity indices. To encode these different possibilities, we define a Holy-trait called <a href="../../lib/sectors/#TensorKitSectors.FusionStyle"><code>FusionStyle</code></a>, i.e. a type hierarchy</p><pre><code class="language-julia hljs">abstract type FusionStyle end
struct UniqueFusion &lt;: FusionStyle end # unique fusion output when fusing two sectors
abstract type MultipleFusion &lt;: FusionStyle end
struct SimpleFusion &lt;: MultipleFusion end # multiple fusion but multiplicity free
struct GenericFusion &lt;: MultipleFusion end # multiple fusion with multiplicities
const MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}</code></pre><p>New sector types <code>I &lt;: Sector</code> should then indicate which fusion style they have by defining <code>FusionStyle(::Type{I})</code>.</p><p>In a similar manner, it is useful to distinguish between the structure and the different styles of the braiding of a sector type. Remember that for group representations, braiding acts as swapping or permuting the vector spaces involved. By definition, applying this operation twice leads us back to the original situation. If that is the case, the braiding is said to be symmetric. For more general fusion categories, associated with the physics of anyonic particles, this is generally not the case. Some categories do not even support a braiding rule, as this requires at least that <span>$a ⊗ b$</span> and <span>$b ⊗ a$</span> have the same fusion outputs for every <span>$a$</span> and <span>$b$</span>. When braiding is possible, it might not be symmetric, and as a result, permutations of tensor indices are not unambiguously defined. The correct description is in terms of the braid group. This will be discussed in more detail below. Fermions are somewhat in between, as their braiding is symmetric, but they have a non-trivial <em>twist</em>. We thereto define a new trait <a href="../../lib/sectors/#TensorKitSectors.BraidingStyle"><code>BraidingStyle</code></a> with associated the type hierarchy</p><pre><code class="language-julia hljs">abstract type HasBraiding &lt;: BraidingStyle end
struct NoBraiding &lt;: BraidingStyle end
abstract type SymmetricBraiding &lt;: HasBraiding end # symmetric braiding =&gt; actions of permutation group are well defined
struct Bosonic &lt;: SymmetricBraiding end # all twists are one
struct Fermionic &lt;: SymmetricBraiding end # twists one and minus one
struct Anyonic &lt;: HasBraiding end</code></pre><p>New sector types <code>I &lt;: Sector</code> should then indicate which fusion style they have by defining <code>BraidingStyle(::Type{I})</code>.</p><p>Note that <code>Bosonic()</code> braiding does not mean that all permutations are trivial and <span>$R^{ab}_c = 1$</span>, but that <span>$R^{ab}_c R^{ba}_c = 1$</span>. For example, for the irreps of <span>$\mathsf{SU}_2$</span>, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is <span>$-1$</span>, i.e. the singlet of two spin-1/2 particles is antisymmetric under swapping the two constituents. For a <code>Bosonic()</code> braiding style, all twists are simply <span>$+1$</span>. The case of fermions and anyons are discussed below.</p><p>For practical reasons, we also require some additional methods to be defined:</p><ul><li><code>hash(a, h)</code> creates a hash of sectors, because sectors and objects created from them are used as keys in lookup tables (i.e. dictionaries).   Julia provides a default implementation of <code>hash</code> for every new type, but it can be useful to overload it for efficiency, or to ensure that the same hash is obtained for different instances that represent the same sector (e.g. when the sector type is not a bitstype).</li><li><code>isless(a, b)</code> associates a canonical order to sectors (of the same type), in order to unambiguously represent representation spaces <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>.</li></ul><p>Lastly, we sometimes need to iterate over different values of a sector type <code>I &lt;: Sector</code>, or at least have some basic information about the number of possible values of <code>I</code> Hereto, TensorKitSectors.jl defines <code>Base.values(I::Type{&lt;:Sector})</code> to return the singleton instance of the parametric type <a href="../../lib/sectors/#TensorKitSectors.SectorValues"><code>SectorValues{I}</code></a>, which should behave as an iterator over all possible values of the sector type <code>I</code>. This means the following methods should be implemented for a new sector type <code>I &lt;: Sector</code>:</p><ul><li><code>Base.iterate(::Type{SectorValues{I}} [, state])</code> should implement the iterator interface so as to enable iterating over all values of the sector <code>I</code> according to the canonical order defined by <code>isless</code>.</li><li><code>Base.IteratorSize(::Type{SectorValues{I}})</code> should return <code>HasLength()</code> if the number of different values of sector <code>I</code> is finite and rather small, and <code>SizeUnknown()</code> or <code>IsInfinite()</code> otherwise.   This is used to encode the degeneracies of the different sectors in a <code>GradedSpace</code> object efficiently, as discussed in the next section on <a href="@ref ss_rep">Graded spaces</a>.</li><li>If <code>IteratorSize(::Type{SectorValues{I}}) == HasLength()</code>, then <code>Base.length(::Type{SectorValues{I}})</code> should return the number of different values of sector <code>I</code>.</li></ul><p>Furthermore, the standard definitions <code>Base.IteratorEltype(::Type{SectorValues{I}}) = HasEltype()</code> and <code>Base.eltype(::Type{SectorValues{I}}) = I</code> are provided by default in TensorKitSectors.jl.</p><div class="admonition is-info" id="Note-dc8e6f3a5a5e36ac"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-dc8e6f3a5a5e36ac" title="Permalink"></a></header><div class="admonition-body"><p>A recent update in TensorKitSectors.jl has extended the minimal interface to also support multi-fusion categories, for which in particular the unit object is non-simple. We do not discuss this extension here, but refer to the documentation of <a href="../../lib/sectors/#TensorKitSectors.UnitStyle"><code>UnitStyle</code></a>, <a href="../../lib/sectors/#TensorKitSectors.leftunit"><code>leftunit</code></a>, <a href="../../lib/sectors/#TensorKitSectors.rightunit"><code>rightunit</code></a> and <a href="../../lib/sectors/#TensorKitSectors.allunits"><code>allunits</code></a> for more details.</p></div></div><h2 id="ss_sectoradditional"><a class="docs-heading-anchor" href="#ss_sectoradditional">Additional methods</a><a id="ss_sectoradditional-1"></a><a class="docs-heading-anchor-permalink" href="#ss_sectoradditional" title="Permalink"></a></h2><p>The sector interface contains a number of additional methods, that are useful, but whose return value can be computed from the minimal interface defined in the previous subsection. However, new sector types can override these default fallbacks with more efficient implementations.</p><p>Firstly, the canonical order of sectors allows to enumerate the different values, and thus to associate each value with an integer. Hereto, the following methods are defined:</p><ul><li><code>Base.getindex(::SectorValues{I}, i::Int)</code>: returns the sector instance of type <code>I</code> that is associated with integer <code>i</code>.   The fallback implementation simply iterates through <code>values(I)</code> up to the <code>i</code>th value.</li><li><code>findindex(::SectorValues{I}, c::I)</code>: reverse mapping that associates an index <code>i::Integer ∈ 1:length(values(I))</code> to a given sector <code>c::I</code>.   The fallback implementation simply searches linearly through the <code>values(I)</code> iterator.</li></ul><p>Note that <code>findindex</code> acts similar to <code>Base.indexin</code>, but with the order of the arguments reversed (so that is more similar to <code>getindex</code>), and returns an <code>Int</code> rather than an <code>Array{0, Union{Int, Nothing}}</code>.</p><p>Secondly, it is often useful to know the scalar type in which the topological data in the F- and R-symbols are expressed. For this, the method <a href="../../lib/sectors/#TensorKitSectors.sectorscalartype"><code>sectorscalartype(I::Type{&lt;:Sector})</code></a> is provided, which has a default implementation that uses type inference on the return values of <code>Fsymbol</code> and <code>Rsymbol</code>. This function is also used to define <code>Base.isreal(I::Type{&lt;:Sector})</code>, which indicates whether all topological data are real numbers. This is important because, if complex numbers appear in the topological data, it means tensor data will necessarily become complex after simple manipulations such as permuting indices, and should therefore probably be stored as complex numbers from the start.</p><p>Finally, additional topological data can be extracted from the minimal interface. In particular, the quantum dimensions <span>$d_a$</span> and Frobenius-Schur phase <span>$χ_a$</span> and indicator (only if <span>$a == \overline{a}$</span>) are encoded in the F-symbol. They are obtained as <a href="../../lib/sectors/#TensorKitSectors.dim-Tuple{Sector}"><code>dim(a)</code></a>, <a href="../../lib/sectors/#TensorKitSectors.frobenius_schur_phase"><code>frobenius_schur_phase(a)</code></a> and <a href="../../lib/sectors/#TensorKitSectors.frobenius_schur_indicator"><code>frobenius_schur_indicator(a)</code></a>. These functions have default definitions which compute the requested data from <code>Fsymbol(a, conj(a), a, a, unit(a), unit(a))</code>, but they can be overloaded in case the value can be computed more efficiently. The same holds for related fusion manipulations such as the B-symbol, which is obtained as <a href="../../lib/sectors/#TensorKitSectors.Bsymbol"><code>Bsymbol(a, b, c)</code></a>. Finally, the twist associated with a sector <code>a</code> is obtained as <a href="../../lib/sectors/#TensorKitSectors.twist-Tuple{Sector}"><code>twist(a)</code></a>, which also has a default implementation in terms of the R-symbol. In addition, the function <code>isunit</code> is provided to facilitate checking whether a sector is a unit sector, in particular for the non-trivial case of the multi-fusion category case, which we do not discuss here.</p><h2 id="ss_sectoradditionaltools"><a class="docs-heading-anchor" href="#ss_sectoradditionaltools">Additional tools</a><a id="ss_sectoradditionaltools-1"></a><a class="docs-heading-anchor-permalink" href="#ss_sectoradditionaltools" title="Permalink"></a></h2><p>The fusion product <code>a ⊗ b</code> of two sectors <code>a</code> and <code>b</code> is required to return an iterable object that generates all unique fusion outputs <code>c</code> for which <span>$N^{ab}_c ≥ 0$</span>. When this list can easily be computed or constructed, it can be returned as a tuple or an array. However, when taking type stability and (memory) efficiency into account, it is often preferable to return a lazy iterator object that generates the different fusion outputs on the fly. Indeed, a tuple result is only type stable when the number of fusion outputs is constant for all possible inputs <code>a</code> and <code>b</code>, whereas a <code>Vector</code> result requires heap allocation.</p><p>By default, <a href="https://github.com/QuantumKitHub/TensorKitSectors.jl">TensorKitSectors.jl</a> defines</p><pre><code class="language-julia hljs">⊗(a::I, b::I) where {I &lt;: Sector} = SectorProductIterator(a, b)</code></pre><p>where <a href="../../lib/sectors/#TensorKitSectors.SectorProductIterator"><code>TensorKitSectors.SectorProductIterator</code></a> is defined as</p><article><details class="docstring"><summary id="TensorKitSectors.SectorProductIterator-man-sectors"><a class="docstring-binding" href="#TensorKitSectors.SectorProductIterator-man-sectors"><code>TensorKitSectors.SectorProductIterator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SectorProductIterator{I &lt;: Sector}
SectorProductIterator(a::I, b::I) where {I &lt;: Sector}</code></pre><p>Custom iterator to represent the (unique) fusion outputs of <span>$a ⊗ b$</span>.</p><p>Custom sectors that aim to use this have to provide the following functionality:</p><ul><li><code>Base.iterate(::SectorProductIterator{I}, state...) where {I &lt;: Sector}</code>: iterate over   the fusion outputs of <code>a ⊗ b</code></li></ul><p>If desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define <code>Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength()</code>, in which case <code>Base.length(::SectorProductIterator{I})</code> has to be implemented.</p><p>See also <a href="../../lib/sectors/#TensorKitSectors.:⊗"><code>⊗</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKitSectors.jl/blob/v0.3.6/src/sectors.jl#L248-L264">source</a></section></details></article><p>and can serve as a general iterator type. For defining the fusion rules of a sector <code>I</code>, instead of implementing <code>⊗(::I, ::I)</code> directly, it is thus possible to instead implement the iterator interface for <code>SectorProductIterator{I}</code>, i.e. provide definitions for</p><ul><li><code>Base.iterate(::SectorProductIterator{I}[, state])</code></li><li><code>Base.IteratorSize(::Type{SectorProductIterator{I}})</code></li><li><code>Base.length(::SectorProductIterator{I})</code> (if applicable)</li></ul><p><a href="https://github.com/QuantumKitHub/TensorKitSectors.jl">TensorKitSectors.jl</a> already defines</p><pre><code class="language-julia hljs">Base.eltype(::Type{SectorProductIterator{I}}) where {I} = I</code></pre><p>and sets <code>Base.IteratorEltype(::Type{SectorProductIterator{I}})</code> accordingly. Furthermore, it provides custom pretty printing, so that <code>SectorProductIterator{I}(a, b)</code> is displayed as <code>a ⊗ b</code>.</p><h2 id="ss_groups"><a class="docs-heading-anchor" href="#ss_groups">Group representations</a><a id="ss_groups-1"></a><a class="docs-heading-anchor-permalink" href="#ss_groups" title="Permalink"></a></h2><p>In this subsection, we give an overview of some existing sector types provided by <a href="https://github.com/QuantumKitHub/TensorKitSectors.jl">TensorKitSectors.jl</a>. We also discuss the implementation of some of them in more detail, in order to illustrate the interface defined above.</p><p>The first sector type is called <code>Trivial</code>, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:</p><pre><code class="language-julia hljs">struct Trivial &lt;: Sector end

# basic properties
unit(::Type{Trivial}) = Trivial()
dual(::Trivial) = Trivial()
Base.isless(::Trivial, ::Trivial) = false

# fusion rules
⊗(::Trivial, ::Trivial) = (Trivial(),)
Nsymbol(::Trivial, ::Trivial, ::Trivial) = true
FusionStyle(::Type{Trivial}) = UniqueFusion()
Fsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1

# braiding rules
Rsymbol(::Trivial, ::Trivial, ::Trivial) = 1
BraidingStyle(::Type{Trivial}) = Bosonic()

# values iterator
Base.IteratorSize(::Type{SectorValues{Trivial}}) = HasLength()
Base.length(::SectorValues{Trivial}) = 1
Base.iterate(::SectorValues{Trivial}, i = false) = return i ? nothing : (Trivial(), true)
function Base.getindex(::SectorValues{Trivial}, i::Int)
    return i == 1 ? Trivial() : throw(BoundsError(values(Trivial), i))
end
findindex(::SectorValues{Trivial}, c::Trivial) = 1</code></pre><p>The <code>Trivial</code> sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.</p><p>The most important class of sectors are irreducible representations of groups. As we often use the group itself as a type parameter, an associated type hierarchy for groups has been defined, namely</p><pre><code class="language-julia hljs">abstract type Group end
abstract type AbelianGroup &lt;: Group end

abstract type Cyclic{N} &lt;: AbelianGroup end
abstract type Dihedral{N} &lt;: Group end
abstract type U₁ &lt;: AbelianGroup end
abstract type CU₁ &lt;: Group end

const ℤ{N} = Cyclic{N}
const ℤ₂ = ℤ{2}
const ℤ₃ = ℤ{3}
const ℤ₄ = ℤ{4}
const D₃ = Dihedral{3}
const D₄ = Dihedral{4}
const SU₂ = SU{2}</code></pre><p>Groups themselves are abstract types without any functionality (at least for now). However, as will become clear instantly, it is useful to identify abelian groups, because their representation theory is particularly simple. We also provide a number of convenient Unicode aliases. These group names are probably self-explanatory, except for <code>CU₁</code> which is explained below.</p><p>Irreps of groups will then be defined as subtypes of the abstract type</p><pre><code class="language-julia hljs">abstract type AbstractIrrep{G&lt;:Group} &lt;: Sector end # irreps have integer quantum dimensions
BraidingStyle(::Type{&lt;:AbstractIrrep}) = Bosonic()</code></pre><p>We will need different data structures to represent irreps of different groups, but it would be convenient to easily obtain the relevant structure for a given group <code>G</code> in a uniform manner. Hereto, we define a singleton type <code>IrrepTable</code> with an associated exported constant <code>Irrep = IrrepTable()</code> as the only instance. When a concrete type for representing the the irreps of a certain group <code>G</code> is iplemented, this type can the be &quot;discovered&quot; or obtained as <code>Irrep[G]</code>, provided it was registered by defining <code>Base.getindex(::IrrepTable, ::Type{G})</code> to return the concrete type.</p><p>Furthermore, we combine the more common functionality for irreps of abelian groups</p><pre><code class="language-julia hljs">const AbelianIrrep{G} = AbstractIrrep{G} where {G &lt;: AbelianGroup}
FusionStyle(::Type{&lt;:AbelianIrrep}) = UniqueFusion()
Base.sectorscalartype(::Type{&lt;:AbelianIrrep}) = Int

Nsymbol(a::I, b::I, c::I) where {I &lt;: AbelianIrrep} = c == first(a ⊗ b)
function Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I &lt;: AbelianIrrep}
    return Int(Nsymbol(a, b, e) * Nsymbol(e, c, d) * Nsymbol(b, c, f) * Nsymbol(a, f, d))
end
frobenius_schur_phase(a::AbelianIrrep) = 1
Asymbol(a::I, b::I, c::I) where {I &lt;: AbelianIrrep} = Int(Nsymbol(a, b, c))
Bsymbol(a::I, b::I, c::I) where {I &lt;: AbelianIrrep} = Int(Nsymbol(a, b, c))
Rsymbol(a::I, b::I, c::I) where {I &lt;: AbelianIrrep} = Int(Nsymbol(a, b, c))</code></pre><p>With these common definition in place, we implement the representation theory of the most common Abelian groups, starting with <span>$\mathsf{U}_1$</span>, the full implementation of which is given by</p><pre><code class="language-julia hljs">struct U1Irrep &lt;: AbstractIrrep{U₁}
    charge::HalfInt
end
Base.getindex(::IrrepTable, ::Type{U₁}) = U1Irrep
Base.convert(::Type{U1Irrep}, c::Real) = U1Irrep(c)

# basic properties
charge(c::U1Irrep) = c.charge
unit(::Type{U1Irrep}) = U1Irrep(0)
dual(c::U1Irrep) = U1Irrep(-charge(c))
@inline function Base.isless(c1::U1Irrep, c2::U1Irrep)
    return isless(abs(charge(c1)), abs(charge(c2))) || zero(HalfInt) &lt; charge(c1) == -charge(c2)
end

# fusion rules
⊗(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(charge(c1) + charge(c2)),)

# values iterator
Base.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()
function Base.iterate(::SectorValues{U1Irrep}, i::Int = 0)
    return i &lt;= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)
end
function Base.getindex(::SectorValues{U1Irrep}, i::Int)
    i &lt; 1 &amp;&amp; throw(BoundsError(values(U1Irrep), i))
    return U1Irrep(iseven(i) ? half(i &gt;&gt; 1) : -half(i &gt;&gt; 1))
end
function findindex(::SectorValues{U1Irrep}, c::U1Irrep)
    return (n = twice(charge(c)); 2 * abs(n) + (n &lt;= 0))
end

# hashing
Base.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)</code></pre><p>A few comments are in order: The <code>getindex</code> definition just below the type definition provides the mechanism to obtain <code>U1Irrep</code> as <code>Irrep[U₁]</code>, as discussed above. The <code>Base.convert</code> definition, while not required by the minimal sector interface, allows to convert real numbers to the corresponding type of sector, and thus to omit the type information of the sector whenever this is clear from the context. The <code>charge</code> function is again not part of the minimal sector interface, and is specific to <code>U1Irrep</code> (and <code>ZNIrrep</code> discussed next), as a mere convenience function to access the charge value. Finally, in the definition of <code>U1Irrep</code>, <code>HalfInt &lt;: Number</code> is a Julia type defined in <a href="https://github.com/sostock/HalfIntegers.jl">HalfIntegers.jl</a>, which is also used for <code>SU2Irrep</code> below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of <code>U₁</code> can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of <code>HalfInt</code> and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Irrep[U₁](0.5)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[U₁](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U1Irrep(0.4)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: Int64(0.8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U1Irrep(1) ⊗ Irrep[U₁](1//2)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U₁](3/2),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = first(U1Irrep(1) ⊗ Irrep[U₁](1//2))</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[U₁](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Nsymbol(u, dual(u), unit(u))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>We similarly implement the irreps of the finite cyclic groups <span>$\mathbb{Z}_N$</span>, where we distinguish between small and large values of <code>N</code> to optimize storage. The implementation is given by</p><pre><code class="language-julia hljs">const SMALL_ZN_CUTOFF = (typemax(UInt8) + 1) ÷ 2
struct ZNIrrep{N} &lt;: AbstractIrrep{ℤ{N}}
    n::UInt8
    function ZNIrrep{N}(n::Integer) where {N}
        N ≤ SMALL_ZN_CUTOFF || throw(DomainError(N, &quot;N exceeds the maximal value, use `LargeZNIrrep` instead&quot;))
        return new{N}(UInt8(mod(n, N)))
    end
end
struct LargeZNIrrep{N} &lt;: AbstractIrrep{ℤ{N}}
    n::UInt
    function LargeZNIrrep{N}(n::Integer) where {N}
        N ≤ (typemax(UInt) ÷ 2) || throw(DomainError(N, &quot;N exceeds the maximal value&quot;))
        return new{N}(UInt(mod(n, N)))
    end

end
Base.getindex(::IrrepTable, ::Type{ℤ{N}}) where {N} = N ≤ SMALL_ZN_CUTOFF ? ZNIrrep{N} : LargeZNIrrep{N}
...</code></pre><p>and continues along simular lines of the <code>U1Irrep</code> implementation above, by replacing the arithmetic with modulo <code>N</code> arithmetic.</p><p>The storage benefits for small <code>N</code> are not only due to a smaller integer type in the sector itself, but emerges as a result of the following distinction in the iterator size:</p><pre><code class="language-julia hljs">Base.IteratorSize(::Type{SectorValues{&lt;:ZNIrrep}}) = HasLength()
Base.IteratorSize(::Type{SectorValues{&lt;:LargeZNIrrep}}) = SizeUnknown()</code></pre><p>As a result, the <code>GradedSpace</code> implementation (see next section on <a href="@ref ss_rep">Graded spaces</a>) to store general direct sum objects <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span> will use a very different internal representation for those two cases.</p><p>We furthermore define some aliases for the first (and most commonly used <code>ℤ{N}</code> irreps)</p><pre><code class="language-julia hljs">const Z2Irrep = ZNIrrep{2}
const Z3Irrep = ZNIrrep{3}
const Z4Irrep = ZNIrrep{4}</code></pre><p>which we can illustrate via</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = Z3Irrep(1)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃](1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ZNIrrep{3}(1) ⊗ Irrep[ℤ₃](1)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](2),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(z)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃](2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unit(z)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃](0)</code></pre><p>As a final remark on the irreps of abelian groups, note that even though <code>a ⊗ b</code> is equivalent to a single new label <code>c</code>, we return this result as an iterable container, in this case a one-element tuple <code>(c,)</code>.</p><p>The first example of irreps of a non-abelian group is that of <span>$\mathsf{SU}_2$</span>, the implementation of which is summarized by</p><pre><code class="language-julia hljs">struct SU2Irrep &lt;: AbstractIrrep{SU₂}
    j::HalfInt
    function SU2Irrep(j)
        j &gt;= zero(j) || error(&quot;Not a valid SU₂ irrep&quot;)
        return new(j)
    end
end
Base.getindex(::IrrepTable, ::Type{SU₂}) = SU2Irrep
Base.convert(::Type{SU2Irrep}, j::Real) = SU2Irrep(j)

# basic properties
const _su2one = SU2Irrep(zero(HalfInt))
unit(::Type{SU2Irrep}) = _su2one
dual(s::SU2Irrep) = s
dim(s::SU2Irrep) = twice(s.j) + 1
Base.isless(s1::SU2Irrep, s2::SU2Irrep) = isless(s1.j, s2.j)

# fusion product iterator
const SU2IrrepProdIterator = SectorProductIterator{SU2Irrep}
Base.IteratorSize(::Type{SU2IrrepProdIterator}) = Base.HasLength()
Base.length(it::SU2IrrepProdIterator) = length(abs(it.a.j - it.b.j):(it.a.j + it.b.j))
function Base.iterate(it::SU2IrrepProdIterator, state = abs(it.a.j - it.b.j))
    return state &gt; (it.a.j + it.b.j) ? nothing : (SU2Irrep(state), state + 1)
end

# fusion and braidingdata
FusionStyle(::Type{SU2Irrep}) = SimpleFusion()
sectorscalartype(::Type{SU2Irrep}) = Float64

Nsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.δ(sa.j, sb.j, sc.j)
function Fsymbol(
        s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,
        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep
    )
    if all(==(_su2one), (s1, s2, s3, s4, s5, s6))
        return 1.0
    else
        return sqrtdim(s5) * sqrtdim(s6) *
            WignerSymbols.racahW(
            sectorscalartype(SU2Irrep), s1.j, s2.j, s4.j, s3.j,
            s5.j, s6.j
        )
    end
end
function Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)
    Nsymbol(sa, sb, sc) || return zero(sectorscalartype(SU2Irrep))
    return iseven(convert(Int, sa.j + sb.j - sc.j)) ? one(sectorscalartype(SU2Irrep)) :
        -one(sectorscalartype(SU2Irrep))
end

# values iterator
Base.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{SU2Irrep}, i::Int = 0) = (SU2Irrep(half(i)), i + 1)
function Base.getindex(::SectorValues{SU2Irrep}, i::Int)
    return 1 &lt;= i ? SU2Irrep(half(i - 1)) : throw(BoundsError(values(SU2Irrep), i))
end
findindex(::SectorValues{SU2Irrep}, s::SU2Irrep) = twice(s.j) + 1

# hashing
Base.hash(s::SU2Irrep, h::UInt) = hash(s.j, h)</code></pre><p>and some methods for pretty printing and converting from real numbers to irrep labels. Here, the fusion rules are implemented lazily using the <code>SectorProductIterator</code> defined above. Furthermore, the topological data (i.e. <code>Nsymbol</code> and <code>Fsymbol</code>) are provided by the package <a href="https://github.com/Jutho/WignerSymbols.jl">WignerSymbols.jl</a>. Note that, while WignerSymbols.jl is able to generate the required data in arbitrary precision, we have explicitly restricted the scalar type of <code>SU2Irrep</code> to <code>Float64</code> for efficiency.</p><p>The following example illustrates the usage of <code>SU2Irrep</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = SU2Irrep(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(s)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(s)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(s ⊗ s)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{SU2Irrep}:
 0
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for s2 in s ⊗ s
           @show s2
           @show Nsymbol(s, s, s2)
           @show Rsymbol(s, s, s2)
       end</code><code class="nohighlight hljs ansi" style="display:block;">s2 = Irrep[SU₂](0)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = Irrep[SU₂](1)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0
s2 = Irrep[SU₂](2)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = Irrep[SU₂](3)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0</code></pre><p>Other non-abelian groups for which the irreps are implemented are the dihedral groups <span>$\mathsf{D}_N$</span>, the alternating group of order four <span>$\mathsf{A}_4$</span> and the semidirect product <span>$\mathsf{U}₁ ⋉ ℤ_2$</span>. In the context of quantum systems, the latter occurs in the case of systems with particle hole symmetry and the non-trivial element of <span>$ℤ_2$</span> acts as charge conjugation <span>$C$</span>. It has the effect of interchanging <span>$\mathsf{U}_1$</span> irreps <span>$n$</span> and <span>$-n$</span>, and turns them together in a joint two-dimensional index, except for the case <span>$n=0$</span>. Irreps are therefore labeled by integers <span>$n ≧ 0$</span>, however for <span>$n=0$</span> the <span>$ℤ₂$</span> symmetry can be realized trivially or non-trivially, resulting in an even and odd one-dimensional irrep with <span>$\mathsf{U}_1$</span> charge <span>$0$</span>. Given <span>$\mathsf{U}_1 ≂ \mathsf{SO}_2$</span>, this group is also simply known as <span>$\mathsf{O}_2$</span>, and the two representations with <span>$n = 0$</span> are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as <code>Irrep[CU₁]</code> or <code>CU1Irrep</code> in full.</p><pre><code class="language-julia hljs">struct CU1Irrep &lt;: AbstractIrrep{CU₁}
    j::HalfInt # value of the U1 charge
    s::Int # rep of charge conjugation:
    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),
    # else s = 2 (two-dimensional representation)
    # Let constructor take the actual half integer value j
    function CU1Irrep(j::Real, s::Int = ifelse(j&gt;zero(j), 2, 0))
        if ((j &gt; zero(j) &amp;&amp; s == 2) || (j == zero(j) &amp;&amp; (s == 0 || s == 1)))
            new(j, s)
        else
            error(&quot;Not a valid CU₁ irrep&quot;)
        end
    end
end

unit(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)
dual(c::CU1Irrep) = c
dim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)

FusionStyle(::Type{CU1Irrep}) = SimpleFusion()
...</code></pre><p>The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of <code>Fsymbol</code>. For the dihedrial groups <span>$\mathsf{D}_N$</span>, which can be intepreted as the semidirect product <span>$\mathbb{Z}_N ⋉ ℤ_2$</span>, the representation theory is obtained quite similarly, and is implmented as the type <a href="../../lib/sectors/#TensorKitSectors.DNIrrep"><code>DNIrrep{N}</code></a>.</p><p>Of the aforementioned groups, only <span>$\mathsf{A}_4$</span> has a representation theory for which <code>FusionStyle(I) == GenericFusion()</code>, i.e. where fusion mulitplicities are required. Another example where this does appear is for the irreps of <code>SU{N}</code> for <span>$N &gt; 2$</span>. Such sectors are supported through <a href="https://github.com/QuantumKitHub/SUNRepresentations.jl">SUNRepresentations.jl</a>, which implements numerical routines to compute the topological data of the representation theory of these groups, as no general analytic formula is available.</p><h2 id="ss_productsectors"><a class="docs-heading-anchor" href="#ss_productsectors">Combining different sectors</a><a id="ss_productsectors-1"></a><a class="docs-heading-anchor-permalink" href="#ss_productsectors" title="Permalink"></a></h2><p>It is also possible to combine two or more different types of symmetry sectors, e.g. when the total symmetry group is a direct product of individual simple groups. Such combined sectors are obtained using the binary operator <code>⊠</code>, which can be entered as <code>\boxtimes</code>+TAB. The resulting type is called <a href="../../lib/sectors/#TensorKitSectors.ProductSector"><code>ProductSector</code></a>, which simply wraps the individual sectors, but knows how to combine their fusion and braiding data correctly. First some examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Z3Irrep(1) ⊠ Irrep[U₁](1)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × U₁](1, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{Z3Irrep, U1Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(a)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × U₁](2, -1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unit(a)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × U₁](0, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(a)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(a ⊗ a)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{ProductSector{Tuple{Z3Irrep, U1Irrep}}}:
 (2, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(a)</code><code class="nohighlight hljs ansi" style="display:block;">UniqueFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = Irrep[ℤ₃](1) ⊠ Irrep[SU₂](3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × SU₂](1, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(b)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{Z3Irrep, SU2Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(b)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × SU₂](2, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unit(b)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × SU₂](0, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(b)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(b ⊗ b)</code><code class="nohighlight hljs ansi" style="display:block;">1×4 Matrix{ProductSector{Tuple{Z3Irrep, SU2Irrep}}}:
 (2, 0)  (2, 1)  (2, 2)  (2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(b)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Irrep[SU₂](1) ⊠ SU2Irrep(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂ × SU₂](1, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(c)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{SU2Irrep, SU2Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(c)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂ × SU₂](1, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; unit(c)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂ × SU₂](0, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(c)</code><code class="nohighlight hljs ansi" style="display:block;">12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(c ⊗ c)</code><code class="nohighlight hljs ansi" style="display:block;">3×4 Matrix{ProductSector{Tuple{SU2Irrep, SU2Irrep}}}:
 (0, 0)  (0, 1)  (0, 2)  (0, 3)
 (1, 0)  (1, 1)  (1, 2)  (1, 3)
 (2, 0)  (2, 1)  (2, 2)  (2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(c)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code></pre><p>We refer to the source file of <a href="../../lib/sectors/#TensorKitSectors.ProductSector"><code>ProductSector</code></a> for implementation details.</p><p>The symbol <code>⊠</code> refers to the <a href="https://ncatlab.org/nlab/show/Deligne+tensor+product+of+abelian+categories">Deligne tensor product</a> within the literature on category theory. Indeed, the category of representation of a product group <code>G₁ × G₂</code> corresponds to the Deligne tensor product of the categories of representations of the two groups separately. But this definition also extends to other categories which are not associated with the representation theory of a group, as discussed below. Note that <code>⊠</code> also works in the type domain, i.e. <code>Irrep[ℤ₃] ⊠ Irrep[CU₁]</code> can be used to create <code>ProductSector{Tuple{Irrep[ℤ₃], Irrep[CU₁]}}</code>. Instances of this type can be constructed by giving a number of arguments, where the first argument is used to construct the first sector, and so forth. Furthermore, for representations of groups, we also enabled the notation <code>Irrep[ℤ₃ × CU₁]</code>, with <code>×</code> obtained using <code>\times+TAB</code>. However, this is merely for convenience, as <code>Irrep[ℤ₃] ⊠ Irrep[CU₁]</code> is not a subtype of the abstract type <code>AbstractIrrep{ℤ₃ × CU₁}</code>. As is often the case with the Julia type system, the purpose of subtyping <code>AbstractIrrep</code> was to share common functionality and thereby simplify the implementation of irreps of the different groups discussed above, but not to express a mathematical hierarchy.</p><p>Some more examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Z3Irrep(1) ⊠ Irrep[CU₁](1.5)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃ × CU₁](1, (3/2, 2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep[ℤ₃] ⊠ CU1Irrep</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep[ℤ₃ × CU₁]</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa AbstractIrrep{ℤ₃ × CU₁}</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a == Irrep[ℤ₃ × CU₁](1, 1.5)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="ss_newsectors"><a class="docs-heading-anchor" href="#ss_newsectors">Defining a new type of sector</a><a id="ss_newsectors-1"></a><a class="docs-heading-anchor-permalink" href="#ss_newsectors" title="Permalink"></a></h2><p>By now, it should be clear how to implement a new <code>Sector</code> subtype. Ideally, a new <code>I &lt;: Sector</code> type is a <code>struct I ... end</code> (immutable) that has <code>isbitstype(I) == true</code> (see Julia&#39;s manual), and implements the following minimal set of methods</p><pre><code class="language-julia hljs">TensorKit.unit(::Type{I}) = I(...)
TensorKit.dual(a::I) = I(...)
Base.isless(a::I, b::I)

TensorKit.FusionStyle(::Type{I}) = ... # UniqueFusion(), SimpleFusion(), GenericFusion()
TensorKit.Nsymbol(a::I, b::I, c::I) = ... # Bool or Integer if FusionStyle(I) == GenericFusion()

TensorKit.:⊗(a::I, b::I) = ... # some iterable object that generates all possible fusion outputs
# or
Base.iterate(::SectorProductIterator{I}[, state]) = ...
Base.IteratorSize(::Type{SectorProductIterator{I}}) = ... # HasLength() or IsInfinite()
Base.length(::SectorProductIterator{I}) = ... # if previous function returns HasLength()

TensorKit.Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) = ...

TensorKit.BraidingStyle(::Type{I}) = ... # NoBraiding(), Bosonic(), Fermionic(), Anyonic()
TensorKit.Rsymbol(a::I, b::I, c::I) = ... # only if BraidingStyle(I) != NoBraiding()

Base.iterate(::TensorKit.SectorValues{I}[, state]) = ...
Base.IteratorSize(::Type{TensorKit.SectorValues{I}}) = ... # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::TensorKit.SectorValues{I}) = ...
# optional, but recommended if IteratorSize returns HasLength():
Base.getindex(::TensorKit.SectorValues{I}, i::Int) = ...
TensorKit.findindex(::TensorKit.SectorValues{I}, c::I) = ...

Base.hash(a::I, h::UInt)</code></pre><p>Additionally, suitable definitions can be given for</p><pre><code class="language-julia hljs">TensorKit.sectorscalartype(::Type{I}) = ... # Int, Float64, ComplexF64, ...
TensorKit.dim(a::I) = ...
TensorKit.frobeniusschur_phase(a::I) = ...
TensorKit.Bsymbol(a::I, b::I, c::I) = ...</code></pre><h2 id="ss_fermions"><a class="docs-heading-anchor" href="#ss_fermions">Fermionic sectors</a><a id="ss_fermions-1"></a><a class="docs-heading-anchor-permalink" href="#ss_fermions" title="Permalink"></a></h2><p>All of the sectors discussed in <a href="#ss_groups">Group representations</a> have a bosonic braiding style. This does not mean that <code>Rsymbol</code> is always trivial, as for example for <code>SU2Irrep</code> the definition was given by</p><pre><code class="language-julia hljs">function Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)
    Nsymbol(sa, sb, sc) || return zero(sectorscalartype(SU2Irrep))
    return iseven(convert(Int, sa.j + sb.j - sc.j)) ? one(sectorscalartype(SU2Irrep)) :
        -one(sectorscalartype(SU2Irrep))
end</code></pre><p>It does however mean that all twists <span>$θ_a$</span> are trivial (equal to <span>$1$</span>). We refer to the appendix on <a href="../../appendix/categories/#s_categories">Category theory</a> for more details on the meaning of the twist. In summary, triviality of the twists implies that self-crossings of lines in tensor diagrams can be ignored, i.e. they can be removed without changing the value of the diagram.</p><p>As is well known, this becomes more subtle when fermionic degrees are involved. Technically, fermions are described using super vector spaces, which are <span>$ℤ₂$</span>-graded vector spaces <span>$V = V_0 ⊕ V_1$</span>, i.e. the vector space is decomposed as an (orthogonal) direct sum into an even and odd subspace, corresponding to states with even and odd fermion parity, respectively. The tensor product of two super vector spaces <span>$V$</span> and <span>$W$</span> is again graded as <span>$(V ⊗ W)_0 = (V_0 ⊗ W_0) ⊕ (V_1 ⊗ W_1)$</span> and <span>$(V ⊗ W)_1 = (V_0 ⊗ W_1) ⊕ (V_1 ⊗ W_0)$</span>. However, when exchanging two super vector spaces in such a tensor product, the natural isomorphism <span>$V ⊗ W → W ⊗ V$</span> takes into account the fermionic nature by acting with a minus sign in the subspace <span>$V_1 ⊗ W_1$</span>. This is known as the Koszul sign rule.</p><p>The super vector space structure fits naturally in the framework of TensorKit.jl. Indeed, the grading naturally corresponds to a <span>$ℤ₂$</span>-valued sector structure, which we implement as <a href="../../lib/sectors/#TensorKitSectors.FermionParity"><code>FermionParity</code></a>:</p><pre><code class="language-julia hljs">struct FermionParity &lt;: Sector
    isodd::Bool
end
const fℤ₂ = FermionParity
fermionparity(f::FermionParity) = f.isodd</code></pre><p>with straightforward fusion rules and associators</p><pre><code class="language-julia hljs">⊗(a::FermionParity, b::FermionParity) = (FermionParity(a.isodd ⊻ b.isodd),)
function Nsymbol(a::FermionParity, b::FermionParity, c::FermionParity)
    return (a.isodd ⊻ b.isodd) == c.isodd
end
function Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I &lt;: FermionParity}
    return Int(Nsymbol(a, b, e) * Nsymbol(e, c, d) * Nsymbol(b, c, f) * Nsymbol(a, f, d))
end</code></pre><p>but with non-trivial braiding and twist</p><pre><code class="language-julia hljs">function Rsymbol(a::I, b::I, c::I) where {I &lt;: FermionParity}
    return a.isodd &amp;&amp; b.isodd ? -Int(Nsymbol(a, b, c)) : Int(Nsymbol(a, b, c))
end
twist(a::FermionParity) = a.isodd ? -1 : +1</code></pre><p>The super vector space structure can also be combined with other sector types using the <code>⊠</code> operator discussed <a href="#ss_productsectors">above</a>. In some cases, there is a richer symmetry than <span>$ℤ₂$</span> associated with the fermionic degrees of freedom, and there is a natural fermion parity associated with the sectors of that symmetry. An example would be a <span>$\mathsf{U}_1$</span> symmetry associated with fermion number conservation, where odd <span>$\mathsf{U}_1$</span> charges correspond to odd fermion parity. However, it is then always possible to separate out the fermion parity structure as a separate sector, and treat the original sectors as bosonic, by only restricting to combinations of sectors that satisfy the natural fermion parity association.</p><p>For convenience (and partially due to legacy reasons), TensorKitSectors.jl does provide <a href="../../lib/sectors/#TensorKitSectors.FermionNumber"><code>FermionNumber</code></a> and <a href="../../lib/sectors/#TensorKitSectors.FermionSpin"><code>FermionSpin</code></a> constructors, which are defined as</p><pre><code class="language-julia hljs">const FermionNumber = U1Irrep ⊠ FermionParity
const fU₁ = FermionNumber
FermionNumber(a::Int) = U1Irrep(a) ⊠ FermionParity(isodd(a))

const FermionSpin = SU2Irrep ⊠ FermionParity
const fSU₂ = FermionSpin
FermionSpin(j::Real) = (s = SU2Irrep(j); s ⊠ FermionParity(isodd(twice(s.j))))</code></pre><p>We conclude this subsection with some examples.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = FermionParity(true)</code><code class="nohighlight hljs ansi" style="display:block;">FermionParity(1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p ⊗ p</code><code class="nohighlight hljs ansi" style="display:block;">(FermionParity(0),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(p)</code><code class="nohighlight hljs ansi" style="display:block;">-1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(p)</code><code class="nohighlight hljs ansi" style="display:block;">UniqueFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BraidingStyle(p)</code><code class="nohighlight hljs ansi" style="display:block;">Fermionic()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = FermionSpin(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](3/2) ⊠ FermionParity(1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(s)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(s)</code><code class="nohighlight hljs ansi" style="display:block;">-1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(s)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{SU2Irrep, FermionParity}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(s)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BraidingStyle(s)</code><code class="nohighlight hljs ansi" style="display:block;">Fermionic()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(s ⊗ s)</code><code class="nohighlight hljs ansi" style="display:block;">4×1 Matrix{ProductSector{Tuple{SU2Irrep, FermionParity}}}:
 (0, 0)
 (1, 0)
 (2, 0)
 (3, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for s2 in s ⊗ s
           @show s2
           @show Rsymbol(s, s, s2)
       end</code><code class="nohighlight hljs ansi" style="display:block;">s2 = (Irrep[SU₂](0) ⊠ FermionParity(0))
Rsymbol(s, s, s2) = 1.0
s2 = (Irrep[SU₂](1) ⊠ FermionParity(0))
Rsymbol(s, s, s2) = -1.0
s2 = (Irrep[SU₂](2) ⊠ FermionParity(0))
Rsymbol(s, s, s2) = 1.0
s2 = (Irrep[SU₂](3) ⊠ FermionParity(0))
Rsymbol(s, s, s2) = -1.0</code></pre><p>Note in particular how the <code>Rsymbol</code> values have opposite signs to the bosonic case, where the fusion of two equal half-integer spins to the trivial sector is antisymmetric and would thus have <code>Rsymbol</code> value <code>-1</code>.</p><h2 id="Anyons"><a class="docs-heading-anchor" href="#Anyons">Anyons</a><a id="Anyons-1"></a><a class="docs-heading-anchor-permalink" href="#Anyons" title="Permalink"></a></h2><p>Both <code>Bosonic</code> and <code>Fermionic</code> braiding styles are <code>SymmetricBraiding</code> styles, which means that exchanging two sectors twice is equivalent to the identity operation. In tensor network diagrams, this implies that lines that cross twice are equivalent to them not crossing at all, or also, that there is no distinction betweeen a line crossing &quot;above&quot; or &quot;below&quot; another line. More technically, the relevant group describing the exchange processes is the permutation group, whereas in more general cases it would be the braid group.</p><p>This more general case is denoted as the <code>Anyonic</code> braiding style in TensorKit.jl, because examples of this behaviour appear in the context of anyons in topological phases of matter.</p><p>There are currently two well-known sector types with <code>Anyonic</code> braiding style implemented in TensorKitSectors. l, namely <a href="../../lib/sectors/#TensorKitSectors.FibonacciAnyon"><code>FibonacciAnyon</code></a> and <a href="../../lib/sectors/#TensorKitSectors.IsingAnyon"><code>IsingAnyon</code></a>. Their values represent the (equivalence classes of) simple objects of the well-known Fibonicci and Ising fusion categories. As an example, we illustrate below the Fibonacci anyons, which has only two distinct sectors, namely the unit sector <code>𝟙</code> and one non-trivial sector denoted as <code>τ</code>. The fusion rules are given by <code>τ ⊗ τ = 𝟙 ⊕ τ</code>, and the topological data is summarized by the following code</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝟙 = FibonacciAnyon(:I)</code><code class="nohighlight hljs ansi" style="display:block;">FibonacciAnyon(:I)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; τ = FibonacciAnyon(:τ)</code><code class="nohighlight hljs ansi" style="display:block;">FibonacciAnyon(:τ)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(τ ⊗ τ)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{FibonacciAnyon}:
 :I
 :τ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(τ)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BraidingStyle(τ)</code><code class="nohighlight hljs ansi" style="display:block;">Anyonic()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(𝟙)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(τ)</code><code class="nohighlight hljs ansi" style="display:block;">1.618033988749895</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F𝟙 = Fsymbol(τ,τ,τ,𝟙,τ,τ)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fτ = [Fsymbol(τ,τ,τ,τ,𝟙,𝟙) Fsymbol(τ,τ,τ,τ,𝟙,τ); Fsymbol(τ,τ,τ,τ,τ,𝟙) Fsymbol(τ,τ,τ,τ,τ,τ)]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.618034   0.786151
 0.786151  -0.618034</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fτ&#39;*Fτ</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polar(x) = rationalize.((abs(x), angle(x)/(2pi)))</code><code class="nohighlight hljs ansi" style="display:block;">polar (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rsymbol(τ,τ,𝟙) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, 2//5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rsymbol(τ,τ,τ) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, -3//10)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(τ) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, -2//5)</code></pre><h2 id="ss_generalsectors"><a class="docs-heading-anchor" href="#ss_generalsectors">Further generalizations</a><a id="ss_generalsectors-1"></a><a class="docs-heading-anchor-permalink" href="#ss_generalsectors" title="Permalink"></a></h2><p>The <code>Anyonic</code> braiding style is one generalization beyond the bosonic and fermionic representation theory of groups, i.e. the action of groups on vector spaces and super vector spaces. It is also possible to consider fusion categories without braiding structure, represented as <code>NoBraiding</code> in TensorKitSectors.jl. Indeed, the framework for sectors outlined above is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) <a href="https://en.wikipedia.org/wiki/Fusion_category">fusion category</a>, which is reviewed in the appendix on <a href="../../appendix/categories/#s_categories">category theory</a>. For such categories, the objects are not necessarily vector spaces and the fusion and splitting tensors <span>$X^{ab}_{c,μ}$</span> do not necessarily exist as actual tensors. However, the morphism spaces <span>$c → a ⊗ b$</span> still behave as vector spaces, and the <span>$X^{ab}_{c,μ}$</span> act as generic basis for that space. As TensorKit.jl does not rely on the <span>$X^{ab}_{c,μ}$</span> themselves (even when they do exist), it can also deal with such general fusion categories. An extensive list of (the topological data of) such fusion categories, with and without braiding, is provided in <a href="https://github.com/lkdvos/CategoryData.jl">CategoryData.jl</a>.</p><p>Within TensorKit.jl, the only sector with <code>NoBraiding</code> is the <a href="../../lib/sectors/#TensorKitSectors.PlanarTrivial"><code>PlanarTrivial</code></a> sector, which is actually equivalent to the <code>Trivial</code> sector, but where the braiding has been &quot;disabled&quot; for testing purposes.</p><p>Finally, as mentioned above, a recent extension prepares TensorKitSectors.jl to deal with multi-fusion categories, where the sectors (simple objects) are organized in a matrix-like structure and thus have an additional row and column index. Fusion between sectors is only possible when the row and column indices match appropriately; otherwise the fusion product is empty. In this structure, the different <em>diagonal</em> sectors define separate fusion categories, whereas the <em>off-diagonal</em> sectors define bimodule categories between these fusion categories. Every diagonal set of sectors has its own unit sector, which also acts as the left / right unit for other sectors in the same column / row. The global unit object is not simple, but rather given by the direct sum of all diagonal unit sectors. We do not document or illustrate this structure here, but refer to the relevant functions <a href="../../lib/sectors/#TensorKitSectors.leftunit"><code>leftunit</code></a>, <a href="../../lib/sectors/#TensorKitSectors.rightunit"><code>rightunit</code></a>, <a href="../../lib/sectors/#TensorKitSectors.allunits"><code>allunits</code></a> and <a href="../../lib/sectors/#TensorKitSectors.UnitStyle"><code>UnitStyle</code></a> for more information. Furthermore, we refer to <a href="https://github.com/QuantumKitHub/MultiTensorKit.jl">MultiTensorKit.jl</a> for examples and ongoing development work on using multi-fusion categories.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../symmetries/">« Symmetries</a><a class="docs-footer-nextpage" href="../gradedspaces/">Graded spaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 11:12">Friday 27 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
