<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graded spaces · TensorKit.jl</title><meta name="title" content="Graded spaces · TensorKit.jl"/><meta property="og:title" content="Graded spaces · TensorKit.jl"/><meta property="twitter:title" content="Graded spaces · TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../symmetries/">Symmetries</a></li><li><a class="tocitem" href="../sectors/">Sectors</a></li><li class="is-active"><a class="tocitem" href>Graded spaces</a><ul class="internal"><li><a class="tocitem" href="#Implementation-details"><span>Implementation details</span></a></li><li><a class="tocitem" href="#Constructing-instances"><span>Constructing instances</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../tensors/">Constructing tensors and the <code>TensorMap</code> type</a></li><li><a class="tocitem" href="../tensormanipulations/">Manipulating tensors</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors</a></li><li><a class="tocitem" href="../../lib/fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/symmetric_tutorial/">A symmetric tensor deep dive: constructing your first tensor map</a></li><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li><li><a class="tocitem" href="../../Changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Graded spaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graded spaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/man/gradedspaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="s_gradedspaces"><a class="docs-heading-anchor" href="#s_gradedspaces">Graded spaces</a><a id="s_gradedspaces-1"></a><a class="docs-heading-anchor-permalink" href="#s_gradedspaces" title="Permalink"></a></h1><p>We have introduced <code>Sector</code> subtypes as a way to label the irreps or sectors in the decomposition <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>. To actually represent such spaces, we now also introduce a corresponding type <code>GradedSpace</code>, which is a subtype of <code>ElementarySpace</code>:</p><article><details class="docstring"><summary id="TensorKit.GradedSpace-man-gradedspaces"><a class="docstring-binding" href="#TensorKit.GradedSpace-man-gradedspaces"><code>TensorKit.GradedSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct GradedSpace{I&lt;:Sector, D} &lt;: ElementarySpace
GradedSpace{I,D}(dims; dual::Bool = false) where {I&lt;:Sector, D}</code></pre><p>A complex Euclidean space with a grading, i.e. a direct sum structure corresponding to labels in a set <code>I</code>, the objects of which have the structure of a monoid with respect to a monoidal product <code>⊗</code>. In practice, we restrict the label set to be a set of superselection sectors of type <code>I&lt;:Sector</code>, e.g. the set of distinct irreps of a finite or compact group, or the isomorphism classes of simple objects of a unitary and pivotal (pre-, multi-) fusion category.</p><p>Here <code>dims</code> represents the degeneracy or multiplicity of every sector.</p><p>The data structure <code>D</code> of <code>dims</code> will depend on the result <code>Base.IteratorSize(values(I))</code>. If the result is of type <code>HasLength</code> or <code>HasShape</code>, <code>dims</code> will be stored in a <code>NTuple{N,Int}</code> with <code>N = length(values(I))</code>. This requires that a sector <code>s::I</code> can be transformed into an index via <code>s == getindex(values(I), i)</code> and <code>i == findindex(values(I), s)</code>. If <code>Base.IteratorElsize(values(I))</code> results <code>IsInfinite()</code> or <code>SizeUnknown()</code>, a <code>SectorDict{I,Int}</code> is used to store the non-zero degeneracy dimensions with the corresponding sector as key. The parameter <code>D</code> is hidden from the user and should typically be of no concern.</p><p>The concrete type <code>GradedSpace{I,D}</code> with correct <code>D</code> can be obtained as <code>Vect[I]</code>, or if <code>I == Irrep[G]</code> for some <code>G&lt;:Group</code>, as <code>Rep[G]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/c28d9ac021645ade521e4d5281d95f21bf83723d/src/spaces/gradedspace.jl#L1-L25">source</a></section></details></article><p>Here, <code>D</code> is a type parameter to denote the data structure used to store the degeneracy or multiplicity dimensions <span>$n_a$</span> of the different sectors. For convenience, <code>Vect[I]</code> will return the fully concrete type with <code>D</code> specified.</p><p>Note that, conventionally, a graded vector space is a space that has a natural direct sum decomposition over some set of labels, i.e. <span>$V = ⨁_{a ∈ I} V_a$</span> where the label set <span>$I$</span> has the structure of a semigroup <span>$a ⊗ b = c ∈ I$</span>. Here, we generalize this notation by using for <span>$I$</span> the fusion ring of a fusion category, <span>$a ⊗ b = ⨁_{c ∈ I} ⨁_{μ = 1}^{N_{a,b}^c} c$</span>. However, this is mostly to lower the barrier, as really the instances of <code>GradedSpace</code> represent just general objects in a fusion category (or strictly speaking, a pre-fusion category, as we allow for an infinite number of simple objects, e.g. the irreps of a continuous group).</p><h2 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h2><p>As mentioned, the way in which the degeneracy dimensions <span>$n_a$</span> are stored depends on the specific sector type <code>I</code>, more specifically on the <code>IteratorSize</code> of <code>values(I)</code>. If <code>IteratorSize(values(I)) isa Union{IsInfinite, SizeUnknown}</code>, the different sectors <span>$a$</span> and their corresponding degeneracy <span>$n_a$</span> are stored as key value pairs in an <code>Associative</code> array, i.e. a dictionary <code>dims::SectorDict</code>. As the total number of sectors in <code>values(I)</code> can be infinite, only sectors <span>$a$</span> for which <span>$n_a$</span> are stored. Here, <code>SectorDict</code> is a constant type alias for a specific dictionary implementation, which currently resorts to <code>SortedVectorDict</code> implemented in TensorKit.jl. Hence, the sectors and their corresponding dimensions are stored as two matching lists (<code>Vector</code> instances), which are ordered based on the property <code>isless(a::I, b::I)</code>. This ensures that the space <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span> has some unique canonical order in the direct sum decomposition, such that two different but equal instances created independently always match.</p><p>If <code>IteratorSize(values(I)) isa Union{HasLength, HasShape}</code>, the degeneracy dimensions <code>n_a</code> are stored for all sectors <code>a ∈ values(I)</code> (also if <code>n_a == 0</code>) in a tuple, more specifically a <code>NTuple{N, Int}</code> with <code>N = length(values(I))</code>. The methods <code>getindex(values(I), i)</code> and <code>findindex(values(I), a)</code> are used to map between a sector <code>a ∈ values(I)</code> and a corresponding index <code>i ∈ 1:N</code>. As <code>N</code> is a compile time constant, these types can be created in a type stable manner. Note however that this implies that for large values of <code>N</code>, it can be beneficial to define <code>IteratorSize(values(a)) = SizeUnknown()</code> to not overly burden the compiler.</p><h2 id="Constructing-instances"><a class="docs-heading-anchor" href="#Constructing-instances">Constructing instances</a><a id="Constructing-instances-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-instances" title="Permalink"></a></h2><p>As mentioned, the convenience method <code>Vect[I]</code> will return the concrete type <code>GradedSpace{I, D}</code> with the matching value of <code>D</code>, so that should never be a user&#39;s concern. In fact, for consistency, <code>Vect[Trivial]</code> will just return <code>ComplexSpace</code>, which is not even a specific type of <code>GradedSpace</code>. For the specific case of group irreps as sectors, one can use <code>Rep[G]</code> with <code>G</code> the group, as inspired by the categorical name <span>$\mathbf{Rep}_{\mathsf{G}}$</span>. Some illustrations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Trivial]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[U1Irrep]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep, TensorKit.SortedVectorDict{U1Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[U₁]]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep, TensorKit.SortedVectorDict{U1Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[U₁]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep, TensorKit.SortedVectorDict{U1Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[ℤ₂ × SU₂]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, TensorKit.SortedVectorDict{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[ℤ₂ × SU₂]]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, TensorKit.SortedVectorDict{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64}}</code></pre><p>Note that we also have the specific alias <code>U₁Space</code>. In fact, for all the common groups we have a number of aliases, both in ASCII and using Unicode:</p><pre><code class="language-julia hljs"># ASCII type aliases
const ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}
const Z2Space = ZNSpace{2}
const Z3Space = ZNSpace{3}
const Z4Space = ZNSpace{4}
const U1Space = Rep[U₁]
const CU1Space = Rep[CU₁]
const SU2Space = Rep[SU₂]

# Unicode alternatives
const ℤ₂Space = Z2Space
const ℤ₃Space = Z3Space
const ℤ₄Space = Z4Space
const U₁Space = U1Space
const CU₁Space = CU1Space
const SU₂Space = SU2Space</code></pre><p>To create specific instances of those types, one can e.g. just use <code>V = GradedSpace(a =&gt; n_a, b =&gt; n_b, c =&gt; n_c)</code> or <code>V = GradedSpace(iterator)</code> where <code>iterator</code> is any iterator (e.g. a dictionary or a generator) that yields <code>Pair{I, Int}</code> instances. With those constructions, <code>I</code> is inferred from the type of sectors. However, it is often more convenient to specify the sector type explicitly (using one of the many alias provided), since then the sectors are automatically converted to the correct type. Thereto, one can use <code>Vect[I]</code>, or when <code>I</code> corresponds to the irreducible representations of a group, <code>Rep[G]</code>. Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[U₁]](0 =&gt; 3, 1 =&gt; 2, -1 =&gt; 1) ==
           GradedSpace(U1Irrep(0) =&gt; 3, U1Irrep(1) =&gt; 2, U1Irrep(-1) =&gt; 1) ==
           U1Space(0 =&gt; 3, 1 =&gt; 2, -1 =&gt; 1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The fact that <code>Rep[G]</code> also works with product groups makes it easy to specify e.g.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[ℤ₂ × SU₂]((0, 0) =&gt; 3, (1, 1/2) =&gt; 2, (0, 1) =&gt; 1) ==
           GradedSpace((Z2Irrep(0) ⊠ SU2Irrep(0)) =&gt; 3, (Z2Irrep(1) ⊠ SU2Irrep(1/2)) =&gt; 2, (Z2Irrep(0) ⊠ SU2Irrep(1)) =&gt; 1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>There are a number of methods to work with instances <code>V</code> of <code>GradedSpace</code>. The function <a href="../../lib/spaces/#TensorKit.sectortype"><code>sectortype</code></a> returns the type of the sector labels. It also works on other vector spaces, in which case it returns <a href="../../lib/sectors/#TensorKitSectors.Trivial"><code>Trivial</code></a>. The function <a href="../../lib/spaces/#TensorKit.sectors"><code>sectors</code></a> returns an iterator over the different sectors <code>a</code> with non-zero <code>n_a</code>, for other <code>ElementarySpace</code> types it returns <code>(Trivial,)</code>. The degeneracy dimensions <code>n_a</code> can be extracted as <code>dim(V, a)</code>, it properly returns <code>0</code> if sector <code>a</code> is not present in the decomposition of <code>V</code>. With <a href="../../lib/spaces/#TensorKit.hassector"><code>hassector(V, a)</code></a> one can check if <code>V</code> contains a sector <code>a</code> with <code>dim(V, a) &gt; 0</code>. Finally, <code>dim(V)</code> returns the total dimension of the space <code>V</code>, i.e. <span>$∑_a n_a d_a$</span> or thus <code>dim(V) = sum(dim(V, a) * dim(a) for a in sectors(V))</code>. Note that a representation space <code>V</code> has certain sectors <code>a</code> with dimensions <code>n_a</code>, then its dual <code>V&#39;</code> will report to have sectors <code>dual(a)</code>, and <code>dim(V&#39;, dual(a)) == n_a</code>. There is a subtelty regarding the difference between the dual of a representation space <span>$R_a^*$</span>, on which the conjugate representation acts, and the representation space of the irrep <code>dual(a) == conj(a)</code> that is isomorphic to the conjugate representation, i.e. <span>$R_{\overline{a}} ≂ R_a^*$</span> but they are not equal. We return to this in the section on <a href="@ref ss_fusiontrees">fusion trees</a>. This is true also in more general fusion categories beyond the representation categories of groups.</p><p>Other methods for <code>ElementarySpace</code>, such as <a href="../../lib/sectors/#TensorKitSectors.dual-Tuple{Sector}"><code>dual</code></a>, <a href="../../lib/spaces/#TensorKit.fuse"><code>fuse</code></a> and <a href="../../lib/spaces/#TensorKit.flip"><code>flip</code></a> also work. In fact, <code>GradedSpace</code> is the reason <code>flip</code> exists, because in this case it is different than <code>dual</code>. The existence of flip originates from the non-trivial isomorphism between <span>$R_{\overline{a}}$</span> and <span>$R_{a}^*$</span>, i.e. the representation space of the dual <span>$\overline{a}$</span> of sector <span>$a$</span> and the dual of the representation space of sector <span>$a$</span>. In order for <code>flip(V)</code> to be isomorphic to <code>V</code>, it is such that, if <code>V = GradedSpace(a=&gt;n_a,...)</code> then <code>flip(V) = dual(GradedSpace(dual(a)=&gt;n_a,....))</code>.</p><p>Furthermore, for two spaces <code>V1 = GradedSpace(a =&gt; n1_a, ...)</code> and <code>V2 = GradedSpace(a =&gt; n2_a, ...)</code>, we have <code>infimum(V1, V2) = GradedSpace(a =&gt; min(n1_a, n2_a), ....)</code> and similarly for <code>supremum</code>, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of <code>infimum(V1, V2)</code> or <code>supremum(V1, V2)</code> is neither equal to <code>V1</code> or <code>V2</code>.</p><p>For <code>W</code> a <code>ProductSpace{Vect[I], N}</code>, <a href="../../lib/spaces/#TensorKit.sectors"><code>sectors(W)</code></a> returns an iterator that generates all possible combinations of sectors <code>as</code> represented as <code>NTuple{I, N}</code>. The function <a href="../../lib/spaces/#TensorKit.dims"><code>dims(W, as)</code></a> returns the corresponding tuple with degeneracy dimensions, while <a href="../../lib/sectors/#TensorKitSectors.dim-Tuple{Sector}"><code>dim(W, as)</code></a> returns the product of these dimensions. <a href="../../lib/spaces/#TensorKit.hassector"><code>hassector(W, as)</code></a> is equivalent to <code>dim(W, as) &gt; 0</code>. Finally, there is the function <a href="../../lib/spaces/#TensorKit.blocksectors-Union{Tuple{ProductSpace{S, N}}, Tuple{N}, Tuple{S}} where {S, N}"><code>blocksectors(W)</code></a> which returns a list (of type <code>Vector</code>) with all possible &quot;block sectors&quot; or total/coupled sectors that can result from fusing the individual uncoupled sectors in <code>W</code>. Correspondingly, <a href="../../lib/spaces/#TensorKit.blockdim"><code>blockdim(W, a)</code></a> counts the total degeneracy dimension of the coupled sector <code>a</code> in <code>W</code>. The machinery for computing this is the topic of the next section on <a href="@ref ss_fusiontrees">Fusion trees</a>, but first, it&#39;s time for some examples.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Let&#39;s start with an example involving <span>$\mathsf{U}_1$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = Rep[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…) of dim 6:
  0 =&gt; 3
  1 =&gt; 2
 -1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 == U1Space(0=&gt;3, 1=&gt;2, -1=&gt;1) == U₁Space(-1=&gt;1, 1=&gt;2,0=&gt;3) # order doesn&#39;t matter</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (sectors(V1)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U₁](0), Irrep[U₁](1), Irrep[U₁](-1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1, U1Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1&#39;, Irrep[U₁](1)) == dim(V1, conj(U1Irrep(1))) == dim(V1, U1Irrep(-1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[U₁](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[U₁](2))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…)&#39; of dim 6:
  0 =&gt; 3
  1 =&gt; 2
 -1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…)&#39; of dim 6:
  0 =&gt; 3
  1 =&gt; 1
 -1 =&gt; 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1) ≅ V1</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1) ≅ V1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = U1Space(0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…) of dim 6:
  0 =&gt; 2
  1 =&gt; 1
 -1 =&gt; 1
  2 =&gt; 1
 -2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…) of dim 4:
  0 =&gt; 2
  1 =&gt; 1
 -1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…) of dim 8:
  0 =&gt; 3
  1 =&gt; 2
 -1 =&gt; 1
  2 =&gt; 1
 -2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ⊕(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…) of dim 12:
  0 =&gt; 5
  1 =&gt; 3
 -1 =&gt; 2
  2 =&gt; 1
 -2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ⊗(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[U₁](0 =&gt; 3, 1 =&gt; 2, -1 =&gt; 1) ⊗ Rep[U₁](0 =&gt; 2, 1 =&gt; 1, -1 =&gt; 1, 2 =&gt; 1, -2 =&gt; 1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(sectors(W))</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Matrix{Tuple{Any, Any}}:
 (Irrep[U₁](0), Irrep[U₁](0))   …  (Irrep[U₁](0), Irrep[U₁](-2))
 (Irrep[U₁](1), Irrep[U₁](0))      (Irrep[U₁](1), Irrep[U₁](-2))
 (Irrep[U₁](-1), Irrep[U₁](0))     (Irrep[U₁](-1), Irrep[U₁](-2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(W, (Irrep[U₁](0), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W, (Irrep[U₁](0), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (Irrep[U₁](0), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (Irrep[U₁](2), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(W)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](…) of dim 36:
  0 =&gt; 9
  1 =&gt; 8
 -1 =&gt; 7
  2 =&gt; 5
 -2 =&gt; 4
  3 =&gt; 2
 -3 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (blocksectors(W)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U₁](0), Irrep[U₁](1), Irrep[U₁](-1), Irrep[U₁](2), Irrep[U₁](-2), Irrep[U₁](3), Irrep[U₁](-3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blockdim(W, Irrep[U₁](0))</code><code class="nohighlight hljs ansi" style="display:block;">9</code></pre><p>and then with <span>$\mathsf{SU}_2$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = Vect[Irrep[SU₂]](0=&gt;3, 1//2=&gt;2, 1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…) of dim 10:
   0 =&gt; 3
 1/2 =&gt; 2
   1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 == SU2Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1) == SU₂Space(0=&gt;3, 0.5=&gt;2, 1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (sectors(V1)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](0), Irrep[SU₂](1/2), Irrep[SU₂](1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1, SU2Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1&#39;, SU2Irrep(1)) == dim(V1, conj(SU2Irrep(1))) == dim(V1, Irrep[SU₂](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[SU₂](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[SU₂](2))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…)&#39; of dim 10:
   0 =&gt; 3
 1/2 =&gt; 2
   1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…)&#39; of dim 10:
   0 =&gt; 3
 1/2 =&gt; 2
   1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU2Space(0=&gt;2, 1//2=&gt;1, 1=&gt;1, 3//2=&gt;1, 2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…) of dim 16:
   0 =&gt; 2
 1/2 =&gt; 1
   1 =&gt; 1
 3/2 =&gt; 1
   2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…) of dim 7:
   0 =&gt; 2
 1/2 =&gt; 1
   1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…) of dim 19:
   0 =&gt; 3
 1/2 =&gt; 2
   1 =&gt; 1
 3/2 =&gt; 1
   2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ⊕(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…) of dim 26:
   0 =&gt; 5
 1/2 =&gt; 3
   1 =&gt; 2
 3/2 =&gt; 1
   2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ⊗(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU₂](0 =&gt; 3, 1/2 =&gt; 2, 1 =&gt; 1) ⊗ Rep[SU₂](0 =&gt; 2, 1/2 =&gt; 1, 1 =&gt; 1, 3/2 =&gt; 1, 2 =&gt; 1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(sectors(W))</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Matrix{Tuple{Any, Any}}:
 (Irrep[SU₂](0), Irrep[SU₂](0))    …  (Irrep[SU₂](0), Irrep[SU₂](2))
 (Irrep[SU₂](1/2), Irrep[SU₂](0))     (Irrep[SU₂](1/2), Irrep[SU₂](2))
 (Irrep[SU₂](1), Irrep[SU₂](0))       (Irrep[SU₂](1), Irrep[SU₂](2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(W, (Irrep[SU₂](0), Irrep[SU₂](0)))</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W, (Irrep[SU₂](0), Irrep[SU₂](0)))</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (SU2Irrep(0), SU2Irrep(0)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (SU2Irrep(2), SU2Irrep(0)))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(W)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](…) of dim 160:
   0 =&gt; 9
 1/2 =&gt; 11
   1 =&gt; 11
 3/2 =&gt; 9
   2 =&gt; 7
 5/2 =&gt; 3
   3 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (blocksectors(W)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](0), Irrep[SU₂](1/2), Irrep[SU₂](1), Irrep[SU₂](3/2), Irrep[SU₂](2), Irrep[SU₂](5/2), Irrep[SU₂](3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blockdim(W, SU2Irrep(0))</code><code class="nohighlight hljs ansi" style="display:block;">9</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sectors/">« Sectors</a><a class="docs-footer-nextpage" href="../fusiontrees/">Fusion trees »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 11:44">Friday 27 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
