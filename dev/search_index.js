var documenterSearchIndex = {"docs":
[{"location":"lib/tensors/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"lib/tensors/#Type-hierarchy","page":"Tensors","title":"Type hierarchy","text":"The abstract supertype of all tensors in TensorKit is given by AbstractTensorMap:\n\nThe following concrete subtypes are provided within the TensorKit library:\n\nOf those, TensorMap provides the generic instantiation of our tensor concept. It supports various constructors, which are discussed in the next subsection.\n\nFurthermore, some aliases are provided for convenience:","category":"section"},{"location":"lib/tensors/#TensorMap-constructors","page":"Tensors","title":"TensorMap constructors","text":"","category":"section"},{"location":"lib/tensors/#General-constructors","page":"Tensors","title":"General constructors","text":"A TensorMap with undefined data can be constructed by specifying its domain and codomain:\n\nThe resulting object can then be filled with data using the setindex! method as discussed below, using functions such as VectorInterface.zerovector!, rand! or fill!, or it can be used as an output argument in one of the many methods that accept output arguments, or in an @tensor output[...] = ... expression.\n\nAlternatively, a TensorMap can be constructed by specifying its data, codomain and domain in one of the following ways:\n\nFinally, we also support the following Array-like constructors\n\nas well as a similar constructor","category":"section"},{"location":"lib/tensors/#Specific-constructors","page":"Tensors","title":"Specific constructors","text":"Additionally, the following methods can be used to construct specific TensorMap instances.","category":"section"},{"location":"lib/tensors/#AbstractTensorMap-properties-and-data-access","page":"Tensors","title":"AbstractTensorMap properties and data access","text":"The following methods exist to obtain type information:\n\nTo obtain information about the indices, you can use:\n\nIn TensorMap instances, all data is gathered in a single AbstractVector, which has an internal structure into blocks associated to total coupled charge, within which live subblocks associated with the different possible fusion-splitting tree pairs.\n\nTo obtain information about the structure of the data, you can use:\n\nData can be accessed (and modified) in a number of ways. To access the full matrix block associated with the coupled charges, you can use:\n\nTo access the reduced tensor elements associated to fusion tree pairs, you can use:\n\nTo access the data associated with a specific fusion tree pair, you can use:\n\nFor a tensor t with FusionStyle(sectortype(t)) isa UniqueFusion, fusion trees are completely determined by the outcoming sectors, and the data can be accessed in a more straightforward way:\n\nFor tensor t with sectortype(t) == Trivial, the data can be accessed and manipulated directly as multidimensional arrays:\n\nThe tensor data can also be filled with random numbers via","category":"section"},{"location":"lib/tensors/#AbstractTensorMap-operations","page":"Tensors","title":"AbstractTensorMap operations","text":"The operations that can be performed on an AbstractTensorMap can be organized into the following categories:\n\nvector operations: these do not change the space or index structure of a tensor and can be straightforwardly implemented on on the full data.   All the methods described in VectorInterface.jl are supported.   For compatibility reasons, we also provide implementations for equivalent methods from LinearAlgebra.jl, such as axpy!, axpby!.\nindex manipulations: these change (permute) the index structure of a tensor, which affects the data in a way that is fully determined by the categorical data of the sectortype of the tensor .\n(planar) contractions and (planar) traces (i.e., contractions with identity tensors).   Tensor contractions correspond to a combination of some index manipulations followed by a composition or multiplication of the tensors in their role as linear maps.   Tensor contractions are however of such importance and frequency that they require a dedicated implementation.\ntensor factorizations, which relies on their identification of tensors with linear maps between tensor spaces.   The factorizations are applied as ordinary matrix factorizations to the matrix blocks associated with the coupled charges.","category":"section"},{"location":"lib/tensors/#Index-manipulations","page":"Tensors","title":"Index manipulations","text":"A general index manipulation of a TensorMap object can be built up by considering some transformation of the fusion trees, along with a permutation of the stored data. They come in three flavours, which are either of the type transform(!) which are exported, or of the type add_transform!, for additional expert-mode options that allows for addition and scaling, as well as the selection of a custom backend.","category":"section"},{"location":"lib/tensors/#Tensor-map-composition,-traces,-contractions-and-tensor-products","page":"Tensors","title":"Tensor map composition, traces, contractions and tensor products","text":"","category":"section"},{"location":"lib/tensors/#TensorMap-factorizations","page":"Tensors","title":"TensorMap factorizations","text":"The factorization methods are powered by MatrixAlgebraKit.jl and all follow the same strategy. The idea is that the TensorMap is interpreted as a linear map based on the current partition of indices between domain and codomain, and then the entire range of MatrixAlgebraKit functions can be called. Factorizing a tensor according to a different partition of the indices is possible by prepending the factorization step with an explicit call to permute or transpose.\n\nFor the full list of factorizations, see Decompositions.\n\nAdditionally, it is possible to obtain truncated versions of some of these factorizations through the MatrixAlgebraKit.TruncationStrategy objects.\n\nThe exact truncation strategy can be controlled through the strategies defined in Truncations, but for TensorMaps there is also the special-purpose scheme:","category":"section"},{"location":"lib/tensors/#TensorKit.AbstractTensorMap","page":"Tensors","title":"TensorKit.AbstractTensorMap","text":"abstract type AbstractTensorMap{T<:Number, S<:IndexSpace, N‚ÇÅ, N‚ÇÇ} end\n\nAbstract supertype of all tensor maps, i.e. linear maps between tensor products of vector spaces of type S<:IndexSpace, with element type T. An AbstractTensorMap maps from an input space of type ProductSpace{S, N‚ÇÇ} to an output space of type ProductSpace{S, N‚ÇÅ}.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.TensorMap","page":"Tensors","title":"TensorKit.TensorMap","text":"struct TensorMap{T, S<:IndexSpace, N‚ÇÅ, N‚ÇÇ, A<:DenseVector{T}} <: AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}\n\nSpecific subtype of AbstractTensorMap for representing tensor maps (morphisms in a tensor category), where the data is stored in a dense vector.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.DiagonalTensorMap","page":"Tensors","title":"TensorKit.DiagonalTensorMap","text":"DiagonalTensorMap{T}(undef, domain::S) where {T,S<:IndexSpace}\n# expert mode: select storage type `A`\nDiagonalTensorMap{T,S,A}(undef, domain::S) where {T,S<:IndexSpace,A<:DenseVector{T}}\n\nConstruct a DiagonalTensorMap with uninitialized data.\n\n\n\n\n\nDiagonalTensorMap(s::SectorVector)\n\nConstruct a DiagonalTensorMap directly from a SectorVector, from which the codomain (assumed non-dual) is inferred automatically.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.AdjointTensorMap","page":"Tensors","title":"TensorKit.AdjointTensorMap","text":"struct AdjointTensorMap{T, S, N‚ÇÅ, N‚ÇÇ, TT<:AbstractTensorMap} <: AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}\n\nSpecific subtype of AbstractTensorMap that is a lazy wrapper for representing the adjoint of an instance of AbstractTensorMap.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.BraidingTensor","page":"Tensors","title":"TensorKit.BraidingTensor","text":"struct BraidingTensor{T,S<:IndexSpace} <: AbstractTensorMap{T, S, 2, 2}\nBraidingTensor(V1::S, V2::S, adjoint::Bool=false) where {S<:IndexSpace}\n\nSpecific subtype of AbstractTensorMap for representing the braiding tensor that braids the first input over the second input; its inverse can be obtained as the adjoint.\n\nIt holds that domain(BraidingTensor(V1, V2)) == V1 ‚äó V2 and codomain(BraidingTensor(V1, V2)) == V2 ‚äó V1.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.AbstractTensor","page":"Tensors","title":"TensorKit.AbstractTensor","text":"AbstractTensor{T,S,N} = AbstractTensorMap{T,S,N,0}\n\nAbstract supertype of all tensors, i.e. elements in the tensor product space of type ProductSpace{S, N}, with element type T.\n\nAn AbstractTensor{T, S, N} is actually a special case AbstractTensorMap{T, S, N, 0}, i.e. a tensor map with only non-trivial output spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.Tensor","page":"Tensors","title":"TensorKit.Tensor","text":"Tensor{T, S, N, A<:DenseVector{T}} = TensorMap{T, S, N, 0, A}\n\nSpecific subtype of AbstractTensor for representing tensors whose data is stored in a dense vector.\n\nA Tensor{T, S, N, A} is actually a special case TensorMap{T, S, N, 0, A}, i.e. a tensor map with only a non-trivial output space.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.TensorMap-Union{Tuple{T}, Tuple{UndefInitializer, TensorMapSpace}} where T","page":"Tensors","title":"TensorKit.TensorMap","text":"TensorMap{T}(undef, codomain::ProductSpace{S, N‚ÇÅ}, domain::ProductSpace{S, N‚ÇÇ}) where {T, S, N‚ÇÅ, N‚ÇÇ}\nTensorMap{T}(undef, codomain ‚Üê domain)\nTensorMap{T}(undef, domain ‚Üí codomain)\n\nConstruct a TensorMap with uninitialized data with elements of type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.TensorMap-Tuple{AbstractDict{<:Sector, <:AbstractMatrix}, TensorMapSpace}","page":"Tensors","title":"TensorKit.TensorMap","text":"TensorMap(data::AbstractDict{<:Sector, <:AbstractMatrix}, codomain::ProductSpace, domain::ProductSpace)\nTensorMap(data, codomain ‚Üê domain)\nTensorMap(data, domain ‚Üí codomain)\n\nConstruct a TensorMap by explicitly specifying its block data.\n\nArguments\n\ndata::AbstractDict{<:Sector, <:AbstractMatrix}: dictionary containing the block data for each coupled sector c as a matrix of size (blockdim(codomain, c), blockdim(domain, c)).\ncodomain::ProductSpace{S, N‚ÇÅ}: the codomain as a ProductSpace of N‚ÇÅ spaces of type S <: ElementarySpace.\ndomain::ProductSpace{S, N‚ÇÇ}: the domain as a ProductSpace of N‚ÇÇ spaces of type S <: ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.TensorMap-Tuple{AbstractArray, TensorMapSpace}","page":"Tensors","title":"TensorKit.TensorMap","text":"TensorMap(data::AbstractArray, codomain::ProductSpace{S,N‚ÇÅ}, domain::ProductSpace{S,N‚ÇÇ};\n                tol=sqrt(eps(real(float(eltype(data)))))) where {S<:ElementarySpace,N‚ÇÅ,N‚ÇÇ}\nTensorMap(data, codomain ‚Üê domain; tol=sqrt(eps(real(float(eltype(data))))))\nTensorMap(data, domain ‚Üí codomain; tol=sqrt(eps(real(float(eltype(data))))))\n\nConstruct a TensorMap from a plain multidimensional array.\n\nArguments\n\ndata::DenseArray: tensor data as a plain array.\ncodomain::ProductSpace{S,N‚ÇÅ}: the codomain as a ProductSpace of N‚ÇÅ spaces of type S<:ElementarySpace.\ndomain::ProductSpace{S,N‚ÇÇ}: the domain as a ProductSpace of N‚ÇÇ spaces of type S<:ElementarySpace.\ntol=sqrt(eps(real(float(eltype(data)))))::Float64: \n\nHere, data can be specified in three ways:\n\ndata can be a DenseVector of length dim(codomain ‚Üê domain); in that case it represents the actual independent entries of the tensor map. An instance will be created that directly references data.\ndata can be an AbstractMatrix of size (dim(codomain), dim(domain))\ndata can be an AbstractArray of rank N‚ÇÅ + N‚ÇÇ with a size matching that of the domain and codomain spaces, i.e. size(data) == (dims(codomain)..., dims(domain)...)\n\nIn cases 2 and 3, the TensorMap constructor will reconstruct the tensor data such that the resulting tensor t satisfies data == convert(Array, t), up to an error specified by tol. For the case where sectortype(S) == Trivial and data isa DenseArray, the data array is simply reshaped into a vector and used as in case 1 so that the memory will still be shared. In other cases, new memory will be allocated.\n\nNote that in the case of N‚ÇÅ + N‚ÇÇ = 1, case 3 also amounts to data being a vector, whereas when N‚ÇÅ + N‚ÇÇ == 2, case 2 and case 3 both require data to be a matrix. Such ambiguous cases are resolved by checking the size of data in an attempt to support all possible cases.\n\nnote: Note\nThis constructor for case 2 and 3 only works for sectortype values for which conversion to a plain array is possible, and only in the case where the data actually respects the specified symmetry structure, up to a tolerance tol.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.zeros-Tuple{Type, TensorMapSpace}","page":"Tensors","title":"Base.zeros","text":"zeros([T=Float64,], codomain::ProductSpace{S,N‚ÇÅ}, domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T}\nzeros([T=Float64,], codomain ‚Üê domain)\n\nCreate a TensorMap with element type T, of all zeros with spaces specified by codomain and domain.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.ones-Tuple{Type, TensorMapSpace}","page":"Tensors","title":"Base.ones","text":"ones([T=Float64,], codomain::ProductSpace{S,N‚ÇÅ}, domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T}\nones([T=Float64,], codomain ‚Üê domain)\n\nCreate a TensorMap with element type T, of all ones with spaces specified by codomain and domain.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.rand-Tuple{Type, TensorMapSpace}","page":"Tensors","title":"Base.rand","text":"rand([rng=default_rng()], [TorA=Float64], codomain::ProductSpace{S,N‚ÇÅ},\n             domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T} -> t\nrand([rng=default_rng()], [TorA=Float64], codomain ‚Üê domain) -> t\n\nGenerate a tensor t with entries generated by rand. The type TorA can be used to control the element type and data type generated. For example, if TorA is a CuVector{ComplexF32} or ROCVector{Float64}, then the final output TensorMap will have that as its storage type.\n\nSee also Random.rand!.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.randn-Tuple{Type, TensorMapSpace}","page":"Tensors","title":"Base.randn","text":"randn([rng=default_rng()], [TorA=Float64], codomain::ProductSpace{S,N‚ÇÅ},\n             domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T} -> t\nrandn([rng=default_rng()], [TorA=Float64], codomain ‚Üê domain) -> t\n\nGenerate a tensor t with entries generated by randn. The type TorA can be used to control the element type and data type generated. For example, if TorA is a CuVector{ComplexF32} or ROCVector{Float64}, then the final output TensorMap will have that as its storage type.\n\nSee also Random.randn!.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Random.randexp-Tuple{Type, TensorMapSpace}","page":"Tensors","title":"Random.randexp","text":"randexp([rng=default_rng()], [TorA=Float64], codomain::ProductSpace{S,N‚ÇÅ},\n             domain::ProductSpace{S,N‚ÇÇ}) where {S,N‚ÇÅ,N‚ÇÇ,T} -> t\nrandexp([rng=default_rng()], [TorA=Float64], codomain ‚Üê domain) -> t\n\nGenerate a tensor t with entries generated by randexp. The type TorA can be used to control the element type and data type generated. For example, if TorA is a CuVector{ComplexF32} or ROCVector{Float64}, then the final output TensorMap will have that as its storage type.\n\nSee also Random.randexp!.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.similar-Tuple{AbstractTensorMap, Vararg{Any}}","page":"Tensors","title":"Base.similar","text":"similar(t::AbstractTensorMap, [AorT=storagetype(t)], [V=space(t)])\nsimilar(t::AbstractTensorMap, [AorT=storagetype(t)], codomain, domain)\n\nCreates an uninitialized mutable tensor with the given scalar or storagetype AorT and structure V or codomain ‚Üê domain, based on the source tensormap. The second and third arguments are both optional, defaulting to the given tensor's storagetype and space. The structure may be specified either as a single HomSpace argument or as codomain and domain.\n\nBy default, this will result in TensorMap{T}(undef, V) when custom objects do not specialize this method.\n\nSee also similar_diagonal.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.id","page":"Tensors","title":"TensorKit.id","text":"id([T::Type=Float64,] V::TensorSpace) -> TensorMap\nid!(t::AbstractTensorMap) -> AbstractTensorMap\n\nConstruct the identity endomorphism on space V, i.e. return a t::TensorMap with domain(t) == codomain(t) == V, where either scalartype(t) = T if T is a Number type or storagetype(t) = T if T is a DenseVector type.\n\nSee also one!.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.isomorphism","page":"Tensors","title":"TensorKit.isomorphism","text":"isomorphism([T::Type=Float64,] codomain::TensorSpace, domain::TensorSpace) -> TensorMap\nisomorphism([T::Type=Float64,] codomain ‚Üê domain) -> TensorMap\nisomorphism([T::Type=Float64,] domain ‚Üí codomain) -> TensorMap\nisomorphism!(t::AbstractTensorMap) -> AbstractTensorMap\n\nConstruct a specific isomorphism between the codomain and the domain, i.e. return a t::TensorMap where either scalartype(t) = T if T is a Number type or storagetype(t) = T if T is a DenseVector type. If the spaces are not isomorphic, an error will be thrown.\n\nnote: Note\nThere is no canonical choice for a specific isomorphism, but the current choice is such that isomorphism(cod, dom) == inv(isomorphism(dom, cod)).\n\nSee also unitary when InnerProductStyle(cod) === EuclideanInnerProduct().\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.unitary","page":"Tensors","title":"TensorKit.unitary","text":"unitary([T::Type=Float64,] codomain::TensorSpace, domain::TensorSpace) -> TensorMap\nunitary([T::Type=Float64,] codomain ‚Üê domain) -> TensorMap\nunitary([T::Type=Float64,] domain ‚Üí codomain) -> TensorMap\nunitary!(t::AbstractTensorMap) -> AbstractTensorMap\n\nConstruct a specific unitary morphism between the codomain and the domain, i.e. return a t::TensorMap where either scalartype(t) = T if T is a Number type or storagetype(t) = T if T is a DenseVector type. If the spaces are not isomorphic, or the spacetype does not have a Euclidean inner product, an error will be thrown.\n\nnote: Note\nThere is no canonical choice for a specific unitary, but the current choice is such that unitary(cod, dom) == inv(unitary(dom, cod)) = adjoint(unitary(dom, cod)).\n\nSee also isomorphism and isometry.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.isometry","page":"Tensors","title":"TensorKit.isometry","text":"isometry([T::Type=Float64,] codomain::TensorSpace, domain::TensorSpace) -> TensorMap\nisometry([T::Type=Float64,] codomain ‚Üê domain) -> TensorMap\nisometry([T::Type=Float64,] domain ‚Üí codomain) -> TensorMap\nisometry!(t::AbstractTensorMap) -> AbstractTensorMap\n\nConstruct a specific isometry between the codomain and the domain, i.e. return a t::TensorMap where either scalartype(t) = T if T is a Number type or storagetype(t) = T if T is a DenseVector type. The isometry t then satisfies t' * t = id(domain) and (t * t')^2 = t * t'. If the spaces do not allow for such an  isometric inclusion, an error will be thrown.\n\nSee also isomorphism and unitary.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#Base.eltype-Union{Tuple{Type{<:AbstractTensorMap{T}}}, Tuple{T}} where T","page":"Tensors","title":"Base.eltype","text":"eltype(::AbstractTensorMap) -> Type{T}\neltype(::Type{<:AbstractTensorMap}) -> Type{T}\n\nReturn the scalar or element type T of a tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.spacetype-Union{Tuple{Type{<:AbstractTensorMap{<:Any, S}}}, Tuple{S}} where S","page":"Tensors","title":"TensorKit.spacetype","text":"spacetype(a) -> Type{S <: IndexSpace}\nspacetype(::Type) -> Type{S <: IndexSpace}\n\nReturn the type of the elementary space S of object a (e.g. a tensor). Also works in type domain.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.sectortype-Union{Tuple{Type{TT}}, Tuple{TT}} where TT<:AbstractTensorMap","page":"Tensors","title":"TensorKit.sectortype","text":"sectortype(a) -> Type{<:Sector}\nsectortype(::Type) -> Type{<:Sector}\n\nReturn the type of sector over which object a (e.g. a representation space or a tensor) is defined. Also works in type domain.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.field-Union{Tuple{Type{TT}}, Tuple{TT}} where TT<:AbstractTensorMap","page":"Tensors","title":"TensorKit.field","text":"field(a) -> Type{ùîΩ <: Field}\nfield(::Type{T}) -> Type{ùîΩ <: Field}\n\nReturn the type of field over which object a (e.g. a vector space or a tensor) is defined. This also works in type domain.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.storagetype","page":"Tensors","title":"TensorKit.storagetype","text":"storagetype(t::AbstractTensorMap) -> Type{A<:AbstractVector}\nstoragetype(T::Type{<:AbstractTensorMap}) -> Type{A<:AbstractVector}\n\nReturn the type of vector that stores the data of a tensor. If this is not overloaded for a given tensor type, the default value of storagetype(scalartype(t)) is returned.\n\nSee also similarstoragetype.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.blocktype","page":"Tensors","title":"TensorKit.blocktype","text":"blocktype(t)\n\nReturn the type of the matrix blocks of a tensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.space-Tuple{AbstractTensorMap, Int64}","page":"Tensors","title":"TensorKit.space","text":"space(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}) -> HomSpace{S,N‚ÇÅ,N‚ÇÇ}\nspace(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, i::Int) -> S\n\nThe index information of a tensor, i.e. the HomSpace of its domain and codomain. If i is specified, return the i-th index space.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.domain","page":"Tensors","title":"TensorKit.domain","text":"domain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}) -> ProductSpace{S,N‚ÇÇ}\ndomain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, i::Int) -> S\n\nReturn the domain of a tensor, i.e. the product space of the input spaces. If i is specified, return the i-th input space. Implementations should provide domain(t).\n\nSee also codomain and space.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.codomain","page":"Tensors","title":"TensorKit.codomain","text":"codomain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}) -> ProductSpace{S,N‚ÇÅ}\ncodomain(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, i::Int) -> S\n\nReturn the codomain of a tensor, i.e. the product space of the output spaces. If i is specified, return the i-th output space. Implementations should provide codomain(t).\n\nSee also domain and space.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.numin","page":"Tensors","title":"TensorKit.numin","text":"numin(x) -> Int\nnumin(T::Type) -> Int\n\nReturn the length of the domain, i.e. the number of input spaces. By default, this is implemented in the type domain.\n\nSee also numout and numind.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.numout","page":"Tensors","title":"TensorKit.numout","text":"numout(x) -> Int\nnumout(T::Type) -> Int\n\nReturn the length of the codomain, i.e. the number of output spaces. By default, this is implemented in the type domain.\n\nSee also numin and numind.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.numind","page":"Tensors","title":"TensorKit.numind","text":"numind(x) -> Int\nnumind(T::Type) -> Int\norder(x) = numind(x)\n\nReturn the total number of input and output spaces, i.e. numin(x) + numout(x). Alternatively, the alias order can also be used.\n\nSee also numout and numin.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.codomainind","page":"Tensors","title":"TensorKit.codomainind","text":"codomainind(x) -> Tuple{Int}\n\nReturn all indices of the codomain.\n\nSee also domainind and allind.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.domainind","page":"Tensors","title":"TensorKit.domainind","text":"domainind(x) -> Tuple{Int}\n\nReturn all indices of the domain.\n\nSee also codomainind and allind.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.allind","page":"Tensors","title":"TensorKit.allind","text":"allind(x) -> Tuple{Int}\n\nReturn all indices, i.e. the indices of both domain and codomain.\n\nSee also codomainind and domainind.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.fusionblockstructure-Tuple{AbstractTensorMap}","page":"Tensors","title":"TensorKit.fusionblockstructure","text":"fusionblockstructure(t::AbstractTensorMap) -> TensorStructure\n\nReturn the necessary structure information to decompose a tensor in blocks labeled by coupled sectors and in subblocks labeled by a splitting-fusion tree couple.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKitSectors.dim-Tuple{AbstractTensorMap}","page":"Tensors","title":"TensorKitSectors.dim","text":"dim(t::AbstractTensorMap) -> Int\n\nThe total number of free parameters of a tensor, discounting the entries that are fixed by symmetry. This is also the dimension of the HomSpace on which the TensorMap is defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.blocksectors-Tuple{AbstractTensorMap}","page":"Tensors","title":"TensorKit.blocksectors","text":"blocksectors(t::AbstractTensorMap)\n\nReturn an iterator over all coupled sectors of a tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.hasblock-Tuple{AbstractTensorMap, Sector}","page":"Tensors","title":"TensorKit.hasblock","text":"hasblock(t::AbstractTensorMap, c::Sector) -> Bool\n\nVerify whether a tensor has a block corresponding to a coupled sector c.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.fusiontrees-Tuple{AbstractTensorMap}","page":"Tensors","title":"TensorKit.fusiontrees","text":"fusiontrees(t::AbstractTensorMap)\n\nReturn an iterator over all splitting - fusion tree pairs of a tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.block","page":"Tensors","title":"TensorKit.block","text":"block(t::AbstractTensorMap, c::Sector)\n\nReturn the matrix block of a tensor corresponding to a coupled sector c.\n\nSee also blocks, blocksectors, blockdim and hasblock.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.blocks","page":"Tensors","title":"TensorKit.blocks","text":"blocks(t::AbstractTensorMap)\n\nReturn an iterator over all blocks of a tensor, i.e. all coupled sectors and their corresponding matrix blocks.\n\nSee also block, blocksectors, blockdim and hasblock.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.subblock","page":"Tensors","title":"TensorKit.subblock","text":"subblock(t::AbstractTensorMap, (f‚ÇÅ, f‚ÇÇ)::Tuple{FusionTree,FusionTree})\nsubblock(t::AbstractTensorMap, sectors::Tuple{Vararg{Sector}})\n\nReturn a view into the data of t corresponding to the splitting - fusion tree pair (f‚ÇÅ, f‚ÇÇ). In particular, this is an AbstractArray{T} with T = scalartype(t), of size (dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(codomain(t), f‚ÇÇ.uncoupled)...).\n\nWhenever FusionStyle(sectortype(t)) isa UniqueFusion , it is also possible to provide only the external sectors, in which case the fusion tree pair will be constructed automatically.\n\nIn general, new tensor types should provide an implementation of this function for the fusion tree signature.\n\nSee also subblocks and fusiontrees.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.subblocks","page":"Tensors","title":"TensorKit.subblocks","text":"subblocks(t::AbstractTensorMap)\n\nReturn an iterator over all subblocks of a tensor, i.e. all fusiontrees and their corresponding tensor subblocks.\n\nSee also subblock, fusiontrees, and hassubblock.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#Base.getindex-Tuple{AbstractTensorMap, FusionTree, FusionTree}","page":"Tensors","title":"Base.getindex","text":"Base.getindex(t::AbstractTensorMap, sectors::Tuple{Vararg{Sector}})\nt[sectors]\nBase.getindex(t::AbstractTensorMap, f‚ÇÅ::FusionTree, f‚ÇÇ::FusionTree)\nt[f‚ÇÅ, f‚ÇÇ]\n\nReturn a view into the data of t corresponding to the splitting - fusion tree pair (f‚ÇÅ, f‚ÇÇ). In particular, this is an AbstractArray{T} with T = scalartype(t), of size (dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(codomain(t), f‚ÇÇ.uncoupled)...).\n\nWhenever FusionStyle(sectortype(t)) isa UniqueFusion , it is also possible to provide only the external sectors, in which case the fusion tree pair will be constructed automatically.\n\nwarning: Warning\nContrary to Julia's array types, the default behavior is to return a view into the tensor data. As a result, modifying the view will modify the data in the tensor.\n\nSee also subblock, subblocks and fusiontrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.setindex!-Tuple{AbstractTensorMap, Any, FusionTree, FusionTree}","page":"Tensors","title":"Base.setindex!","text":"Base.setindex!(t::AbstractTensorMap, v, sectors::Tuple{Vararg{Sector}})\nt[sectors] = v\nBase.setindex!(t::AbstractTensorMap, v, f‚ÇÅ::FusionTree, f‚ÇÇ::FusionTree)\nt[f‚ÇÅ, f‚ÇÇ] = v\n\nCopies v into the data slice of t corresponding to the splitting - fusion tree pair (f‚ÇÅ, f‚ÇÇ). By default, v can be any object that can be copied into the view associated with t[f‚ÇÅ, f‚ÇÇ].\n\nSee also subblock, subblocks and fusiontrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.getindex-Union{Tuple{I}, Tuple{AbstractTensorMap, Tuple{I, Vararg{I}}}} where I<:Sector","page":"Tensors","title":"Base.getindex","text":"Base.getindex(t::AbstractTensorMap, sectors::Tuple{Vararg{Sector}})\nt[sectors]\nBase.getindex(t::AbstractTensorMap, f‚ÇÅ::FusionTree, f‚ÇÇ::FusionTree)\nt[f‚ÇÅ, f‚ÇÇ]\n\nReturn a view into the data of t corresponding to the splitting - fusion tree pair (f‚ÇÅ, f‚ÇÇ). In particular, this is an AbstractArray{T} with T = scalartype(t), of size (dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(codomain(t), f‚ÇÇ.uncoupled)...).\n\nWhenever FusionStyle(sectortype(t)) isa UniqueFusion , it is also possible to provide only the external sectors, in which case the fusion tree pair will be constructed automatically.\n\nwarning: Warning\nContrary to Julia's array types, the default behavior is to return a view into the tensor data. As a result, modifying the view will modify the data in the tensor.\n\nSee also subblock, subblocks and fusiontrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.getindex-Tuple{AbstractTensorMap}","page":"Tensors","title":"Base.getindex","text":"Base.getindex(t::AbstractTensorMap)\nt[]\n\nReturn a view into the data of t as a StridedViews.StridedView of size dims(t).\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.getindex-Tuple{AbstractTensorMap, Vararg{Union{Colon, AbstractRange{<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}","page":"Tensors","title":"Base.getindex","text":"Base.getindex(t::AbstractTensorMap, indices::Vararg{Int})\nt[indices]\n\nReturn a view into the data slice of t corresponding to indices, by slicing the StridedViews.StridedView into the full data array.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.setindex!-Tuple{AbstractTensorMap, Any, Vararg{Union{Colon, AbstractRange{<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}","page":"Tensors","title":"Base.setindex!","text":"Base.setindex!(t::AbstractTensorMap, v, indices::Vararg{Int})\nt[indices] = v\n\nAssigns v to the data slice of t corresponding to indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Random.rand!","page":"Tensors","title":"Random.rand!","text":"rand!([rng=default_rng()], t::AbstractTensorMap) -> t\n\nFill the tensor t with entries generated by rand!.\n\nSee also Random.rand.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#Random.randn!","page":"Tensors","title":"Random.randn!","text":"randn!([rng=default_rng()], t::AbstractTensorMap) -> t\n\nFill the tensor t with entries generated by randn!.\n\nSee also Random.randn.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#Random.randexp!","page":"Tensors","title":"Random.randexp!","text":"randexp!([rng=default_rng()], t::AbstractTensorMap) -> t\n\nFill the tensor t with entries generated by randexp!.\n\nSee also Random.randexp.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.permute-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}","page":"Tensors","title":"TensorKit.permute","text":"permute(tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple; copy::Bool = false) -> tdst::TensorMap\n\nReturn tensor tdst obtained by permuting the indices of tsrc. The codomain and domain of tdst correspond to the indices in p‚ÇÅ and p‚ÇÇ of tsrc respectively.\n\nIf copy = false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nTo permute into an existing destination, see permute! and add_permute!\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.braid-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}, NTuple{N, Int64} where N}","page":"Tensors","title":"TensorKit.braid","text":"braid(tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple, levels::IndexTuple;\n      copy::Bool = false)\n    -> tdst::TensorMap\n\nReturn tensor tdst obtained by braiding the indices of tsrc. The codomain and domain of tdst correspond to the indices in p‚ÇÅ and p‚ÇÇ of tsrc respectively. Here, levels is a tuple of length numind(tsrc) that assigns a level or height to the indices of tsrc, which determines whether they will braid over or under any other index with which they have to change places.\n\nIf copy=false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nTo braid into an existing destination, see braid! and add_braid!\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.transpose-Tuple{AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}","page":"Tensors","title":"Base.transpose","text":"transpose(tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple;\n          copy::Bool=false)\n    -> tdst::TensorMap\n\nReturn tensor tdst obtained by transposing the indices of tsrc. The codomain and domain of tdst correspond to the indices in p‚ÇÅ and p‚ÇÇ of tsrc respectively. The new index positions should be attainable without any indices crossing each other, i.e., the permutation (p‚ÇÅ..., reverse(p‚ÇÇ)...) should constitute a cyclic permutation of (codomainind(tsrc)..., reverse(domainind(tsrc))...).\n\nIf copy=false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nTo permute into an existing destination, see permute! and add_permute!\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.repartition-Tuple{AbstractTensorMap, Int64, Int64}","page":"Tensors","title":"TensorKit.repartition","text":"repartition(\n    tsrc::AbstractTensorMap{T, S}, N‚ÇÅ::Int, N‚ÇÇ::Int; copy::Bool=false\n) where {T, S} -> tdst::AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}\n\nReturn tensor tdst obtained by repartitioning the indices of t. The codomain and domain of tdst correspond to the first N‚ÇÅ and last N‚ÇÇ spaces of t, respectively.\n\nIf copy=false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nTo repartition into an existing destination, see repartition!.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.flip-Tuple{AbstractTensorMap, Any}","page":"Tensors","title":"TensorKit.flip","text":"flip(t::AbstractTensorMap, I) -> t‚Ä≤::AbstractTensorMap\n\nReturn a new tensor that is isomorphic to t but where the arrows on the indices i that satisfy i ‚àà I are flipped, i.e. space(t‚Ä≤, i) = flip(space(t, i)).\n\nnote: Note\nThe isomorphism that flip applies to each of the indices i ‚àà I is such that flipping two indices that are afterwards contracted within an @tensor contraction will yield the same result as without flipping those indices first. However, flip is not involutory, i.e. flip(flip(t, I), I) != t in general. To obtain the original tensor, one can use the inv keyword, i.e. it holds that flip(flip(t, I), I; inv=true) == t.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKitSectors.twist-Tuple{AbstractTensorMap, Int64}","page":"Tensors","title":"TensorKitSectors.twist","text":"twist(tsrc::AbstractTensorMap, i::Int; inv::Bool = false, copy::Bool = false) -> tdst\ntwist(tsrc::AbstractTensorMap, inds; inv::Bool = false, copy::Bool = false) -> tdst\n\nApply a twist to the ith index of tsrc and return the result as a new tensor. If inv = true, use the inverse twist. If copy = false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nSee twist! for storing the result in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.insertleftunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i","page":"Tensors","title":"TensorKit.insertleftunit","text":"insertleftunit(tsrc::AbstractTensorMap, i=numind(t) + 1;\n               conj=false, dual=false, copy=false) -> tdst\n\nInsert a trivial vector space, isomorphic to the underlying field, at position i, which can be specified as an Int or as Val(i) for improved type stability. More specifically, adds a left monoidal unit or its dual.\n\nIf copy=false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nSee also insertrightunit, removeunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.insertrightunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i","page":"Tensors","title":"TensorKit.insertrightunit","text":"insertrightunit(tsrc::AbstractTensorMap, i=numind(t);\n                conj=false, dual=false, copy=false) -> tdst\n\nInsert a trivial vector space, isomorphic to the underlying field, after position i, which can be specified as an Int or as Val(i) for improved type stability. More specifically, adds a right monoidal unit or its dual.\n\nIf copy=false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nSee also insertleftunit, removeunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.removeunit-Union{Tuple{i}, Tuple{AbstractTensorMap, Val{i}}} where i","page":"Tensors","title":"TensorKit.removeunit","text":"removeunit(tsrc::AbstractTensorMap, i; copy=false) -> tdst\n\nThis removes a trivial tensor product factor at position 1 ‚â§ i ‚â§ N, where i can be specified as an Int or as Val(i) for improved type stability. For this to work, that factor has to be isomorphic to the field of scalars.\n\nIf copy=false, tdst might share data with tsrc whenever possible. Otherwise, a copy is always made.\n\nThis operation undoes the work of insertleftunit  and insertrightunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}","page":"Tensors","title":"Base.permute!","text":"permute!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple)\n    -> tdst\n\nWrite into tdst the result of permuting the indices of tsrc. The codomain and domain of tdst correspond to the indices in p‚ÇÅ and p‚ÇÇ of tsrc respectively.\n\nSee permute for creating a new tensor and add_permute! for a more general version.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.braid!","page":"Tensors","title":"TensorKit.braid!","text":"braid!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap,\n       (p‚ÇÅ, p‚ÇÇ)::Index2Tuple, levels::Tuple)\n    -> tdst\n\nWrite into tdst the result of braiding the indices of tsrc. The codomain and domain of tdst correspond to the indices in p‚ÇÅ and p‚ÇÇ of tsrc respectively. Here, levels is a tuple of length numind(tsrc) that assigns a level or height to the indices of tsrc, which determines whether they will braid over or under any other index with which they have to change places.\n\nSee braid for creating a new tensor and add_braid! for a more general version.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#LinearAlgebra.transpose!","page":"Tensors","title":"LinearAlgebra.transpose!","text":"transpose!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap,\n           (p‚ÇÅ, p‚ÇÇ)::Index2Tuple)\n    -> tdst\n\nWrite into tdst the result of transposing the indices of tsrc. The codomain and domain of tdst correspond to the indices in p‚ÇÅ and p‚ÇÇ of tsrc respectively. The new index positions should be attainable without any indices crossing each other, i.e., the permutation (p‚ÇÅ..., reverse(p‚ÇÇ)...) should constitute a cyclic permutation of (codomainind(tsrc)..., reverse(domainind(tsrc))...).\n\nSee transpose for creating a new tensor and add_transpose! for a more general version.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.repartition!","page":"Tensors","title":"TensorKit.repartition!","text":"repartition!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap) -> tdst\n\nWrite into tdst the result of repartitioning the indices of tsrc. This is just a special case of a transposition that only changes the number of in- and outgoing indices.\n\nSee repartition for creating a new tensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.twist!","page":"Tensors","title":"TensorKit.twist!","text":"twist!(t::AbstractTensorMap, i::Int; inv::Bool=false) -> t\ntwist!(t::AbstractTensorMap, inds; inv::Bool=false) -> t\n\nApply a twist to the ith index of t, or all indices in inds, storing the result in t. If inv=true, use the inverse twist.\n\nSee twist for creating a new tensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.add_permute!","page":"Tensors","title":"TensorKit.add_permute!","text":"add_permute!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,\n             Œ±::Number, Œ≤::Number, backend::AbstractBackend...)\n\nReturn the updated tdst, which is the result of adding Œ± * tsrc to tdst after permuting  the indices of tsrc according to (p‚ÇÅ, p‚ÇÇ).\n\nSee also permute, permute!, add_braid!, add_transpose!.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.add_braid!","page":"Tensors","title":"TensorKit.add_braid!","text":"add_braid!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,\n           levels::IndexTuple, Œ±::Number, Œ≤::Number, backend::AbstractBackend...)\n\nReturn the updated tdst, which is the result of adding Œ± * tsrc to tdst after braiding the indices of tsrc according to (p‚ÇÅ, p‚ÇÇ) and levels.\n\nSee also braid, braid!, add_permute!, add_transpose!.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.add_transpose!","page":"Tensors","title":"TensorKit.add_transpose!","text":"add_transpose!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,\n               Œ±::Number, Œ≤::Number, backend::AbstractBackend...)\n\nReturn the updated tdst, which is the result of adding Œ± * tsrc to tdst after transposing the indices of tsrc according to (p‚ÇÅ, p‚ÇÇ).\n\nSee also transpose, transpose!, add_permute!, add_braid!.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.compose-Tuple{AbstractTensorMap, AbstractTensorMap}","page":"Tensors","title":"TensorKit.compose","text":"compose(t1::AbstractTensorMap, t2::AbstractTensorMap) -> AbstractTensorMap\n\nReturn the AbstractTensorMap that implements the composition of the two tensor maps t1 and t2.\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.trace_permute!","page":"Tensors","title":"TensorKit.trace_permute!","text":"trace_permute!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap,\n               (p‚ÇÅ, p‚ÇÇ)::Index2Tuple, (q‚ÇÅ, q‚ÇÇ)::Index2Tuple,\n               Œ±::Number, Œ≤::Number, backend=TO.DefaultBackend())\n\nReturn the updated tdst, which is the result of adding Œ± * tsrc to tdst after permuting the indices of tsrc according to (p‚ÇÅ, p‚ÇÇ) and furthermore tracing the indices in q‚ÇÅ and q‚ÇÇ.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.contract!","page":"Tensors","title":"TensorKit.contract!","text":"contract!(C::AbstractTensorMap,\n          A::AbstractTensorMap, (oindA, cindA)::Index2Tuple,\n          B::AbstractTensorMap, (cindB, oindB)::Index2Tuple,\n          (p‚ÇÅ, p‚ÇÇ)::Index2Tuple,\n          Œ±::Number, Œ≤::Number,\n          backend, allocator)\n\nReturn the updated C, which is the result of adding Œ± * A * B to C after permuting the indices of A and B according to (oindA, cindA) and (cindB, oindB) respectively.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKitSectors.:‚äó-Tuple{AbstractTensorMap, AbstractTensorMap}","page":"Tensors","title":"TensorKitSectors.:‚äó","text":"‚äó(t1::AbstractTensorMap, t2::AbstractTensorMap, ...) -> TensorMap\notimes(t1::AbstractTensorMap, t2::AbstractTensorMap, ...) -> TensorMap\n\nCompute the tensor product between two AbstractTensorMap instances, which results in a new TensorMap instance whose codomain is codomain(t1) ‚äó codomain(t2) and whose domain is domain(t1) ‚äó domain(t2).\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#TensorKit.Factorizations.truncspace","page":"Tensors","title":"TensorKit.Factorizations.truncspace","text":"truncspace(space::ElementarySpace; by=abs, rev::Bool=true)\n\nTruncation strategy to keep the first values for each sector when sorted according to by and rev, such that the resulting vector space is no greater than V.\n\n\n\n\n\n","category":"function"},{"location":"Changelog/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"Changelog/#Guidelines-for-updating-this-changelog","page":"Changelog","title":"Guidelines for updating this changelog","text":"When making changes to this project, please update the \"Unreleased\" section with your changes under the appropriate category:\n\nAdded for new features.\nChanged for changes in existing functionality.\nDeprecated for soon-to-be removed features.\nRemoved for now removed features.\nFixed for any bug fixes.\nPerformance for performance improvements.\n\nWhen releasing a new version, move the \"Unreleased\" changes to a new version section with the release date.","category":"section"},{"location":"Changelog/#[Unreleased](https://github.com/QuantumKitHub/TensorKit.jl/compare/v0.16.2...HEAD)","page":"Changelog","title":"Unreleased","text":"","category":"section"},{"location":"Changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"Changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"Changelog/#Deprecated","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"Changelog/#Removed","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"Changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"Changelog/#[0.16.2](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.16.2)-2026-02-10","page":"Changelog","title":"0.16.2 - 2026-02-10","text":"","category":"section"},{"location":"Changelog/#Added-2","page":"Changelog","title":"Added","text":"A more robust promotion system for storagetypes to better handle working with unions and other abstract tensor map types (#370).","category":"section"},{"location":"Changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"Fix findtruncated with truncspace (#369)\nFix truncrank when kept rank is larger than input (#368)\nAdded missing similar definition for SectorVector (#367)\nSmall fixes for CUDA support (#366)","category":"section"},{"location":"Changelog/#[0.16.1](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.16.1)-2026-02-05","page":"Changelog","title":"0.16.1 - 2026-02-05","text":"","category":"section"},{"location":"Changelog/#Added-3","page":"Changelog","title":"Added","text":"Extended support for selecting storage types in the TensorMap constructors (#327)\nsimilar_diagonal to handle storage types when constructing diagonals (#330)\nSupport for CUDA.jl (#336,#325)\nSupport for Adapt.jl (#344)\nPreliminary support for Mooncake (#352)\nExport TimeReversed symbol (#337)","category":"section"},{"location":"Changelog/#Fixed-3","page":"Changelog","title":"Fixed","text":"Issue with using relative tolerances in truncation schemes (#314)\nUsing scalartype instead of eltype in BLAS contraction (#326)\nDivide by zero error in show for empty tensors (#329)\nsvd_vals(::DiagonalTensorMap) correctly outputs SectorVector and implementation fix. (#333)\nFix handling of real tensors with complex scalartype (#360)\nSorted diagonal eigenvalues to ensure consistent ordering (#350)\nAdding tensors of different types now correctly promotes (#364)","category":"section"},{"location":"Changelog/#Changed-2","page":"Changelog","title":"Changed","text":"convert(TensorMap, t) now retains storagetype when converting (#357)\ntranspose specialization for DiagonalTensorMap for improved correctness/performance (#335)\nUniformized CartesianSpace and ComplexSpace constructors (#334)","category":"section"},{"location":"Changelog/#Performance","page":"Changelog","title":"Performance","text":"GPU-friendly truncation implementations (#349)\nnorm performance optimizations (#351)\nTensorOperations ChainRules performance improvements (#343)\nType-stability and small test fixes (various commits)","category":"section"},{"location":"Changelog/#[0.16.0](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.16.0)-2025-12-08","page":"Changelog","title":"0.16.0 - 2025-12-08","text":"","category":"section"},{"location":"Changelog/#Added-4","page":"Changelog","title":"Added","text":"rrule for transpose operation (#319)\nNew functions for multifusion support: unitspace, zerospace, leftunitspace, rightunitspace, isunitspace (#291)\nSupport for projections and orthogonal complements (#312)","category":"section"},{"location":"Changelog/#Changed-3","page":"Changelog","title":"Changed","text":"Improvements to the default printing of tensors, where only a (possibly compressed) representation of the (possibly truncated) list of diagonal blocks is printed. Use blocks(t) and subblocks(t) for a full inspection of the tensor data (#304, #322))\nUpdated left_orth, right_orth, left_null and right_null interfaces for MatrixAlgebraKit v0.6 (#312)\nUpdated ishermitian and isisometric implementations (#312)\nSector functions now by default use unit instead of one, isunit instead of isone, and dual instead of conj (#291)\nReworked TensorOperations implementation to use backend and allocator system (#311)\nMajor documentation update/overhaul (#289)\nAdded symmetric tensor tutorial as appendix (#316)\nImproved error messages throughout codebase (#309)\neigvals and svdvals now output SectorVector objects, which do behave as AbstractVector but also have the option of iterating the blocks through Base.pairs. (#324","category":"section"},{"location":"Changelog/#Deprecated-2","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"Changelog/#Removed-2","page":"Changelog","title":"Removed","text":"All deprecations from v0.15: old factorization function names (leftorth, rightorth, tsvd, eig, eigh)\nOld truncation strategy names (truncdim, truncbelow)\nOld factorization struct types (OrthogonalFactorization)\nOld constructor syntaxes and deprecated rand* function names","category":"section"},{"location":"Changelog/#Fixed-4","page":"Changelog","title":"Fixed","text":"Avoid unnecessary copy in twist for tensors with bosonic braiding (#305)\nSmall fixes and typos (#295)\neig_vals, svd_vals, etc now all output SectorVector objects instead of DiagonalTensorMaps, in line with how MatrixAlgebraKit returns Vectors instead of Diagonals (#324","category":"section"},{"location":"Changelog/#[0.15.3](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.15.3)-2025-10-30","page":"Changelog","title":"0.15.3 - 2025-10-30","text":"","category":"section"},{"location":"Changelog/#Fixed-5","page":"Changelog","title":"Fixed","text":"Fixed typo in show(::GradedSpace) (#308)\nUpdated printing of ProductSpace{<:Any,0}\nAdded tests for show methods","category":"section"},{"location":"Changelog/#[0.15.2](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.15.2)-2025-10-28","page":"Changelog","title":"0.15.2 - 2025-10-28","text":"","category":"section"},{"location":"Changelog/#Added-5","page":"Changelog","title":"Added","text":"subblocks iterator for easier inspection of tensor data (#304)","category":"section"},{"location":"Changelog/#Changed-4","page":"Changelog","title":"Changed","text":"Tensors no longer print their data by default, only their spaces. Use blocks(t) or subblocks(t) to inspect data (#304)\nUpdated compatibility to TensorKitSectors v0.3 (#290)\nRefactored test suite and split into groups (#298)","category":"section"},{"location":"Changelog/#Fixed-6","page":"Changelog","title":"Fixed","text":"Fixed TruncationIntersection implementation and test (#300)\nAvoided unnecessary allocations in rrules for contractions and tensor products (#306)","category":"section"},{"location":"Changelog/#[0.15.1](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.15.1)-2025-10-09","page":"Changelog","title":"0.15.1 - 2025-10-09","text":"","category":"section"},{"location":"Changelog/#Fixed-7","page":"Changelog","title":"Fixed","text":"Small fixes and typo corrections (#295)","category":"section"},{"location":"Changelog/#[0.15.0](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.15.0)-2025-10-03","page":"Changelog","title":"0.15.0 - 2025-10-03","text":"","category":"section"},{"location":"Changelog/#Added-6","page":"Changelog","title":"Added","text":"MatrixAlgebraKit as new backend for tensor factorizations (#230)\nforeachblock(f, t::AbstractTensorMap...) - uniform interface to iterate through tensor blocks\neig_trunc and eigh_trunc - truncated eigenvalue decompositions\nominus (and unicode ‚äñ) - compute orthogonal complement of a space\nBackend selection for factorizations - swap algorithms or implementations","category":"section"},{"location":"Changelog/#Changed-5","page":"Changelog","title":"Changed","text":"left_orth and right_orth now always output tensors with a single connecting space\nleft_orth and right_orth now always have connecting space with isdual=false\nCode formatter is now Runic.jl","category":"section"},{"location":"Changelog/#Deprecated-3","page":"Changelog","title":"Deprecated","text":"Factorization functions leftorth, rightorth, tsvd, eig, eigh in favor of MatrixAlgebraKit variants (left_orth, right_orth, svd_compact, eig_full, eigh_full)\nTruncation strategies: truncdim (use truncrank) and truncbelow (use trunctol)\nOrthogonalFactorization structs (constructors deprecated to return equivalent MatrixAlgebraKit algorithm structs)","category":"section"},{"location":"Changelog/#Removed-3","page":"Changelog","title":"Removed","text":"Direct permute-and-factorize operations (incompatible with permute vs braid distinction)\nPolar decomposition behavior for left_orth/right_orth (use left_polar/right_polar instead for isposdef R factors)","category":"section"},{"location":"Changelog/#[0.14.0](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.14.0)-2024-12-19","page":"Changelog","title":"0.14.0 - 2024-12-19","text":"","category":"section"},{"location":"Changelog/#Added-7","page":"Changelog","title":"Added","text":"DiagonalTensorMap type for representing tensor maps with diagonal blocks\nreduceddim(V) function that sums up degeneracy dimensions for each sector\nNew index manipulation functions:\nflip(t, i)\ninsertleftunit(t, i)\ninsertrightunit(t, i)\nremoveunit(t, i)","category":"section"},{"location":"Changelog/#Changed-6","page":"Changelog","title":"Changed","text":"Singular values and eigenvalues now explicitly represented as DiagonalTensorMap instances\nSVD truncation now guarantees smaller singular values are removed first, irrespective of sector quantum dimension","category":"section"},{"location":"Changelog/#[0.13.0](https://github.com/QuantumKitHub/TensorKit.jl/releases/tag/v0.13.0)-2024-11-24","page":"Changelog","title":"0.13.0 - 2024-11-24","text":"","category":"section"},{"location":"Changelog/#Added-8","page":"Changelog","title":"Added","text":"Refactored TensorMap constructors to align with Julia Array constructors\nConvenience constructors: ones, zeros, rand, randn for tensors\nTensorOperations v5 support","category":"section"},{"location":"Changelog/#Changed-7","page":"Changelog","title":"Changed","text":"Scalar type as parameter to AbstractTensorMap type: AbstractTensorMap{E, S, N‚ÇÅ, N‚ÇÇ}\nDefault way to create uninitialized tensors is now TensorMap{E}(undef, codomain ‚Üê domain)\nBehavior of copy for BraidingTensor to properly instantiate a TensorMap\nTensorKitSectors promoted to separate package\nTensorMap data structure now consists of single vector with blocks as views\nFusionTree vertices now only use Int labels for GenericFusion sectors","category":"section"},{"location":"man/symmetries/#s_symmetries","page":"Symmetries","title":"Symmetries","text":"","category":"section"},{"location":"man/symmetries/#Symmetries-and-symmetric-tensors","page":"Symmetries","title":"Symmetries and symmetric tensors","text":"When a physical system exhibits certain symmetries, it can often be described using tensors that transform covariantly with respect to the corresponding symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, and thus assume that the corresponding vector spaces also have a natural Euclidean inner product. In particular, the Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.\n\nThe corresponding vector spaces will be canonically represented as V = _a ‚ÑÇ^n_a  R_a, where a labels the different irreps, n_a is the number of times irrep a appears and R_a is the vector space associated with irrep a. Irreps are also known as spin sectors (in the case of mathsfSU_2) or charge sectors (in the case of mathsfU_1), and we henceforth refer to a as a sector. The number of times n_a that sector a appears will be referred to as the degeneracy of sector a in the space V. In fact, the approach taken by TensorKit.jl goes beyond the case of irreps of groups, and, using the language from the Appendix on categories, sectors correspond to (equivalence classes of) simple objects in a unitary fusion or multifusion category, whereas the \"representation spaces\" V correspond to general (semisimple) objects in such a category. Nonetheless, many aspects of the construction of symmetric tensors can already be appreciated by considering the representation theory of a non-abelian group such as mathsfSU_2 or mathsfSU_3 as example. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space V is completely specified by the values of n_a.\n\nWhen considering a tensor product of such representation spaces, they can again be decomposed into a direct sum of \"coupled\" sectors and associated degeneracy spaces. However, a non-trivial basis transformation is required to go from the tensor product basis to the basis of coupled sectors. The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric (technically: equivariant) tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. Hence, to exploit this block diagonal form, it is essential that we know the basis transformation from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors. The transformation from the uncoupled sectors in the domain (or codomain) of the tensor map to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group's Clebsch‚ÄìGordan (CG) coefficients. However, it turns out that we do not need to know or instantiate the actual CG coefficients that make up the fusion and splitting trees. Instead, we only need to know how the splitting and fusion trees transform under transformations such as interchanging the order of the incoming sectors or interchanging incoming and outgoing sectors. This information is known as the topological data of the group. It consists out of the fusion rules and the associativity relations encoded by the F-symbols, which are also known as recoupling coefficients or 6j-symbols (more accurately, the F-symbol is actually Racah's W-coefficients in the case of mathsfSU_2).\n\nIn the next three sections of the manual, we describe how the above concepts are implemented in TensorKit.jl in greater detail. Firstly, we describe how sectors and their associated topological data are encoded using a specialized interface and type hierarchy. The second section describes how to build spaces V composed of a direct sum of different sectors of the same type, and which operations are supported on those spaces. In the third section, we explain the details of constructing and manipulating fusion trees. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists.\n\nBut first, on the remainder of this page, we provide a concise theoretical summary of the required data of the representation theory of a group. We refer to the appendix on categories, and in particular the subsection on topological data of a unitary fusion category, for more details.\n\nnote: Note\nThe infrastructure for defining sectors is actually implemented in a standalone package, TensorKitSectors.jl, that is imported and reexported by TensorKit.jl.\n\nnote: Note\nOn this and the next page of the manual, we assume some familiarity with the representation theory of non-abelian groups, and the structure of a symmetric tensor. For a more pedagogical introduction based on physical examples, we recommend reading the first appendix, which provides a tutorial-style introduction on the construction of symmetric tensors.","category":"section"},{"location":"man/symmetries/#ss_representationtheory","page":"Symmetries","title":"Representation theory and unitary fusion categories","text":"Let the different irreps or sectors be labeled as a, b, c, ‚Ä¶ First and foremost, we need to specify the fusion rules a  b =  N^ab_c c with N^ab_c some non-negative integers. The meaning of the fusion rules is that the space of covariant maps R_a  R_b  R_c (or vice versa R_c  R_a  R_b) has dimension N^ab_c. In particular, there should always exists a unique trivial sector u (called the identity object I or 1 in the language of categories) such that a  u = a = u  a for every other sector a. Furthermore, with respect to every sector a there should exist a unique sector bara such that N^abara_u = 1, whereas for all b neq bara, N^ab_u = 0. For irreps of groups, bara corresponds to the complex conjugate of the representation a, or some representation isomorphic to it. For example, for the representations of mathsfSU_2, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. a = bara), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are however not equal but related by a similarity transform).\n\nIn particular, we now assume the existence of a basis for the N^ab_c-dimensional space of covariant maps R_c  R_a  R_b, which consists of unitary tensor maps X^ab_cŒº  R_c  R_a  R_b with Œº = 1  N^ab_c such that\n\nX^ab_cŒº)^ X^ab_cŒΩ = Œ¥_ŒºŒΩ mathrmid_R_c\n\nand\n\nsum_c sum_Œº = 1^N^ab_c X^ab_cŒº (X^ab_cŒº)^dagger = mathrmid_R_a  R_b\n\nThe tensors X^ab_cŒº are the splitting tensors, and because we restrict to unitary representations (or unitary categories), the corresponding fusion tensors are obtained by hermitian conjugation. Different choices of orthonormal bases would be related by a unitary basis transform within the space, i.e. acting on the multiplicity label Œº = 1  N^ab_c. For mathsfSU_2, where N^ab_c is zero or one and the multiplicity labels are absent, this freedom reduces to a phase factor. In a standard convention, the entries of X^ab_cŒº are precisely given by the CG coefficients. However, the point is that we do not need to know the tensors X^ab_cŒº explicitly, but only the topological data of (the representation category of) the group, which describes the following transformation:\n\nF-move or recoupling: the transformation from (a  b)  c to a  (b  c):\n\n(X^ab_eŒº  mathrmid_c)  X^ec_dŒΩ = _fŒ∫Œª F^abc_d_eŒºŒΩ^fŒ∫Œª (mathrmid_a  X^bc_fŒ∫)  X^af_dŒª\n\nBraiding or permuting: the transformation from a  b to b  a as defined by œÑ_a b R_a  R_b  R_b  R_a:\n\nœÑ_R_aR_b  X^ab_cŒº = _ŒΩ R^ab_c^ŒΩ_Œº X^ba_cŒΩ\n\nThe dimensions of the spaces R_a on which representation a acts are denoted as d_a and referred to as quantum dimensions. In particular d_u = 1 and d_a = d_bara. This information is also encoded in the F-symbol as d_a =  F^a bara a_a^u_u ^-1. Note that there are no multiplicity labels in that particular F-symbol as N^abara_u = 1.\n\nThere is a graphical representation associated with the fusion tensors and their manipulations, which we summarize here:\n\n<img src=\"../img/tree-summary.svg\" alt=\"summary\" class=\"color-invertible\"/>\n\nWe refer to the appendix on category theory, and in particular the section on topological data of a unitary fusion category for further details.\n\nFinally, for the implementation, it will be useful to distinguish between a number of different possibilities regarding the fusion rules. If, for every a and b, there is a unique c such that a  b = c (i.e. N^ab_c = 1 and N^ab_c = 0 for all other c), the sector type is said to have unique fusion. The representations of a group have this property if and only if the group multiplication law is commutative, i.e. if the group is abelian. In that case, all spaces R_a associated with the representation are one-dimensional and thus trivial. In the case of representations of non-abelian groups, or in the more general categorical case, there will always be at least one pair of sectors a and b (not necessarily distinct) for which the fusion product a  b contains more than one sector c with non-zero N^ab_c. In those cases, we find it useful to further distinguish between sector types for which N^ab_c only takes the values zero or one, such that no multiplicity labels (the Greek letters Œº, ... are needed), e.g. the representations of mathsfSU_2, and those where some N^ab_c are larger than one, e.g. the representations of mathsfSU_3.","category":"section"},{"location":"man/tensors/#s_tensors","page":"Constructing tensors and the TensorMap type","title":"Constructing tensors and the TensorMap type","text":"This last page explains how to create and manipulate tensors in TensorKit.jl. As this is probably the most important part of the manual, we will also focus more strongly on the usage and interface, and less so on the underlying implementation. The only aspect of the implementation that we will address is the storage of the tensor data, as this is important to know how to create and initialize a tensor, but will in fact also shed light on how some of the methods work.\n\nAs mentioned, all tensors in TensorKit.jl are interpreted as linear maps (morphisms) from a domain (a ProductSpace{S, N‚ÇÇ}) to a codomain (another ProductSpace{S, N‚ÇÅ}), with the same S <: ElementarySpace that labels the type of spaces associated with the individual tensor indices. The overall type for all such tensor maps is AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}. Note that we place information about the codomain before that of the domain. Indeed, we have already encountered the constructor for the concrete parametric type TensorMap in the form TensorMap(..., codomain, domain). This convention is opposite to the mathematical notation, e.g. mathrmHom(W V) or f  W  V, but originates from the fact that a normal matrix is also denoted as having size m √ó n or is constructed in Julia as Array(..., (m, n)), where the first integer m refers to the codomain being m- dimensional, and the seond integer n to the domain being n-dimensional. This also explains why we have consistently used the symbol W for spaces in the domain and V for spaces in the codomain. A tensor map t  (W_1    W_N_2)  (V_1    V_N_1) will be created in Julia as TensorMap(..., V1 ‚äó ... ‚äó VN‚ÇÅ, W1 ‚äó ... ‚äó WN‚ÇÇ).\n\nFurthermore, the abstract type AbstractTensor{T, S, N} is just a synonym for AbstractTensorMap{T, S, N, 0}, i.e. for tensor maps with an empty domain, which is equivalent to the unit of the monoidal category, or thus, the field of scalars ùïú.\n\nCurrently, AbstractTensorMap has three subtypes. TensorMap provides the actual implementation, where the data of the tensor is stored in a DenseArray (more specifically a DenseMatrix as will be explained below). AdjointTensorMap is a simple wrapper type to denote the adjoint of an existing TensorMap object. DiagonalTensorMap provides an efficient representations of diagonal tensor maps. In the future, additional types could be defined, to deal with sparse data, static data, etc...","category":"section"},{"location":"man/tensors/#ss_tensor_storage","page":"Constructing tensors and the TensorMap type","title":"Storage of tensor data","text":"Before discussion how to construct and initalize a TensorMap, let us discuss what is meant by 'tensor data' and how it can efficiently and compactly be stored. Let us first discuss the case sectortype(S) == Trivial sector, i.e. the case of no symmetries. In that case the data of a tensor t = TensorMap(..., V1 ‚äó ... ‚äó VN‚ÇÅ, W‚ÇÅ ‚äó ... ‚äó WN‚ÇÇ) can just be represented as a multidimensional array of size\n\n(dim(V1), dim(V2), ‚Ä¶, dim(VN‚ÇÅ), dim(W1), ‚Ä¶, dim(WN‚ÇÇ))\n\nwhich can also be reshaped into matrix of size\n\n(dim(V1) * dim(V2) * ‚Ä¶ * dim(VN‚ÇÅ), dim(W1) * dim(W2) * ‚Ä¶ * dim(WN‚ÇÇ))\n\nand is really the matrix representation of the linear map that the tensor represents. In particular, given a second tensor t2 whose domain matches with the codomain of t, function composition amounts to multiplication of their corresponding data matrices. Similarly, tensor factorizations such as the singular value decomposition, which we discuss below, can act directly on this matrix representation.\n\nnote: Note\nOne might wonder if it would not have been more natural to represent the tensor data as (dim(V1), dim(V2), ‚Ä¶, dim(VN‚ÇÅ), dim(WN‚ÇÇ), ‚Ä¶, dim(W1)) given how employing the duality naturally reverses the tensor product, as encountered with the interface of repartition for fusion trees. However, such a representation, when plainly reshaped to a matrix, would not have the above properties and would thus not constitute the matrix representation of the tensor in a compatible basis.\n\nNow consider the case where sectortype(S) == I for some I which has FusionStyle(I) == UniqueFusion(), i.e. the representations of an Abelian group, e.g. I == Irrep[‚Ñ§‚ÇÇ] or I == Irrep[U‚ÇÅ]. In this case, the tensor data is associated with sectors (a1, a2, ‚Ä¶, aN‚ÇÅ) ‚àà sectors(V1 ‚äó V2 ‚äó ‚Ä¶ ‚äó VN‚ÇÅ) and (b1, ‚Ä¶, bN‚ÇÇ) ‚àà sectors(W1 ‚äó ‚Ä¶ ‚äó WN‚ÇÇ) such that they fuse to a same common charge, i.e.  (c = first(‚äó(a1, ‚Ä¶, aN‚ÇÅ))) == first(‚äó(b1, ‚Ä¶, bN‚ÇÇ)). The data associated with this takes the form of a multidimensional array with size (dim(V1, a1), ‚Ä¶, dim(VN‚ÇÅ, aN‚ÇÅ), dim(W1, b1), ‚Ä¶, dim(WN‚ÇÇ, bN‚ÇÇ)), or equivalently, a matrix of with row size dim(V1, a1) * ‚Ä¶ * dim(VN‚ÇÅ, aN‚ÇÅ) == dim(codomain, (a1, ‚Ä¶, aN‚ÇÅ)) and column size dim(W1, b1) * ‚Ä¶ * dim(WN‚ÇÇ, aN‚ÇÇ) == dim(domain, (b1, ‚Ä¶, bN‚ÇÇ)).\n\nHowever, there are multiple combinations of (a1, ‚Ä¶, aN‚ÇÅ) giving rise to the same c, and so there is data associated with all of these, as well as all possible combinations of (b1, ‚Ä¶, bN‚ÇÇ). Stacking all matrices for different (a1, ‚Ä¶) and a fixed value of (b1, ‚Ä¶) underneath each other, and for fixed value of (a1, ‚Ä¶) and different values of (b1, ‚Ä¶) next to each other, gives rise to a larger block matrix of all data associated with the central sector c. The size of this matrix is exactly (blockdim(codomain, c), blockdim(domain, c)) and these matrices are exactly the diagonal blocks whose existence is guaranteed by Schur's lemma, and which are labeled by the coupled sector c. Indeed, if we would represent the tensor map t as a matrix without explicitly using the symmetries, we could reorder the rows and columns to group data corresponding to sectors that fuse to the same c, and the resulting block diagonal representation would emerge. This basis transform is thus a permutation, which is a unitary operation, that will cancel or go through trivially for linear algebra operations such as composing tensor maps (matrix multiplication) or tensor factorizations such as a singular value decomposition. For such linear algebra operations, we can thus directly act on these large matrices, which correspond to the diagonal blocks that emerge after a basis transform, provided that the partition of the tensor indices in domain and codomain of the tensor are in line with our needs. For example, composing two tensor maps amounts to multiplying the matrices corresponding to the same c (provided that its subblocks labeled by the different combinations of sectors are ordered in the same way, which we guarantee by associating a canonical order with sectors). Henceforth, we refer to the blocks of a tensor map as those diagonal blocks, the existence of which is provided by Schur's lemma and which are labeled by the coupled sectors c. We directly concatenate these blocks as consecutive entries in a single larger DenseVector, together with metadata to retrieve a block by using the corresponding coupled sector c as key. For a given tensor t, we can access a specific block as block(t, c), whereas blocks(t) yields an iterator over pairs c => block(t, c).\n\nThe subblocks corresponding to a particular combination of sectors then correspond to a particular view for some range of the rows and some range of the colums, i.e. view(block(t, c), m‚ÇÅ:m‚ÇÇ, n‚ÇÅ:n‚ÇÇ) where the ranges m‚ÇÅ:m‚ÇÇ associated with (a1, ‚Ä¶, aN‚ÇÅ) and n‚ÇÅ:n‚ÇÇ associated with (b‚ÇÅ, ‚Ä¶, bN‚ÇÇ) are stored within the fields of the instance t of type TensorMap. This view can then lazily be reshaped to a multidimensional array, for which we rely on the package Strided.jl. Indeed, the data in this view is not contiguous, because the stride between the different columns is larger than the length of the columns. Nonetheless, this does not pose a problem and even as multidimensional array there is still a definite stride associated with each dimension.\n\nWhen FusionStyle(I) isa MultipleFusion, things become slightly more complicated. Not only do (a1, ‚Ä¶, aN‚ÇÅ) give rise to different coupled sectors c, there can be multiply ways in which they fuse to c. These different possibilities are enumerated by the iterator fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c) and fusiontrees((b1, ‚Ä¶, bN‚ÇÇ), c), and with each of those, there is tensor data that takes the form of a multidimensional array, or, after reshaping, a matrix of size (dim(codomain, (a1, ‚Ä¶, aN‚ÇÅ)), dim(domain, (b1, ‚Ä¶, bN‚ÇÇ)))). Again, we can stack all such matrices with the same value of f‚ÇÅ ‚àà fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c) horizontally (as they all have the same number of rows), and with the same value of f‚ÇÇ ‚àà fusiontrees((b1, ‚Ä¶, bN‚ÇÇ), c) vertically (as they have the same number of columns). What emerges is a large matrix of size (blockdim(codomain, c), blockdim(domain, c)) containing all the tensor data associated with the coupled sector c, where blockdim(P, c) = sum(dim(P, s) * length(fusiontrees(s, c)) for s in sectors(P)) for some instance P of ProductSpace. The tensor implementation does not distinguish between abelian or non-abelian sectors and still stores these matrices concatenated in a DenseVector, where each individual block is accessible via block(t, c).\n\nAt first sight, it might now be less clear what the relevance of this block is in relation to the full matrix representation of the tensor map, where the symmetry is not exploited. The essential interpretation is still the same. Schur's lemma now tells that there is a unitary basis transform which makes this matrix representation block diagonal, more specifically, of the form _c B_c  ùüô_c, where B_c denotes block(t, c) and ùüô_c is an identity matrix of size (dim(c), dim(c)). The reason for this extra identity is that the group representation is recoupled to act as _c ùüô  u_c(g) for all g  mathsfI, with u_c(g) the matrix representation of group element g according to the irrep c. In the abelian case, dim(c) == 1, i.e. all irreducible representations are one-dimensional and Schur's lemma only dictates that all off-diagonal blocks are zero. However, in this case the basis transform to the block diagonal representation is not simply a permutation matrix, but a more general unitary matrix composed of the different fusion trees. Indeed, let us denote the fusion trees f‚ÇÅ ‚àà fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c) as X^a_1  a_N‚ÇÅ_cŒ± where Œ± = (e_1  e_N_1-2 Œº‚ÇÅ  Œº_N_1-1) is a collective label for the internal sectors e and the vertex degeneracy labels Œº of a generic fusion tree, as discussed in the corresponding section. The tensor is then represented as\n\n<img src=\"../img/tensor-storage.svg\" alt=\"tensor storage\" class=\"color-invertible\"/>\n\nIn this diagram, we have indicated how the tensor map can be rewritten in terms of a block diagonal matrix with a unitary matrix on its left and another unitary matrix (if domain and codomain are different) on its right. So the left and right matrices should actually have been drawn as squares. They represent the unitary basis transform. In this picture, red and white regions are zero. The center matrix is most easy to interpret. It is the block diagonal matrix _c B_c  ùüô_c with diagonal blocks labeled by the coupled charge c, in this case it takes two values. Every single small square in between the dotted or dashed lines has size d_c  d_c and corresponds to a single element of B_c, tensored with the identity mathrmid_c. Instead of B_c, a more accurate labelling is t^c_(a_1  a_N‚ÇÅ)Œ± (b_1  b_N‚ÇÇ)Œ≤ where Œ± labels different fusion trees from (a_1  a_N‚ÇÅ) to c. The dashed horizontal lines indicate regions corresponding to different fusion (actually splitting) trees, either because of different sectors (a_1  a_N‚ÇÅ) or different labels Œ± within the same sector. Similarly, the dashed vertical lines define the border between regions of different fusion trees from the domain to c, either because of different sectors (b_1  b_N‚ÇÇ) or a different label Œ≤.\n\nTo understand this better, we need to understand the basis transformation, e.g. on the left (codomain) side. In more detail, it is given by\n\n<img src=\"../img/tensor-unitary.svg\" alt=\"tensor unitary\" class=\"color-invertible\"/>\n\nIndeed, remembering that V_i = _a_i R_a_i  ‚ÑÇ^n_a_i with R_a_i the representation space on which irrep a_i acts (with dimension mathrmdim(a_i)), we find\n\nV_1    V_N_1 = _a_1  a_N‚ÇÅ (R_a_1    R_a_N_1)  ‚ÑÇ^n_a_1   n_a_N_1\n\nIn the diagram above, the wiggly lines correspond to the direct sum over the different sectors (a_1  a_N‚ÇÅ), there depicted taking three possible values (a), (a) and (a). The tensor product (R_a_1    R_a_N_1)  ‚ÑÇ^n_a_1   n_a_N_1 is depicted as (R_a_1    R_a_N_1)^ n_a_1   n_a_N_1, i.e. as a direct sum of the spaces R_(a) = (R_a_1    R_a_N_1) according to the dotted horizontal lines, which repeat n_(a) = n_a_1   n_a_N_1 times. In this particular example, n_(a)=2, n_(a)=3 and n_(a)=5. The thick vertical line represents the separation between the two different coupled sectors, denoted as c and c. Dashed vertical lines represent different ways of reaching the coupled sector, corresponding to different Œ±. In this example, the first sector (a) has one fusion tree to c, labeled by cŒ±, and two fusion trees to c, labeled by cŒ± and cŒ±. The second sector has only a fusion tree to c, labeled by cŒ±. The third sector only has a fusion tree to c, labeld by c Œ±. Finally then, because the fusion trees do not act on the spaces ‚ÑÇ^n_a_1   n_a_N_1, the dotted lines which represent the different n_(a) = n_a_1   n_a_N_1 dimensions are also drawn vertically. In particular, for a given sector (a) and a specific fusion tree X^(a)_cŒ±  R_(a)R_c, the action is X^(a)_cŒ±  ùüô_n_(a), which corresponds to the diagonal green blocks in this drawing where the same matrix X^(a)_cŒ± (the fusion tree) is repeated along the diagonal. Note that the fusion tree is not a vector or single column, but a matrix with number of rows equal to mathrmdim(R_(aldots)) = d_a_1 d_a_2  d_a_N_1 and number of columns equal to d_c. A similar interpretation can be given to the basis transform on the right, by taking its adjoint. In this particular example, it has two different combinations of sectors (b) and (b), where both have a single fusion tree to c as well as to c, and n_(b)=2, n_(b)=3.\n\nNote that we never explicitly store or act with the basis transformations on the left and the right. For composing tensor maps (i.e. multiplying them), these basis transforms just cancel, whereas for tensor factorizations they just go through trivially. They transform non-trivially when reshuffling the tensor indices, both within or in between the domain and codomain. For this, however, we can completely rely on the manipulations of fusion trees to implicitly compute the effect of the basis transform and construct the new blocks B_c that result with respect to the new basis.\n\nHence, as before, we only store the diagonal blocks B_c of size (blockdim(codomain(t), c), blockdim(domain(t), c)) as a DenseMatrix, accessible via block(t, c). Within this matrix, there are regions of the form view(block(t, c), m‚ÇÅ:m‚ÇÇ, n‚ÇÅ:n‚ÇÇ) that correspond to the data t^c_(a_1  a_N‚ÇÅ)Œ± (b_1  b_N‚ÇÇ)Œ≤ associated with a pair of fusion trees X^(a_1  a_N‚ÇÅ)_cŒ± and X^(b_1  b_N‚ÇÇ)_cŒ≤, henceforth again denoted as f‚ÇÅ and f‚ÇÇ, with f‚ÇÅ.coupled == f‚ÇÇ.coupled == c. The ranges where this subblock is living are managed within the tensor implementation, and these subblocks can be accessed via t[f‚ÇÅ, f‚ÇÇ], and is returned as a StridedArray of size n_a_1  n_a_2    n_a_N_1  n_b_1   n_b_N‚ÇÇ, or in code, (dim(V1, a1), dim(V2, a2), ‚Ä¶, dim(VN‚ÇÅ, aN‚ÇÅ), dim(W1, b1), ‚Ä¶, dim(WN‚ÇÇ, bN‚ÇÇ)). While the implementation does not distinguish between FusionStyle isa UniqueFusion or FusionStyle isa MultipleFusion, in the former case the fusion tree is completely characterized by the uncoupled sectors, and so the subblocks can also be accessed as t[(a1, ‚Ä¶, aN‚ÇÅ, b1, ‚Ä¶, bN‚ÇÇ)]. When there is no symmetry at all, i.e.  sectortype(t) == Trivial, t[] returns the raw tensor data as a StridedArray of size (dim(V1), ‚Ä¶, dim(VN‚ÇÅ), dim(W1), ‚Ä¶, dim(WN‚ÇÇ)), whereas block(t, Trivial()) returns the same data as a DenseMatrix of size (dim(V1) * ‚Ä¶ * dim(VN‚ÇÅ), dim(W1) * ‚Ä¶ * dim(WN‚ÇÇ)).","category":"section"},{"location":"man/tensors/#ss_tensor_construction","page":"Constructing tensors and the TensorMap type","title":"Constructing tensor maps and accessing tensor data","text":"Having learned how a tensor is represented and stored, we can now discuss how to create tensors and tensor maps. From hereon, we focus purely on the interface rather than the implementation.","category":"section"},{"location":"man/tensors/#Random-and-uninitialized-tensor-maps","page":"Constructing tensors and the TensorMap type","title":"Random and uninitialized tensor maps","text":"The most convenient set of constructors are those that construct tensors or tensor maps with random or uninitialized data. They take the form\n\nf(codomain, domain = one(codomain))\nf(eltype::Type{<:Number}, codomain, domain = one(codomain))\nTensorMap{eltype::Type{<:Number}}(undef, codomain, domain = one(codomain))\nTensor{eltype::Type{<:Number}}(undef, codomain)\n\nHere, f is any of the typical functions from Base that normally create arrays, namely zeros, ones, rand, randn and Random.randexp. Remember that one(codomain) is the empty ProductSpace{S, 0}(). The third and fourth calling syntax use the UndefInitializer from Julia Base and generates a TensorMap with unitialized data, which can thus contain NaNs.\n\nIn all of these constructors, the last two arguments can be replaced by domain ‚Üí codomain or codomain ‚Üê domain, where the arrows are obtained as \\rightarrow+TAB and \\leftarrow+TAB and create a HomSpace as explained in the section on Spaces of morphisms. Some examples are perhaps in order\n\nt1 = randn(‚ÑÇ^2 ‚äó ‚ÑÇ^3, ‚ÑÇ^2)\nt2 = zeros(Float32, ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üê ‚ÑÇ^2)\nt3 = TensorMap{Float64}(undef, ‚ÑÇ^2 ‚Üí ‚ÑÇ^2 ‚äó ‚ÑÇ^3)\ndomain(t1) == domain(t2) == domain(t3)\ncodomain(t1) == codomain(t2) == codomain(t3)\ndisp(x) = show(IOContext(Core.stdout, :compact=>false), \"text/plain\", trunc.(x; digits = 3));\nt1[] |> disp\nblock(t1, Trivial()) |> disp\nreshape(t1[], dim(codomain(t1)), dim(domain(t1))) |> disp\n\nFinally, all constructors can also be replaced by Tensor(..., codomain), in which case the domain is assumed to be the empty ProductSpace{S, 0}(), which can easily be obtained as one(codomain). Indeed, the empty product space is the unit object of the monoidal category, equivalent to the field of scalars ùïú, and thus the multiplicative identity (especially since * also acts as tensor product on vector spaces).\n\nThe matrices created by f are the matrices B_c discussed above, i.e. those returned by block(t, c). Only numerical matrices of type DenseMatrix are accepted, which in practice just means Julia's intrinsic Matrix{T} for some T <: Number. Ongoing work extends this to support for CuMatrix from CuArrays.jl to harness GPU computing power, and future work might include distributed arrays.\n\nSupport for static or sparse data is currently unavailable, and if it would be implemented, it would likely lead to new subtypes of AbstractTensorMap which are distinct from TensorMap. Future implementations of e.g. SparseTensorMap or StaticTensorMap could be useful.","category":"section"},{"location":"man/tensors/#Tensor-maps-from-existing-data","page":"Constructing tensors and the TensorMap type","title":"Tensor maps from existing data","text":"To create a TensorMap with existing data, one can use the aforementioned form but with the function f replaced with the actual data, i.e. TensorMap(data, codomain, domain) or any of its equivalents.\n\nHere, data can be of two types. It can be a dictionary (any AbstractDict subtype) which has blocksectors c of type sectortype(codomain) as keys, and the corresponding matrix blocks as value, i.e. data[c] is some DenseMatrix of size (blockdim(codomain, c), blockdim(domain, c)).\n\nFor those space types for which a TensorMap can be converted to a plain multidimensional array, the data can also be a general DenseArray, either of rank N‚ÇÅ + N‚ÇÇ and with matching size (dims(codomain)..., dims(domain)...), or just as a DenseMatrix with size (dim(codomain), dim(domain)). This is true in particular if the sector type is Trivial, e.g. for CartesianSpace or ComplexSpace. Then the data array is just reshaped into matrix form and referred to as such in the resulting TensorMap instance. When spacetype is GradedSpace, the TensorMap constructor will try to reconstruct the tensor data such that the resulting tensor t satisfies data == convert(Array, t). This might not be possible, if the data does not respect the symmetry structure. This procedure can be sketched using a simple physical example, namely the SWAP gate on two qubits,\n\nbeginalign*\nmathrmSWAP mathbbC^2 otimes mathbbC^2  to mathbbC^2 otimes mathbbC^2\nirangle otimes jrangle mapsto jrangle otimes irangle\nendalign*\n\nThis operator can be rewritten in terms of the familiar Heisenberg exchange interaction vecS_i cdot vecS_j as\n\nmathrmSWAP = 2 vecS_i cdot vecS_j + frac12 ùüô\n\nwhere vecS = (S^x S^y S^z) and the spin-1/2 generators of SU‚ÇÇ S^k are defined defined in terms of the 2 times 2 Pauli matrices sigma^k as S^k = frac12sigma^k. The SWAP gate can be realized as a rank-4 TensorMap in the following way:\n\n# encode the matrix elements of the swap gate into a rank-4 array, where the first two\n# indices correspond to the codomain and the last two indices correspond to the domain\ndata = zeros(2,2,2,2)\n# the swap gate then maps the last two indices on the first two in reversed order\ndata[1,1,1,1] = data[2,2,2,2] = data[1,2,2,1] = data[2,1,1,2] = 1\nV1 = ‚ÑÇ^2 # generic qubit hilbert space\nt1 = TensorMap(data, V1 ‚äó V1, V1 ‚äó V1)\nV2 = SU2Space(1/2=>1) # hilbert space of an actual spin-1/2 particle, respecting symmetry\nt2 = TensorMap(data, V2 ‚äó V2, V2 ‚äó V2)\nV3 = U1Space(1/2=>1,-1/2=>1) # restricted space that only uses the `œÉ_z` rotation symmetry\nt3 = TensorMap(data, V3 ‚äó V3, V3 ‚äó V3)\nfor (c,b) in blocks(t3)\n    println(\"Data for block $c :\")\n    disp(b)\n    println()\nend\n\nHence, we recognize that the exchange interaction has eigenvalue -1 in the coupled spin zero sector (SU2Irrep(0)), and eigenvalue +1 in the coupled spin 1 sector (SU2Irrep(1)). Using Irrep[U‚ÇÅ] instead, we observe that both coupled charge U1Irrep(+1) and U1Irrep(-1) have eigenvalue +1. The coupled charge U1Irrep(0) sector is two-dimensional, and has an eigenvalue +1 and an eigenvalue -1.\n\nTo construct the proper data in more complicated cases, one has to know where to find each sector in the range 1:dim(V) of every index i with associated space V, as well as the internal structure of the representation space when the corresponding sector c has dim(c) > 1, i.e. in the case of FusionStyle(c) isa MultipleFusion. Currently, the only non-abelian sectors are Irrep[SU‚ÇÇ] and Irrep[CU‚ÇÅ], for which the internal structure is the natural one.\n\nThere are some tools available to facilitate finding the proper range of sector c in space V, namely axes(V, c). This also works on a ProductSpace, with a tuple of sectors. An example\n\nV = SU2Space(0=>3, 1=>2, 2=>1)\nP = V ‚äó V ‚äó V\naxes(P, (SU2Irrep(1), SU2Irrep(0), SU2Irrep(2)))\n\nNote that the length of the range is the degeneracy dimension of that sector, times the dimension of the internal representation space, i.e. the quantum dimension of that sector.","category":"section"},{"location":"man/tensors/#Assigning-block-data-after-initialization","page":"Constructing tensors and the TensorMap type","title":"Assigning block data after initialization","text":"In order to avoid having to know the internal structure of each representation space to properly construct the full data array, it is often simpler to assign the block data directly after initializing an all zero TensorMap with the correct spaces. While this may seem more difficult at first sight since it requires knowing the exact entries associated to each valid combination of domain uncoupled sectors, coupled sector and codomain uncoupled sectors, this is often a far more natural procedure in practice.\n\nA first option is to directly set the full matrix block for each coupled sector in the TensorMap. For the example with mathsfU_1 symmetry, this can be done as\n\nt4 = zeros(V3 ‚äó V3, V3 ‚äó V3);\nblock(t4, U1Irrep(0)) .= [1 0; 0 1];\nblock(t4, U1Irrep(1)) .= [1;;];\nblock(t4, U1Irrep(-1)) .= [1;;];\nfor (c, b) in blocks(t4)\n    println(\"Data for block $c :\")\n    disp(b)\n    println()\nend\n\nWhile this indeed does not require considering the internal structure of the representation spaces, it still requires knowing the precise row and column indices corresponding to each set of uncoupled sectors in the codmain and domain respectively to correctly assign the nonzero entries in each block.\n\nPerhaps the most natural way of constructing a particular TensorMap is to directly assign the data slices for each splitting - fusion tree pair using the fusiontrees(::TensorMap) method. This returns an iterator over all tuples (f‚ÇÅ, f‚ÇÇ) of splitting - fusion tree pairs corresponding to all ways in which the set of domain uncoupled sectors can fuse to a coupled sector and split back into the set of codomain uncoupled sectors. By directly setting the corresponding data slice t[f‚ÇÅ, f‚ÇÇ] of size (dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(domain(t), f‚ÇÇ.uncoupled)...), we can construct all the block data without worrying about the internal ordering of row and column indices in each block. In addition, the corresponding value of each fusion tree slice is often directly informed by the object we are trying to construct in the first place. For example, in order to construct the Heisenberg exchange interaction on two spin-1/2 particles i and j as an SU‚ÇÇ symmetric TensorMap, we can make use of the observation that\n\nvecS_i cdot vecS_j = frac12 left( left( vecS_i cdot vecS_j right)^2 - vecS_i^2 - vecS_j^2 right)\n\nRecalling some basic group theory, we know that the quadratic Casimir of SU‚ÇÇ, vecS^2, has a well-defined eigenvalue j(j+1) on every irrep of spin j. From the above expressions, we can therefore directly read off the eigenvalues of the SWAP gate in terms of this Casimir eigenvalue on the domain uncoupled sectors and the coupled sector. This gives us exactly the prescription we need to assign the data slice corresponding to each splitting - fusion tree pair:\n\nC(s::SU2Irrep) = s.j * (s.j + 1)\nt5 = zeros(V2 ‚äó V2, V2 ‚äó V2);\nfor (f‚ÇÅ, f‚ÇÇ) in fusiontrees(t5)\n    t5[f‚ÇÅ, f‚ÇÇ] .= C(f‚ÇÇ.coupled) - C(f‚ÇÇ.uncoupled[1]) - C(f‚ÇÇ.uncoupled[2]) + 1/2\nend\nfor (c, b) in blocks(t5)\n    println(\"Data for block $c :\")\n    disp(b)\n    println()\nend","category":"section"},{"location":"man/tensors/#Constructing-similar-tensors","page":"Constructing tensors and the TensorMap type","title":"Constructing similar tensors","text":"A third way to construct a TensorMap instance is to use Base.similar, i.e.\n\nsimilar(t [, T::Type{<:Number}, codomain, domain])\n\nwhere T is a possibly different eltype for the tensor data, and codomain and domain optionally define a new codomain and domain for the resulting tensor. By default, these values just take the value from the input tensor t. The result will be a new TensorMap instance, with undef data, but whose data is stored in the same subtype of DenseVector (e.g. Vector or CuVector or ...) as t. In particular, this uses the methods storagetype(t) and TensorKit.similarstoragetype(t, T).","category":"section"},{"location":"man/tensors/#Special-purpose-constructors","page":"Constructing tensors and the TensorMap type","title":"Special purpose constructors","text":"Finally, there are methods zero, one, id, isomorphism, unitary and isometry to create specific new tensors. Tensor maps behave as vectors and can be added (if they have the same domain and codomain); zero(t) is the additive identity, i.e. a TensorMap instance where all entries are zero. For a t::TensorMap with domain(t) == codomain(t), i.e. an endomorphism, one(t) creates the identity tensor, i.e. the identity under composition. As discussed in the section on linear algebra operations, we denote composition of tensor maps with the multiplication operator *, such that one(t) is the multiplicative identity. Similarly, it can be created as id(V) with V the relevant vector space, e.g. one(t) == id(domain(t)). The identity tensor is currently represented with dense data, and one can use id(A::Type{<:DenseVector}, V) to specify the type of DenseVector (and its eltype), e.g. A = Vector{Float64}. Finally, it often occurs that we want to construct a specific isomorphism between two spaces that are isomorphic but not equal, and for which there is no canonical choice. Hereto, one can use the method u = isomorphism([A::Type{<:DenseVector}, ] codomain, domain), which will explicitly check that the domain and codomain are isomorphic, and return an error otherwise. Again, an optional first argument can be given to specify the specific type of DenseVector that is currently used to store the rather trivial data of this tensor. If InnerProductStyle(u) <: EuclideanProduct, the same result can be obtained with the method u = unitary([A::Type{<:DenseVector}, ] codomain, domain). Note that reversing the domain and codomain yields the inverse morphism, which in the case of EuclideanProduct coincides with the adjoint morphism, i.e. isomorphism(A, domain, codomain) == adjoint(u) == inv(u), where inv and adjoint will be further discussed below. Finally, if two spaces V1 and V2 are such that V2 can be embedded in V1, i.e. there exists an inclusion with a left inverse, and furthermore they represent tensor products of some ElementarySpace with EuclideanProduct, the function w = isometry([A::Type{<:DenseMatrix}, ], V1, V2) creates one specific isometric embedding, such that adjoint(w) * w == id(V2) and w * adjoint(w) is some hermitian idempotent (a.k.a. orthogonal projector) acting on V1. An error will be thrown if such a map cannot be constructed for the given domain and codomain.\n\nLet's conclude this section with some examples with GradedSpace.\n\nV1 = ‚Ñ§‚ÇÇSpace(0 => 3, 1 => 2)\nV2 = ‚Ñ§‚ÇÇSpace(0 => 2, 1 => 1)\n# First a `TensorMap{‚Ñ§‚ÇÇSpace, 1, 1}`\nm = randn(V1, V2)\nconvert(Array, m) |> disp\n# compare with:\nblock(m, Irrep[‚Ñ§‚ÇÇ](0)) |> disp\nblock(m, Irrep[‚Ñ§‚ÇÇ](1)) |> disp\n# Now a `TensorMap{‚Ñ§‚ÇÇSpace, 2, 2}`\nt = randn(V1 ‚äó V1, V2 ‚äó V2')\n(array = convert(Array, t)) |> disp\nd1 = dim(codomain(t))\nd2 = dim(domain(t))\n(matrix = reshape(array, d1, d2)) |> disp\n(u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |> disp\n(v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |> disp\nu' * u ‚âà I ‚âà v' * v\n(u' * matrix * v) |> disp\n# compare with:\nblock(t, Z2Irrep(0)) |> disp\nblock(t, Z2Irrep(1)) |> disp\n\nHere, we illustrated some additional concepts. Firstly, note that we convert a TensorMap to an Array. This only works when sectortype(t) supports fusiontensor, and in particular when BraidingStyle(sectortype(t)) == Bosonic(), e.g. the case of trivial tensors (the category mathbfVect) and group representations (the category mathbfRep_mathsfG, which can be interpreted as a subcategory of mathbfVect). Here, we are in this case with mathsfG = ‚Ñ§‚ÇÇ. For a TensorMap{S, 1, 1}, the blocks directly correspond to the diagonal blocks in the block diagonal structure of its representation as an Array, there is no basis transform in between. This is no longer the case for TensorMap{S, N‚ÇÅ, N‚ÇÇ} with different values of N‚ÇÅ and N‚ÇÇ. Here, we use the operation fuse(V), which creates an ElementarySpace which is isomorphic to a given space V (of type ProductSpace or ElementarySpace). The specific map between those two spaces constructed using the specific method unitary implements precisely the basis change from the product basis to the coupled basis. In this case, for a group G with FusionStyle(Irrep[G]) isa UniqueFusion, it is a permutation matrix. Specifically choosing V equal to the codomain and domain of t, we can construct the explicit basis transforms that bring t into block diagonal form.\n\nLet's repeat the same exercise for I = Irrep[SU‚ÇÇ], which has FusionStyle(I) isa MultipleFusion.\n\nV1 = SU‚ÇÇSpace(0 => 2, 1 => 1)\nV2 = SU‚ÇÇSpace(0 => 1, 1 => 1)\n# First a `TensorMap{SU‚ÇÇSpace, 1, 1}`\nm = randn(V1, V2)\nconvert(Array, m) |> disp\n# compare with:\nblock(m, Irrep[SU‚ÇÇ](0)) |> disp\nblock(m, Irrep[SU‚ÇÇ](1)) |> disp\n# Now a `TensorMap{SU‚ÇÇSpace, 2, 2}`\nt = randn(V1 ‚äó V1, V2 ‚äó V2')\n(array = convert(Array, t)) |> disp\nd1 = dim(codomain(t))\nd2 = dim(domain(t))\n(matrix = reshape(array, d1, d2)) |> disp\n(u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |> disp\n(v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |> disp\nu' * u ‚âà I ‚âà v' * v\n(u' * matrix * v) |> disp\n# compare with:\nblock(t, SU2Irrep(0)) |> disp\nblock(t, SU2Irrep(1)) |> disp\nblock(t, SU2Irrep(2)) |> disp\n\nNote that the basis transforms u and v are no longer permutation matrices, but are still unitary. Furthermore, note that they render the tensor block diagonal, but that now every element of the diagonal blocks labeled by c comes itself in a tensor product with an identity matrix of size dim(c), i.e. dim(SU2Irrep(1)) = 3 and dim(SU2Irrep(2)) = 5.","category":"section"},{"location":"man/tensors/#ss_tensor_properties","page":"Constructing tensors and the TensorMap type","title":"Tensor properties","text":"Given a t::AbstractTensorMap{T, S, N‚ÇÅ, N‚ÇÇ}, there are various methods to query its properties. The most important are clearly codomain(t) and domain(t). For t::AbstractTensor{S, N}, i.e. t::AbstractTensorMap{T, S, N, 0}, we can use space(t) as synonym for codomain(t). However, for a general AbstractTensorMap this has no meaning. However, we can query space(t, i), the space associated with the ith index. For i ‚àà 1:N‚ÇÅ, this corresponds to codomain(t, i) = codomain(t)[i]. For j = i-N‚ÇÅ ‚àà (1:N‚ÇÇ), this corresponds to dual(domain(t, j)) = dual(domain(t)[j]).\n\nThe total number of indices, i.e. N‚ÇÅ + N‚ÇÇ, is given by numind(t), with N‚ÇÅ == numout(t) and N‚ÇÇ == numin(t), the number of outgoing and incoming indices. There are also the unexported methods TensorKit.codomainind(t) and TensorKit.domainind(t) which return the tuples (1, 2, ‚Ä¶, N‚ÇÅ) and (N‚ÇÅ+1, ‚Ä¶, N‚ÇÅ+N‚ÇÇ), and are useful for internal purposes. The type parameter S <: ElementarySpace can be obtained as spacetype(t); the corresponding sector can directly obtained as sectortype(t) and is Trivial when S != GradedSpace. The underlying field scalars of S can also directly be obtained as field(t). This is different from eltype(t), which returns the type of Number in the tensor data, i.e. the type parameter T in the (subtype of) DenseVector{T} in which the matrix blocks are stored. Note that during construction, a (one-time) warning is printed if !(T ‚äÇ field(S)). The specific DenseVector{T} subtype in which the tensor data is stored is obtained as storagetype(t). Each of the methods numind, numout, numin, TensorKit.codomainind, TensorKit.domainind, spacetype, sectortype, field, eltype and storagetype work in the type domain as well, i.e. they are encoded in typeof(t).\n\nFinally, there are methods to probe the data, which we already encountered. blocksectors(t) returns an iterator over the different coupled sectors that can be obtained from fusing the uncoupled sectors available in the domain, but they must also be obtained from fusing the uncoupled sectors available in the codomain (i.e. it is the intersection of both blocksectors(codomain(t)) and blocksectors(domain(t))). For a specific sector c ‚àà blocksectors(t), block(t, c) returns the corresponding data. Both are obtained together with blocks(t), which returns an iterator over the pairs c => block(t, c). Furthermore, there is fusiontrees(t) which returns an iterator over splitting-fusion tree pairs (f‚ÇÅ, f‚ÇÇ), for which the corresponding data is given by t[f‚ÇÅ, f‚ÇÇ] (i.e. using Base.getindex).\n\nLet's again illustrate these methods with an example, continuing with the tensor t from the previous example\n\ntypeof(t)\ncodomain(t)\ndomain(t)\nspace(t,1)\nspace(t,2)\nspace(t,3)\nspace(t,4)\nnumind(t)\nnumout(t)\nnumin(t)\nspacetype(t)\nsectortype(t)\nfield(t)\neltype(t)\nstoragetype(t)\nblocksectors(t)\nblocks(t)\nblock(t, first(blocksectors(t)))\nfusiontrees(t)\nf1, f2 = first(fusiontrees(t))\nt[f1,f2]","category":"section"},{"location":"man/tensors/#ss_tensor_readwrite","page":"Constructing tensors and the TensorMap type","title":"Reading and writing tensors: Dict conversion","text":"There are no custom or dedicated methods for reading, writing or storing TensorMaps, however, there is the possibility to convert a t::AbstractTensorMap into a Dict, simply as convert(Dict, t). The backward conversion convert(TensorMap, dict) will return a tensor that is equal to t, i.e. t == convert(TensorMap, convert(Dict, t)).\n\nThis conversion relies on that the string represenation of objects such as VectorSpace, FusionTree or Sector should be such that it represents valid code to recreate the object. Hence, we store information about the domain and codomain of the tensor, and the sector associated with each data block, as a String obtained with repr. This provides the flexibility to still change the internal structure of such objects, without this breaking the ability to load older data files. The resulting dictionary can then be stored using any of the provided Julia packages such as JLD.jl, JLD2.jl, BSON.jl, JSON.jl, ...","category":"section"},{"location":"man/spaces/#s_spaces","page":"Vector spaces","title":"Vector spaces","text":"From the Introduction, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type VectorSpace\n\nabstract type VectorSpace end\n\nTechnically speaking, this name does not capture the full generality that TensorKit.jl supports, as instances of subtypes of VectorSpace can encode general objects in linear monoidal categories, which are not necessarily vector spaces. However, in order not to make the remaining discussion too abstract or complicated, we will simply use the nomenclature of vector spaces. In particular, we define two abstract subtypes\n\nabstract type ElementarySpace <: VectorSpace end\nconst IndexSpace = ElementarySpace\n\nabstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end\n\nHere, ElementarySpace is a super type for all vector spaces (objects) that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace.\n\nOn the other hand, subtypes of CompositeSpace{S} where S <: ElementarySpace are composed of a number of elementary spaces of type S. So far, there is a single concrete type ProductSpace{S, N} that represents the tensor product of N vector spaces of a homogeneous type S. Its properties are discussed in the section on Composite spaces, together with possible extensions for the future.\n\nThroughout TensorKit.jl, the function spacetype returns the type of ElementarySpace associated with e.g. a composite space or a tensor. It works both on instances and in the type domain. Its use will be illustrated below.","category":"section"},{"location":"man/spaces/#ss_fields","page":"Vector spaces","title":"Fields","text":"Vector spaces (and linear categories more generally) are defined over a field of scalars ùîΩ. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via\n\nabstract type Field end\n\nstruct RealNumbers <: Field end\nstruct ComplexNumbers <: Field end\n\nconst ‚Ñù = RealNumbers()\nconst ‚ÑÇ = ComplexNumbers()\n\nNote that ‚Ñù and ‚ÑÇ can be typed as \\bbR+TAB and \\bbC+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia's Number hierarchy is to introduce some syntactic sugar without committing type piracy. In particular, we now have\n\n3 ‚àà ‚Ñù\n5.0 ‚àà ‚ÑÇ\n5.0 + 1.0 * im ‚àà ‚Ñù\nFloat64 ‚äÜ ‚Ñù\nComplexF64 ‚äÜ ‚ÑÇ\n‚Ñù ‚äÜ ‚ÑÇ\n‚ÑÇ ‚äÜ ‚Ñù\n\nand furthermore ‚Äîprobably more usefully‚Äî ‚Ñù^n and ‚ÑÇ^n create specific elementary vector spaces as described in the next section. The underlying field of a vector space or tensor a can be obtained with field(a):","category":"section"},{"location":"man/spaces/#ss_elementaryspaces","page":"Vector spaces","title":"Elementary spaces","text":"As mentioned at the beginning of this section, vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of ElementarySpace. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that associated vector spaces, such as the dual space, are objects of the same concrete type (i.e. with the same type parameters in case of a parametric type). In particular, every ElementarySpace should implement the following methods\n\nFor convenience, the dual of a space V can also be obtained as V'. Furthermore, it is sometimes necessary to test whether a space is a dual or conjugate space, for which the methods isdual(::ElementarySpace) and isconj(::ElementarySpace) should be implemented.\n\nWe furthermore define a trait type\n\nto denote for a vector space V whether it has an inner product and thus a canonical mapping from dual(V) to V (for real fields ùîΩ ‚äÜ ‚Ñù) or from dual(V) to conj(V) (for complex fields). This mapping is provided by the metric, but no further support for working with vector spaces with general metrics is currently implemented.\n\nA number of concrete elementary spaces are implemented in TensorKit.jl. There is concrete type GeneralSpace which is completely characterized by its field ùîΩ, its dimension and whether its the dual and/or complex conjugate of ùîΩ^d.\n\nHowever, as the InnerProductStyle of GeneralSpace is currently set to NoInnerProduct(), this type of vector space is currently quite limited, though it supports constructing tensors and contracting them. However, most tensor factorizations will depend on the presence of an Euclidean inner product.\n\nSpaces with the EuclideanInnerProduct() style, i.e. with a standard Euclidean metric, have the natural isomorphisms dual(V) == V (for ùîΩ == ‚Ñù) or dual(V) == conj(V) (for ùîΩ == ‚ÑÇ). In the language of the appendix on categories, this trait represents dagger or unitary categories, and these vector spaces support an adjoint operation.\n\nIn particular, two concrete types are provided:\n\nThey represent the Euclidean spaces ‚Ñù^d or C^d without further inner structure. They can be created using the syntax CartesianSpace(d) == ‚Ñù^d and ComplexSpace(d) == ‚ÑÇ^d, or ComplexSpace(d, true) == ComplexSpace(d; dual = true) == (‚ÑÇ^d)' for the dual space of the latter. Note that the brackets are required because of the precedence rules, since d' == d for d::Integer.\n\nSome examples:\n\ndim(‚Ñù^10)\n(‚Ñù^10)' == ‚Ñù^10\nisdual((‚ÑÇ^5))\nisdual((‚ÑÇ^5)')\nisdual((‚Ñù^5)')\ndual(‚ÑÇ^5) == (‚ÑÇ^5)' == conj(‚ÑÇ^5) == ComplexSpace(5; dual = true)\nfield(‚ÑÇ^5)\nfield(‚Ñù^3)\ntypeof(‚Ñù^3)\nspacetype(‚Ñù^3)\nInnerProductStyle(‚Ñù^3)\nInnerProductStyle(‚ÑÇ^5)\n\nnote: Note\nFor ‚ÑÇ^n the dual space is equal (or naturally isomorphic) to the conjugate space, but not to the space itself. This means that even for ‚ÑÇ^n, arrows matter in the diagrammatic notation for categories or for tensors, and in particular that a contraction between two tensor indices will check that one is living in the space and the other in the dual space. This is in contrast with several other software packages, especially in the context of tensor networks, where arrows are only introduced when discussing symmetries. We believe that our more puristic approach can be useful to detect errors (e.g. unintended contractions). Only with ‚Ñù^n will their be no distinction between a space and its dual. When creating tensors with indices in ‚Ñù^n that have complex data, a one-time warning will be printed, but most operations should continue to work nonetheless.\n\nOne more important concrete implementation of ElementarySpace with a EuclideanInnerProduct() is the GradedSpace type, which is used to represent a graded complex vector space, where the grading is provided by the irreducible representations of a group, or more generally, the simple objects of a unitary fusion category. We refer to the subsection on graded spaces on the next page for further information about GradedSpace.","category":"section"},{"location":"man/spaces/#Operations-with-elementary-spaces","page":"Vector spaces","title":"Operations with elementary spaces","text":"Instances of ElementarySpace support a number of useful operations. Firstly, we define the direct sum of two vector spaces V1 and V2 of the same spacetype (and with the same value of isdual) as V1 ‚äï V2, where ‚äï is obtained by typing \\oplus+TAB. zerospace(V) corresponds to the identity or zero element with respect to this direct sum operation, i.e. it corresponds to a zero-dimensional space. Furthermore, unitspace(V) applied to an elementary space returns a one-dimensional space, that is isomorphic to the scalar field underlying the space itself. Finally, we have also introduced the non-standard convention V1 ‚äñ V2 (obtained by typing \\ominus+TAB.) in order to obtain a space that is isomorphic to the quotient space of V1 by V2, or thus, a particular choice of complement of V2 in V1 such that V1 == V2 ‚äï (V1 ‚äñ V2) is satisfied.\n\nSome examples illustrate this better.\n\n‚Ñù^5 ‚äï ‚Ñù^3\n‚ÑÇ^5 ‚äï ‚ÑÇ^3\n‚ÑÇ^5 ‚äï (‚ÑÇ^3)'\nzerospace(‚ÑÇ^3)\nunitspace(‚Ñù^3)\n‚ÑÇ^5 ‚äï unitspace(ComplexSpace)\nunitspace((‚ÑÇ^3)')\n(‚ÑÇ^5) ‚äï unitspace((‚ÑÇ^5))\n(‚ÑÇ^5)' ‚äï unitspace((‚ÑÇ^5)')\n(‚Ñù^5) ‚äñ (‚Ñù^3)\n(‚ÑÇ^5) ‚äñ (‚ÑÇ^3)\n(‚ÑÇ^5)' ‚äñ (‚ÑÇ^3)'\n‚ÑÇ^5 == ((‚ÑÇ^5) ‚äñ (‚ÑÇ^3)) ‚äï (‚ÑÇ^3) == (‚ÑÇ^3) ‚äï ((‚ÑÇ^5) ‚äñ (‚ÑÇ^3))\n\nNote, finally, that we have defined oplus and ominus as ASCII alternatives for ‚äï and ‚äñ respectively.\n\nA second type of operation with elementary spaces is the function flip(V::ElementarySpace), which returns a space that is isomorphic to V but has isdual(flip(V)) == isdual(V'), i.e., if V is a normal space, then flip(V) is a dual space. flip(V) is different from dual(V) in the case of GradedSpace. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from V1 to flip(V1).\n\nWhile we provide some trivial examples here, we refer to the section on graded spaces for examples where flip acts non-trivially and produces results that are different than dual.\n\nflip(‚ÑÇ^4)\nflip(‚ÑÇ^4) ‚âÖ ‚ÑÇ^4\nflip(‚ÑÇ^4) == ‚ÑÇ^4\n\nFinally, we provide two methods infimum(V1, V2) and supremum(V1, V2) for elementary spaces V1 and V2 with the same spacetype and value of isdual. The former returns the \"largest\" elementary space V::ElementarySpace with the same value of isdual such that we can construct surjective morphisms from both V1 and V2 to V. Similarly, the latter returns the \"smallest\" elementary space W::ElementarySpace with the same value of isdual such that we can construct injective morphisms from both V1 and V2 to W. For CartesianSpace and ComplexSpace, this simply amounts to the space with minimal or maximal dimension, but it is again more interesting in the case of GradedSpace, as discussed on the next page. It is that case where infimum(V1, V2) might be different from either V1 or V2, and similar for supremum(V1, V2), which justifies the choice of these names over simply min and max. Also note that these methods are a direct consequence of the partial order that we can define between vector spaces of the same spacetype more generally, as discussed below in the subsection More operations with vector spaces.\n\nSome examples:\n\ninfimum(‚Ñù^5, ‚Ñù^3)\nsupremum(‚ÑÇ^5, ‚ÑÇ^3)\nsupremum(‚ÑÇ^5, (‚ÑÇ^3)')\nsupremum((‚ÑÇ^5)', (‚ÑÇ^3)')","category":"section"},{"location":"man/spaces/#ss_compositespaces","page":"Vector spaces","title":"Composite spaces","text":"Composite spaces are vector spaces that are built up out of individual elementary vector spaces of the same type. The most prominent (and currently only) example is a tensor product of N elementary spaces of the same type S:\n\nGiven some V1::S, V2::S, V3::S of the same type S<:ElementarySpace, we can easily construct ProductSpace{S, 3}((V1, V2, V3)) as ProductSpace(V1, V2, V3) or using V1 ‚äó V2 ‚äó V3, where ‚äó is simply obtained by typing \\otimes+TAB. In fact, for convenience, also the regular multiplication operator * acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.\n\nV1 = ‚ÑÇ^2\nV2 = ‚ÑÇ^3\nV1 ‚äó V2 ‚äó V1' == V1 * V2 * V1' == ProductSpace(V1, V2, V1') == ProductSpace(V1, V2) ‚äó V1'\nV1^3\ndim(V1 ‚äó V2)\ndims(V1 ‚äó V2)\ndual(V1 ‚äó V2 ‚äó V1')\nspacetype(V1 ‚äó V2)\nspacetype(ProductSpace{ComplexSpace,3})\n\nHere, the newly introduced function dims maps dim to the individual spaces in a ProductSpace and returns the result as a tuple. The rationale for the dual space of a ProductSpace being the tensor product of the dual spaces in reverse order is explained in the subsection on duality in the appendix on category theory.\n\nFollowing Julia's Base library, the function one applied to an instance of ProductSpace{S, N} or of S <: ElementarySpace itself returns the multiplicative identity for these objects. Similar to Julia Base, one also works in the type domain. The multiplicative identity for vector spaces corresponds to the (monoidal) unit, which is represented as ProductSpace{S, 0}(()) and simply printed as one(S) for the specific type S. Note, however, that one(S) is strictly speaking only the multiplicative identity when multiplied with ProductSpace{S, N} instances. For elementary spaces V::S, V ‚äó one(V) will yield ProductSpace{S, 1}(V) and not V itself. However, even though V ‚äó one(V) is not strictly equal to V, the object ProductSpace(V), which can also be created as ‚äó(V), does mathematically encapsulate the same vector space as V.\n\none(V1)\ntypeof(one(V1))\nV1 * one(V1) == ProductSpace(V1) == ‚äó(V1)\nV1 * one(V1) == V1\nP = V1 * V2;\none(P)\none(typeof(P))\nP * one(P) == P == one(P) ‚äó P\n\nIn the future, other CompositeSpace types could be added. For example, the wave function of an N-particle quantum system in first quantization would require the introduction of a SymmetricSpace{S, N} or a AntiSymmetricSpace{S, N} for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of V^N, where V::S represents the Hilbert space of the single particle system. Other scientific fields, like general relativity, might also benefit from tensors living in subspace with certain symmetries under specific index permutations.","category":"section"},{"location":"man/spaces/#ss_spaceops","page":"Vector spaces","title":"More operations with vector spaces","text":"Vector spaces of the same spacetype can be given a partial order, based on whether there exist injective morphisms (a.k.a monomorphisms) or surjective morphisms (a.k.a.  epimorphisms) between them. In particular, we define ismonomorphic(V1, V2), with Unicode synonym V1 ‚âæ V2 (obtained as \\precsim+TAB), to express whether there exist monomorphisms in V1 ‚Üí V2. Similarly, we define isepimorphic(V1, V2), with Unicode synonym V1 ‚âø V2 (obtained as \\succsim+TAB), to express whether there exist epimorphisms in V1 ‚Üí V2. Finally, we define isisomorphic(V1, V2), with Unicode alternative V1 ‚âÖ V2 (obtained as \\cong+TAB), to express whether there exist isomorphism in V1 ‚Üí V2. In particular V1 ‚âÖ V2 if and only if V1 ‚âæ V2 && V1 ‚âø V2.\n\nFor completeness, we also export the strict comparison operators ‚â∫ and ‚âª (\\prec+TAB and \\succ+TAB), with definitions\n\n‚â∫(V1::VectorSpace, V2::VectorSpace) = V1 ‚âæ V2 && !(V1 ‚âø V2)\n‚âª(V1::VectorSpace, V2::VectorSpace) = V1 ‚âø V2 && !(V1 ‚âæ V2)\n\nHowever, as we expect these to be less commonly used, no ASCII alternative is provided.\n\nIn the context of InnerProductStyle(V) <: EuclideanInnerProduct, V1 ‚âæ V2 implies that there exists isometries W  V1  V2 such that W^  W = mathrmid_V1, while V1 ‚âÖ V2 implies that there exist unitaries U  V1  V2 such that U^  U = mathrmid_V1 and U  U^ = mathrmid_V2.\n\nNote that spaces that are isomorphic are not necessarily equal. One can be a dual space, and the other a normal space, or one can be an instance of ProductSpace, while the other is an ElementarySpace. There will exist (infinitely) many isomorphisms between the corresponding spaces, but in general none of those will be canonical.\n\nThere are also a number of convenience functions to create isomorphic spaces. The function fuse(V1, V2, ...) or fuse(V1 ‚äó V2 ‚äó ...) returns an elementary space that is isomorphic to V1 ‚äó V2 ‚äó ....","category":"section"},{"location":"man/spaces/#ss_homspaces","page":"Vector spaces","title":"Space of morphisms","text":"As mentioned in the introduction, we define tensor maps as linear maps from a ProductSpace domain to a ProductSpace codomain. The set of all tensor maps with a fixed domain and codomain constitutes a vector space, which we represent with the HomSpace type.\n\nAside from the standard constructor, a HomSpace instance can be created as either domain ‚Üí codomain or codomain ‚Üê domain (where the arrows are obtained as \\to+TAB or \\leftarrow+TAB, and as \\rightarrow+TAB respectively). The reason for first listing the codomain and than the domain will become clear in the section on tensor maps.\n\nNote that HomSpace is not a subtype of VectorSpace, i.e. we restrict the latter to encode all spaces and generalizations thereof (i.e. objects in linear monoidal categories) that are associated with the indices and the domain and codomain of a tensor map. Even when these generalizations are no longer strictly vector spaces and have unconventional properties (such as non-integer dimensions), the space of tensor maps (homomorphisms) between a given domain and codomain, represented by a HomSpace instance, is always a vector space in the strict mathematical sense (with in particular an integer dimension). Because HomSpace and the different subtypes of VectorSpace represent very different mathematical concepts that do not directly interact, we have chosen to keep them separate in the type hierarchy.\n\nFurthermore, on these HomSpace instances, we define a number of useful methods that are a precursor to the corresponding methods that we will define to manipulate the actual tensors, as illustrated in the following example:\n\nW = ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üí ‚ÑÇ^3 ‚äó dual(‚ÑÇ^4)\nfield(W)\ndual(W)\nadjoint(W)\nspacetype(W)\nspacetype(typeof(W))\nW[1]\nW[2]\nW[3]\nW[4]\ndim(W)\ndomain(W)\ncodomain(W)\nnumin(W)\nnumout(W)\nnumind(W)\nnumind(W) == numin(W) + numout(W)\npermute(W, ((2, 3), (1, 4)))\nflip(W, 3)\ninsertleftunit(W, 3)\ninsertrightunit(W, 2)\nremoveunit(insertrightunit(W, 2), 3)\nTensorKit.compose(W, adjoint(W))\n\nNote that indexing W follows an order that first targets the spaces in the codomain, followed by the dual of the spaces in the domain. This particular convention is useful in combination with the instances of type TensorMap, which represent the actual morphisms living in such a HomSpace. Also note that dim(W) is here given by the product of the dimensions of the individual spaces, but that this is no longer true once symmetries are involved. At any time will dim(::HomSpace) represent the number of linearly independent morphisms in this space, or thus, the number of independent components that a corresponding TensorMap object will have.\n\nA complete list of methods defined on HomSpace instances together with the corresponding documentation is provided in the library section on Vector spaces.","category":"section"},{"location":"man/spaces/#TensorKitSectors.dim-Tuple{ElementarySpace}-man-spaces","page":"Vector spaces","title":"TensorKitSectors.dim","text":"dim(V::VectorSpace) -> Int\n\nReturn the total dimension of the vector space V as an Int.\n\n\n\n\n\ndim(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) where {S<:ElementarySpace}\n-> Int\n\nReturn the total degeneracy dimension corresponding to a tuple of sectors for each of the spaces in the tensor product, obtained as prod(dims(P, s))`.\n\n\n\n\n\n","category":"method"},{"location":"man/spaces/#TensorKit.field-Tuple{ElementarySpace}-man-spaces","page":"Vector spaces","title":"TensorKit.field","text":"field(a) -> Type{ùîΩ <: Field}\nfield(::Type{T}) -> Type{ùîΩ <: Field}\n\nReturn the type of field over which object a (e.g. a vector space or a tensor) is defined. This also works in type domain.\n\n\n\n\n\n","category":"method"},{"location":"man/spaces/#TensorKitSectors.dual-Tuple{S} where S<:ElementarySpace-man-spaces","page":"Vector spaces","title":"TensorKitSectors.dual","text":"dual(V::VectorSpace) -> VectorSpace\n\nReturn the dual space of V; also obtained via V'. This should satisfy dual(dual(V)) == V. It is assumed that typeof(V) == typeof(V').\n\n\n\n\n\n","category":"method"},{"location":"man/spaces/#Base.conj-Tuple{S} where S<:ElementarySpace-man-spaces","page":"Vector spaces","title":"Base.conj","text":"conj(V::S) where {S<:ElementarySpace} -> S\n\nReturn the conjugate space of V. This should satisfy conj(conj(V)) == V.\n\nFor field(V)==‚Ñù, conj(V) == V. It is assumed that typeof(V) == typeof(conj(V)).\n\n\n\n\n\n","category":"method"},{"location":"man/spaces/#TensorKit.InnerProductStyle-man-spaces","page":"Vector spaces","title":"TensorKit.InnerProductStyle","text":"abstract type InnerProductStyle end\nInnerProductStyle(V::VectorSpace) -> ::InnerProductStyle\nInnerProductStyle(S::Type{<:VectorSpace}) -> ::InnerProductStyle\n\nTrait to describe wether vector spaces exhibit an inner product structure, a.k.a. a unitary structure, which can take the following values:\n\nEuclideanInnerProduct(): the metric is the identity, making dual and conjugate spaces equivalent\nNoInnerProduct(): no metric and thus no relation between dual(V) or conj(V)\n\nFurthermore, EuclideanInnerProduct is a subtype of HasInnerProduct, indicating that an inner product exists, and an isomorphism between the dual space and the conjugate space can be constructed. New inner product styles can be defined that subtype HasInnerProduct, for example to work with vector spaces with non-trivial metrics. However, at the moment TensorKit does not provide built-in support for such non-standard inner products.\n\n\n\n\n\n","category":"type"},{"location":"man/spaces/#TensorKit.GeneralSpace-man-spaces","page":"Vector spaces","title":"TensorKit.GeneralSpace","text":"struct GeneralSpace{ùîΩ} <: ElementarySpace\nGeneralSpace{ùîΩ}(d::Integer = 0; dual::Bool = false, conj::Bool = false)\n\nA finite-dimensional space over an arbitrary field ùîΩ without additional structure. It is thus characterized by its dimension, and whether or not it is the dual and/or conjugate space. For a real field ùîΩ, the space and its conjugate are the same.\n\n\n\n\n\n","category":"type"},{"location":"man/spaces/#TensorKit.CartesianSpace-man-spaces","page":"Vector spaces","title":"TensorKit.CartesianSpace","text":"struct CartesianSpace <: ElementarySpace\nCartesianSpace(d::Integer = 0; dual = false)\n‚Ñù^d\n\nA real Euclidean space ‚Ñù^d. CartesianSpace has no additonal structure and is completely characterised by its dimension d. A dual keyword argument is accepted for compatibility with other space constructors, but is ignored since the dual of a Cartesian space is isomorphic to itself. This is the vector space that is implicitly assumed in most of matrix algebra.\n\n\n\n\n\n","category":"type"},{"location":"man/spaces/#TensorKit.ComplexSpace-man-spaces","page":"Vector spaces","title":"TensorKit.ComplexSpace","text":"struct ComplexSpace <: ElementarySpace\nComplexSpace(d::Integer = 0; dual = false)\n‚ÑÇ^d\n\nA standard complex vector space ‚ÑÇ^d with Euclidean inner product and no additional structure. It is completely characterised by its dimension and whether its the normal space or its dual (which is canonically isomorphic to the conjugate space).\n\n\n\n\n\n","category":"type"},{"location":"man/spaces/#TensorKit.ProductSpace-man-spaces","page":"Vector spaces","title":"TensorKit.ProductSpace","text":"struct ProductSpace{S <: ElementarySpace, N} <: CompositeSpace{S}\nProductSpace(spaces::NTuple{N, S}) where {S <: ElementarySpace, N}\n\nA ProductSpace is a tensor product space of N vector spaces of type S <: ElementarySpace. Only tensor products between ElementarySpace objects of the same type are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/spaces/#TensorKit.HomSpace-man-spaces","page":"Vector spaces","title":"TensorKit.HomSpace","text":"struct HomSpace{S<:ElementarySpace, P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}\nHomSpace(codomain::CompositeSpace{S}, domain::CompositeSpace{S}) where {S<:ElementarySpace}\n\nRepresents the linear space of morphisms with codomain of type P1 and domain of type P2. Note that HomSpace is not a subtype of VectorSpace, i.e. we restrict the latter to denote categories and their objects, and keep HomSpace distinct.\n\n\n\n\n\n","category":"type"},{"location":"man/tensormanipulations/#s_tensormanipulations","page":"Manipulating tensors","title":"Manipulating tensors","text":"","category":"section"},{"location":"man/tensormanipulations/#ss_tensor_linalg","page":"Manipulating tensors","title":"Vector space and linear algebra operations","text":"AbstractTensorMap instances t represent linear maps, i.e. homomorphisms in a ùïú-linear category, just like matrices. To a large extent, they follow the interface of Matrix in Julia's LinearAlgebra standard library. Many methods from LinearAlgebra are (re)exported by TensorKit.jl, and can then us be used without using LinearAlgebra explicitly. In all of the following methods, the implementation acts directly on the underlying matrix blocks (typically using the same method) and never needs to perform any basis transforms.\n\nIn particular, AbstractTensorMap instances can be composed, provided the domain of the first object coincides with the codomain of the second. Composing tensor maps uses the regular multiplication symbol as in t = t1 * t2, which is also used for matrix multiplication. TensorKit.jl also supports (and exports) the mutating method mul!(t, t1, t2). We can then also try to invert a tensor map using inv(t), though this can only exist if the domain and codomain are isomorphic, which can e.g. be checked as fuse(codomain(t)) == fuse(domain(t)). If the inverse is composed with another tensor t2, we can use the syntax t1 \\ t2 or t2 / t1. However, this syntax also accepts instances t1 whose domain and codomain are not isomorphic, and then amounts to pinv(t1), the Moore-Penrose pseudoinverse. This, however, is only really justified as minimizing the least squares problem if InnerProductStyle(t) <: EuclideanProduct.\n\nAbstractTensorMap instances behave themselves as vectors (i.e. they are ùïú-linear) and so they can be multiplied by scalars and, if they live in the same space, i.e. have the same domain and codomain, they can be added to each other. There is also a zero(t), the additive identity, which produces a zero tensor with the same domain and codomain as t. In addition, TensorMap supports basic Julia methods such as fill! and copy!, as well as copy(t) to create a copy with independent data. Aside from basic + and * operations, TensorKit.jl reexports a number of efficient in-place methods from LinearAlgebra, such as axpy! (for y ‚Üê Œ± * x + y), axpby! (for y ‚Üê Œ± * x + Œ≤ * y), lmul! and rmul! (for y ‚Üê Œ± * y and y ‚Üê y * Œ±, which is typically the same) and mul!, which can also be used for out-of-place scalar multiplication y ‚Üê Œ± * x.\n\nFor S = spacetype(t) where InnerProductStyle(S) <: EuclideanProduct, we can compute norm(t), and for two such instances, the inner product dot(t1, t2), provided t1 and t2 have the same domain and codomain. Furthermore, there is normalize(t) and normalize!(t) to return a scaled version of t with unit norm. These operations should also exist for InnerProductStyle(S) <: HasInnerProduct, but require an interface for defining a custom inner product in these spaces. Currently, there is no concrete subtype of HasInnerProduct that is not an EuclideanProduct. In particular, CartesianSpace, ComplexSpace and GradedSpace all have InnerProductStyle(S) <: EuclideanProduct.\n\nWith tensors that have InnerProductStyle(t) <: EuclideanProduct there is associated an adjoint operation, given by adjoint(t) or simply t', such that domain(t') == codomain(t) and codomain(t') == domain(t). Note that for an instance t::TensorMap{S, N‚ÇÅ, N‚ÇÇ}, t' is simply stored in a wrapper called AdjointTensorMap{S, N‚ÇÇ, N‚ÇÅ}, which is another subtype of AbstractTensorMap. This should be mostly invisible to the user, as all methods should work for this type as well. It can be hard to reason about the index order of t', i.e. index i of t appears in t' at index position j = TensorKit.adjointtensorindex(t, i), where the latter method is typically not necessary and hence unexported. There is also a plural TensorKit.adjointtensorindices to convert multiple indices at once. Note that, because the adjoint interchanges domain and codomain, we have space(t', j) == space(t, i)'.\n\nAbstractTensorMap instances can furthermore be tested for exact (t1 == t2) or approximate (t1 ‚âà t2) equality, though the latter requires that norm can be computed.\n\nWhen tensor map instances are endomorphisms, i.e. they have the same domain and codomain, there is a multiplicative identity which can be obtained as one(t) or one!(t), where the latter overwrites the contents of t. The multiplicative identity on a space V can also be obtained using id(A, V) as discussed above, such that for a general homomorphism t‚Ä≤, we have t‚Ä≤ == id(codomain(t‚Ä≤)) * t‚Ä≤ == t‚Ä≤ * id(domain(t‚Ä≤)). Returning to the case of endomorphisms t, we can compute the trace via tr(t) and exponentiate them using exp(t), or if the contents of t can be destroyed in the process, exp!(t). Furthermore, there are a number of tensor factorizations for both endomorphisms and general homomorphism that we discuss below.\n\nFinally, there are a number of operations that also belong in this paragraph because of their analogy to common matrix operations. The tensor product of two TensorMap instances t1 and t2 is obtained as t1 ‚äó t2 and results in a new TensorMap with codomain(t1 ‚äó t2) = codomain(t1) ‚äó codomain(t2) and domain(t1 ‚äó t2) = domain(t1) ‚äó domain(t2). If we have two TensorMap{T, S, N, 1} instances t1 and t2 with the same codomain, we can combine them in a way that is analogous to hcat, i.e. we stack them such that the new tensor catdomain(t1, t2) has also the same codomain, but has a domain which is domain(t1) ‚äï domain(t2). Similarly, if t1 and t2 are of type TensorMap{T, S, 1, N} and have the same domain, the operation catcodomain(t1, t2) results in a new tensor with the same domain and a codomain given by codomain(t1) ‚äï codomain(t2), which is the analogy of vcat. Note that direct sum only makes sense between ElementarySpace objects, i.e. there is no way to give a tensor product meaning to a direct sum of tensor product spaces.\n\nTime for some more examples:\n\nusing TensorKit # hide\nV1 = ‚ÑÇ^2\nt = randn(V1 ‚Üê V1 ‚äó V1 ‚äó V1)\nt == t + zero(t) == t * id(domain(t)) == id(codomain(t)) * t\nt2 = randn(ComplexF64, codomain(t), domain(t));\ndot(t2, t)\ntr(t2' * t)\ndot(t2, t) ‚âà dot(t', t2')\ndot(t2, t2)\nnorm(t2)^2\nt3 = copy!(similar(t, ComplexF64), t);\nt3 == t\nrmul!(t3, 0.8);\nt3 ‚âà 0.8 * t\naxpby!(0.5, t2, 1.3im, t3);\nt3 ‚âà 0.5 * t2 + 0.8 * 1.3im * t\nt4 = randn(fuse(codomain(t)), codomain(t));\nt5 = TensorMap{Float64}(undef, fuse(codomain(t)), domain(t));\nmul!(t5, t4, t) == t4 * t\ninv(t4) * t4 ‚âà id(codomain(t))\nt4 * inv(t4) ‚âà id(fuse(codomain(t)))\nt4 \\ (t4 * t) ‚âà t\nt6 = randn(ComplexF64, V1, codomain(t));\nnumout(t4) == numout(t6) == 1\nt7 = catcodomain(t4, t6);\nforeach(println, (codomain(t4), codomain(t6), codomain(t7)))\nnorm(t7) ‚âà sqrt(norm(t4)^2 + norm(t6)^2)\nt8 = t4 ‚äó t6;\nforeach(println, (codomain(t4), codomain(t6), codomain(t8)))\nforeach(println, (domain(t4), domain(t6), domain(t8)))\nnorm(t8) ‚âà norm(t4)*norm(t6)","category":"section"},{"location":"man/tensormanipulations/#ss_indexmanipulation","page":"Manipulating tensors","title":"Index manipulations","text":"In many cases, the bipartition of tensor indices (i.e. ElementarySpace instances) between the codomain and domain is not fixed throughout the different operations that need to be performed on that tensor map, i.e. we want to use the duality to move spaces from domain to codomain and vice versa. Furthermore, we want to use the braiding to reshuffle the order of the indices.\n\nFor this, we use an interface that is closely related to that for manipulating splitting- fusion tree pairs, namely braid and permute, with the interface\n\nbraid(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, (p1, p2)::Index2Tuple{N‚ÇÅ‚Ä≤,N‚ÇÇ‚Ä≤}, levels::IndexTuple{N‚ÇÅ+N‚ÇÇ,Int})\n\nand\n\npermute(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, (p1, p2)::Index2Tuple{N‚ÇÅ‚Ä≤,N‚ÇÇ‚Ä≤}; copy = false)\n\nboth of which return an instance of AbstractTensorMap{T, S, N‚ÇÅ‚Ä≤, N‚ÇÇ‚Ä≤}.\n\nIn these methods, p1 and p2 specify which of the original tensor indices ranging from 1 to N‚ÇÅ + N‚ÇÇ make up the new codomain (with N‚ÇÅ‚Ä≤ spaces) and new domain (with N‚ÇÇ‚Ä≤ spaces). Hence, (p1..., p2...) should be a valid permutation of 1:(N‚ÇÅ + N‚ÇÇ). Note that, throughout TensorKit.jl, permutations are always specified using tuples of Ints, for reasons of type stability. For braid, we also need to specify levels or depths for each of the indices of the original tensor, which determine whether indices will braid over or underneath each other (use the braiding or its inverse). We refer to the section on manipulating fusion trees for more details.\n\nWhen BraidingStyle(sectortype(t)) isa SymmetricBraiding, we can use the simpler interface of permute, which does not require the argument levels. permute accepts a keyword argument copy. When copy == true, the result will be a tensor with newly allocated data that can independently be modified from that of the input tensor t. When copy takes the default value false, permute can try to return the result in a way that it shares its data with the input tensor t, though this is only possible in specific cases (e.g. when sectortype(S) == Trivial and (p1..., p2...) = (1:(N‚ÇÅ+N‚ÇÇ)...)).\n\nBoth braid and permute come in a version where the result is stored in an already existing tensor, i.e. braid!(tdst, tsrc, (p1, p2), levels) and permute!(tdst, tsrc, (p1, p2)).\n\nAnother operation that belongs under index manipulations is taking the transpose of a tensor, i.e. LinearAlgebra.transpose(t) and LinearAlgebra.transpose!(tdst, tsrc), both of which are reexported by TensorKit.jl. Note that transpose(t) is not simply equal to reshuffling domain and codomain with braid(t, (1:(N‚ÇÅ+N‚ÇÇ)...), reverse(domainind(tsrc)), reverse(codomainind(tsrc)))). Indeed, the graphical representation (where we draw the codomain and domain as a single object), makes clear that this introduces an additional (inverse) twist, which is then compensated in the transpose implementation.\n\n<img src=\"../img/tensor-transpose.svg\" alt=\"transpose\" class=\"color-invertible\"/>\n\nIn categorical language, the reason for this extra twist is that we use the left coevaluation Œ∑, but the right evaluation tildeœµ, when repartitioning the indices between domain and codomain.\n\nThere are a number of other index related manipulations. We can apply a twist (or inverse twist) to one of the tensor map indices via twist(t, i; inv = false) or twist!(t, i; inv = false). Note that the latter method does not store the result in a new destination tensor, but just modifies the tensor t in place. Twisting several indices simultaneously can be obtained by using the defining property\n\nŒ∏_VW = œÑ_WV  (Œ∏_W  Œ∏_V)  œÑ_VW = (Œ∏_V  Œ∏_W)  œÑ_WV  œÑ_VW\n\nbut is currently not implemented explicitly.\n\nFor all sector types I with BraidingStyle(I) == Bosonic(), all twists are 1 and thus have no effect. Let us start with some examples, in which we illustrate that, albeit permute might act highly non-trivial on the fusion trees and on the corresponding data, after conversion to a regular Array (when possible), it just acts like permutedims\n\ndomain(t) ‚Üí codomain(t)\nta = convert(Array, t);\nt‚Ä≤ = permute(t, (1, 2, 3, 4));\ndomain(t‚Ä≤) ‚Üí codomain(t‚Ä≤)\nconvert(Array, t‚Ä≤) ‚âà ta\nt‚Ä≤‚Ä≤ = permute(t, ((4, 2, 3), (1,)));\ndomain(t‚Ä≤‚Ä≤) ‚Üí codomain(t‚Ä≤‚Ä≤)\nconvert(Array, t‚Ä≤‚Ä≤) ‚âà permutedims(ta, (4, 2, 3, 1))\ntranspose(t)\nconvert(Array, transpose(t)) ‚âà permutedims(ta, (4, 3, 2, 1))\ndot(t2, t) ‚âà dot(transpose(t2), transpose(t))\ntranspose(transpose(t)) ‚âà t\ntwist(t, 3) ‚âà t\n\nNote that transpose acts like one would expect on a TensorMap{T, S, 1, 1}. On a TensorMap{T, S, N‚ÇÅ, N‚ÇÇ}, because transpose replaces the codomain with the dual of the domain, which has its tensor product operation reversed, this in the end amounts in a complete reversal of all tensor indices when representing it as a plain multi-dimensional Array. Also, note that we have not defined the conjugation of TensorMap instances. One definition that one could think of is conj(t) = adjoint(transpose(t)). However note that codomain(adjoint(tranpose(t))) == domain(transpose(t)) == dual(codomain(t)) and similarly domain(adjoint(tranpose(t))) == dual(domain(t)), where dual of a ProductSpace is composed of the dual of the ElementarySpace instances, in reverse order of tensor product. This might be very confusing, and as such we leave tensor conjugation undefined. However, note that we have a conjugation syntax within the context of tensor contractions.\n\nTo show the effect of twist, we now consider a type of sector I for which BraidingStyle(I) != Bosonic(). In particular, we use FibonacciAnyon. We cannot convert the resulting TensorMap to an Array, so we have to rely on indirect tests to verify our results.\n\nV1 = GradedSpace{FibonacciAnyon}(:I => 3, :œÑ => 2)\nV2 = GradedSpace{FibonacciAnyon}(:I => 2, :œÑ => 1)\nm = randn(Float32, V1, V2)\ntranspose(m)\ntwist(braid(m, ((2,), (1,)), (1, 2)), 1)\nt1 = randn(V1 * V2', V2 * V1);\nt2 = randn(ComplexF64, V1 * V2', V2 * V1);\ndot(t1, t2) ‚âà dot(transpose(t1), transpose(t2))\ntranspose(transpose(t1)) ‚âà t1\n\nA final operation that one might expect in this section is to fuse or join indices, and its inverse, to split a given index into two or more indices. For a plain tensor (i.e. with sectortype(t) == Trivial) amount to the equivalent of reshape on the multidimensional data. However, this represents only one possibility, as there is no canonically unique way to embed the tensor product of two spaces V1 ‚äó V2 in a new space V = fuse(V1 ‚äó V2). Such a mapping can always be accompagnied by a basis transform. However, one particular choice is created by the function isomorphism, or for EuclideanProduct spaces, unitary. Hence, we can join or fuse two indices of a tensor by first constructing u = unitary(fuse(space(t, i) ‚äó space(t, j)), space(t, i) ‚äó space(t, j)) and then contracting this map with indices i and j of t, as explained in the section on contracting tensors. Note, however, that a typical algorithm is not expected to often need to fuse and split indices, as e.g. tensor factorizations can easily be applied without needing to reshape or fuse indices first, as explained in the next section.","category":"section"},{"location":"man/tensormanipulations/#ss_tensor_factorization","page":"Manipulating tensors","title":"Tensor factorizations","text":"As tensors are linear maps, they suport various kinds of factorizations. These functions all interpret the provided AbstractTensorMap instances as a map from domain to codomain, which can be thought of as reshaping the tensor into a matrix according to the current bipartition of the indices.\n\nTensorKit's factorizations are provided by MatrixAlgebraKit.jl, which is used to supply both the interface, as well as the implementation of the various operations on the blocks of data. For specific details on the provided functionality, we refer to its documentation page.\n\nFinally, note that each of the factorizations takes the current partition of domain and codomain as the axis along which to matricize and perform the factorization. In order to obtain factorizations according to a different bipartition of the indices, we can use any of the previously mentioned index manipulations before the factorization.\n\nSome examples to conclude this section\n\nV1 = SU‚ÇÇSpace(0 => 2, 1/2 => 1)\nV2 = SU‚ÇÇSpace(0 => 1, 1/2 => 1, 1 => 1)\n\nt = randn(V1 ‚äó V1, V2);\nU, S, Vh = svd_compact(t);\nt ‚âà U * S * Vh\nD, V = eigh_full(t' * t);\nD ‚âà S * S\nU' * U ‚âà id(domain(U))\nS\n\nQ, R = left_orth(t; alg = :svd);\nQ' * Q ‚âà id(domain(Q))\nt ‚âà Q * R\n\nU2, S2, Vh2, Œµ = svd_trunc(t; trunc = truncspace(V1));\nVh2 * Vh2' ‚âà id(codomain(Vh2))\nS2\nŒµ ‚âà norm(block(S, Irrep[SU‚ÇÇ](1))) * sqrt(dim(Irrep[SU‚ÇÇ](1)))\n\nL, Q = right_orth(permute(t, ((1,), (2, 3))));\ncodomain(L), domain(L), domain(Q)\nQ * Q'\nP = Q' * Q;\nP ‚âà P * P\nt‚Ä≤ = permute(t, ((1,), (2, 3)));\nt‚Ä≤ ‚âà t‚Ä≤ * P","category":"section"},{"location":"man/tensormanipulations/#ss_tensor_contraction","page":"Manipulating tensors","title":"Bosonic tensor contractions and tensor networks","text":"One of the most important operation with tensor maps is to compose them, more generally known as contracting them. As mentioned in the section on category theory, a typical composition of maps in a ribbon category can graphically be represented as a planar arrangement of the morphisms (i.e. tensor maps, boxes with lines eminating from top and bottom, corresponding to source and target, i.e. domain and codomain), where the lines connecting the source and targets of the different morphisms should be thought of as ribbons, that can braid over or underneath each other, and that can twist. Technically, we can embed this diagram in ‚Ñù  01 and attach all the unconnected line endings corresponding objects in the source at some position (x0) for x‚Ñù, and all line endings corresponding to objects in the target at some position (x1). The resulting morphism is then invariant under what is known as framed three-dimensional isotopy, i.e. three-dimensional rearrangements of the morphism that respect the rules of boxes connected by ribbons whose open endings are kept fixed. Such a two-dimensional diagram cannot easily be encoded in a single line of code.\n\nHowever, things simplify when the braiding is symmetric (such that over- and under- crossings become equivalent, i.e. just crossings), and when twists, i.e. self-crossings in this case, are trivial. This amounts to BraidingStyle(I) == Bosonic() in the language of TensorKit.jl, and is true for any subcategory of mathbfVect, i.e. ordinary tensors, possibly with some symmetry constraint. The case of mathbfSVect and its subcategories, and more general categories, are discussed below.\n\nIn the case of trivial twists, we can deform the diagram such that we first combine every morphism with a number of coevaluations Œ∑ so as to represent it as a tensor, i.e. with a trivial domain. We can then rearrange the morphism to be all ligned up horizontally, where the original morphism compositions are now being performed by evaluations œµ. This process will generate a number of crossings and twists, where the latter can be omitted because they act trivially. Similarly, double crossings can also be omitted. As a consequence, the diagram, or the morphism it represents, is completely specified by the tensors it is composed of, and which indices between the different tensors are connect, via the evaluation œµ, and which indices make up the source and target of the resulting morphism. If we also compose the resulting morphisms with coevaluations so that it has a trivial domain, we just have one type of unconnected lines, henceforth called open indices. We sketch such a rearrangement in the following picture\n\n<img src=\"../img/tensor-bosoniccontraction.svg\" alt=\"tensor unitary\" class=\"color-invertible\"/>\n\nHence, we can now specify such a tensor diagram, henceforth called a tensor contraction or also tensor network, using a one-dimensional syntax that mimicks abstract index notation and specifies which indices are connected by the evaluation map using Einstein's summation conventation. Indeed, for BraidingStyle(I) == Bosonic(), such a tensor contraction can take the same format as if all tensors were just multi-dimensional arrays. For this, we rely on the interface provided by the package TensorOperations.jl.\n\nThe above picture would be encoded as\n\n@tensor E[a, b, c, d, e] := A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]\n\nor\n\n@tensor E[:] := A[1, 2, -4, 3] * B[4, 5, -3, 3] * C[1, -5, 4, -2] * D[-1, 2, 5]\n\nwhere the latter syntax is known as NCON-style, and labels the unconnected or outgoing indices with negative integers, and the contracted indices with positive integers.\n\nA number of remarks are in order. TensorOperations.jl accepts both integers and any valid variable name as dummy label for indices, and everything in between [ ] is not resolved in the current context but interpreted as a dummy label. Here, we label the indices of a TensorMap, like A::TensorMap{T, S, N‚ÇÅ, N‚ÇÇ}, in a linear fashion, where the first position corresponds to the first space in codomain(A), and so forth, up to position N‚ÇÅ. Index N‚ÇÅ + 1 then corresponds to the first space in domain(A). However, because we have applied the coevaluation Œ∑, it actually corresponds to the corresponding dual space, in accordance with the interface of space(A, i) that we introduced above, and as indiated by the dotted box around A in the above picture. The same holds for the other tensor maps. Note that our convention also requires that we braid indices that we brought from the domain to the codomain, and so this is only unambiguous for a symmetric braiding, where there is a unique way to permute the indices.\n\nWith the current syntax, we create a new object E because we use the definition operator :=. Furthermore, with the current syntax, it will be a Tensor, i.e. it will have a trivial domain, and correspond to the dotted box in the picture above, rather than the actual morphism E. We can also directly define E with the correct codomain and domain by rather using\n\n@tensor E[a b c;d e] := A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]\n\nor\n\n@tensor E[(a, b, c);(d, e)] := A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]\n\nwhere the latter syntax can also be used when the codomain is empty. When using the assignment operator =, the TensorMap E is assumed to exist and the contents will be written to the currently allocated memory. Note that for existing tensors, both on the left hand side and right hand side, trying to specify the indices in the domain and the codomain seperately using the above syntax, has no effect, as the bipartition of indices are already fixed by the existing object. Hence, if E has been created by the previous line of code, all of the following lines are now equivalent\n\n@tensor E[(a, b, c);(d, e)] = A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]\n@tensor E[a, b, c, d, e] = A[v w d; x] * B[(y, z, c); (x, )] * C[v e y; b] * D[a, w, z]\n@tensor E[a b; c d e] = A[v; w d x] * B[y, z, c, x] * C[v, e, y, b] * D[a w; z]\n\nand none of those will or can change the partition of the indices of E into its codomain and its domain.\n\nTwo final remarks are in order. Firstly, the order of the tensors appearing on the right hand side is irrelevant, as we can reorder them by using the allowed moves of the Penrose graphical calculus, which yields some crossings and a twist. As the latter is trivial, it can be omitted, and we just use the same rules to evaluate the newly ordered tensor network. For the particular case of matrix-matrix multiplication, which also captures more general settings by appropriotely combining spaces into a single line, we indeed find\n\n<img src=\"../img/tensor-contractionreorder.svg\" alt=\"tensor contraction reorder\" class=\"color-invertible\"/>\n\nor thus, the following two lines of code yield the same result\n\n@tensor C[i, j] := B[i, k] * A[k, j]\n@tensor C[i, j] := A[k, j] * B[i, k]\n\nReordering of tensors can be used internally by the @tensor macro to evaluate the contraction in a more efficient manner. In particular, the NCON-style of specifying the contraction gives the user control over the order, and there are other macros, such as @tensoropt, that try to automate this process. There is also an @ncon macro and ncon function, an we recommend reading the manual of TensorOperations.jl to learn more about the possibilities and how they work.\n\nA final remark involves the use of adjoints of tensors. The current framework is such that the user should not be too worried about the actual bipartition into codomain and domain of a given TensorMap instance. Indeed, for tensor contractions the @tensor macro figures out the correct manipulations automatically. However, when wanting to use the adjoint of an instance t::TensorMap{T, S, N‚ÇÅ, N‚ÇÇ}, the resulting adjoint(t) is an AbstractTensorMap{T, S, N‚ÇÇ, N‚ÇÅ} and one needs to know the values of N‚ÇÅ and N‚ÇÇ to know exactly where the ith index of t will end up in adjoint(t), and hence the index order of t'. Within the @tensor macro, one can instead use conj() on the whole index expression so as to be able to use the original index ordering of t. For example, for TensorMap{T, S, 1, 1} instances, this yields exactly the equivalence one expects, namely one between the following two expressions:\n\n@tensor C[i, j] := B'[i, k] * A[k, j]\n@tensor C[i, j] := conj(B[k, i]) * A[k, j]\n\nFor e.g. an instance A::TensorMap{T, S, 3, 2}, the following two syntaxes have the same effect within an @tensor expression: conj(A[a, b, c, d, e]) and A'[d, e, a, b, c].\n\nSome examples:","category":"section"},{"location":"man/tensormanipulations/#Fermionic-tensor-contractions","page":"Manipulating tensors","title":"Fermionic tensor contractions","text":"TODO","category":"section"},{"location":"man/tensormanipulations/#Anyonic-tensor-contractions","page":"Manipulating tensors","title":"Anyonic tensor contractions","text":"TODO","category":"section"},{"location":"lib/fusiontrees/#Fusion-trees","page":"Fusion trees","title":"Fusion trees","text":"","category":"section"},{"location":"lib/fusiontrees/#Type-hierarchy","page":"Fusion trees","title":"Type hierarchy","text":"","category":"section"},{"location":"lib/fusiontrees/#Methods-for-defining-and-generating-fusion-trees","page":"Fusion trees","title":"Methods for defining and generating fusion trees","text":"","category":"section"},{"location":"lib/fusiontrees/#Methods-for-manipulating-fusion-trees","page":"Fusion trees","title":"Methods for manipulating fusion trees","text":"For manipulating single fusion trees, the following internal methods are defined:\n\nThese can be composed to implement elementary manipulations of fusion-splitting tree pairs, according to the following methods\n\n# TODO: add documentation for the following methods\nTensorKit.bendright\nTensorKit.bendleft\nTensorKit.foldright\nTensorKit.foldleft\nTensorKit.cycleclockwise\nTensorKit.cycleanticlockwise\n\nFinally, these are used to define large manipulations of fusion-splitting tree pairs, which are then used in the index manipulation of AbstractTensorMap objects. The following methods defined on fusion splitting tree pairs have an associated definition for tensors.","category":"section"},{"location":"lib/fusiontrees/#TensorKit.FusionTree","page":"Fusion trees","title":"TensorKit.FusionTree","text":"struct FusionTree{I, N, M, L}\n\nRepresents a fusion tree of sectors of type I<:Sector, fusing (or splitting) N uncoupled sectors to a coupled sector. It actually represents a splitting tree, but fusion tree is a more common term.\n\nFields\n\nuncoupled::NTuple{N,I}: the uncoupled sectors coming out of the splitting tree, before the possible ùëç isomorphism (see isdual).\ncoupled::I: the coupled sector.\nisdual::NTuple{N,Bool}: indicates whether a ùëç isomorphism is present (true) or not (false) for each uncoupled sector.\ninnerlines::NTuple{M,I}: the labels of the M=max(0, N-2) inner lines of the splitting tree.\nvertices::NTuple{L,Int}: the integer values of the L=max(0, N-1) vertices of the splitting tree. If FusionStyle(I) isa MultiplicityFreeFusion, then vertices is simply equal to the constant value ntuple(n->1, L).\n\n\n\n\n\n","category":"type"},{"location":"lib/fusiontrees/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{NTuple{N, I}, I, NTuple{N, Bool}}} where {N, I<:Sector}","page":"Fusion trees","title":"TensorKit.fusiontrees","text":"fusiontrees(uncoupled::NTuple{N,I}[,\n    coupled::I=unit(I)[, isdual::NTuple{N,Bool}=ntuple(n -> false, length(uncoupled))]])\n    where {N,I<:Sector} -> FusionTreeIterator{I,N,I}\n\nReturn an iterator over all fusion trees with a given coupled sector label coupled and uncoupled sector labels and isomorphisms uncoupled and isdual respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#TensorKit.insertat","page":"Fusion trees","title":"TensorKit.insertat","text":"insertat(f::FusionTree{I, N‚ÇÅ}, i::Int, f‚ÇÇ::FusionTree{I, N‚ÇÇ})\n-> <:AbstractDict{<:FusionTree{I, N‚ÇÅ+N‚ÇÇ-1}, <:Number}\n\nAttach a fusion tree f‚ÇÇ to the uncoupled leg i of the fusion tree f‚ÇÅ and bring it into a linear combination of fusion trees in standard form. This requires that f‚ÇÇ.coupled == f‚ÇÅ.uncoupled[i] and f‚ÇÅ.isdual[i] == false.\n\n\n\n\n\n","category":"function"},{"location":"lib/fusiontrees/#TensorKit.split","page":"Fusion trees","title":"TensorKit.split","text":"split(f::FusionTree{I, N}, M::Int)\n-> (::FusionTree{I, M}, ::FusionTree{I, N-M+1})\n\nSplit a fusion tree into two. The first tree has as uncoupled sectors the first M uncoupled sectors of the input tree f, whereas its coupled sector corresponds to the internal sector between uncoupled sectors M and M+1 of the original tree f. The second tree has as first uncoupled sector that same internal sector of f, followed by remaining N-M uncoupled sectors of f. It couples to the same sector as f. This operation is the inverse of insertat in the sense that if f‚ÇÅ, f‚ÇÇ = split(t, M) ‚áí f == insertat(f‚ÇÇ, 1, f‚ÇÅ).\n\n\n\n\n\n","category":"function"},{"location":"lib/fusiontrees/#TensorKit.merge","page":"Fusion trees","title":"TensorKit.merge","text":"merge(f‚ÇÅ::FusionTree{I, N‚ÇÅ}, f‚ÇÇ::FusionTree{I, N‚ÇÇ}, c::I, Œº = 1)\n-> <:AbstractDict{<:FusionTree{I, N‚ÇÅ+N‚ÇÇ}, <:Number}\n\nMerge two fusion trees together to a linear combination of fusion trees whose uncoupled sectors are those of f‚ÇÅ followed by those of f‚ÇÇ, and where the two coupled sectors of f‚ÇÅ and f‚ÇÇ are further fused to c. In case of FusionStyle(I) == GenericFusion(), also a degeneracy label Œº for the fusion of the coupled sectors of f‚ÇÅ and f‚ÇÇ to c needs to be specified.\n\n\n\n\n\n","category":"function"},{"location":"lib/fusiontrees/#TensorKit.elementary_trace","page":"Fusion trees","title":"TensorKit.elementary_trace","text":"elementary_trace(f::FusionTree{I,N}, i) where {I<:Sector,N} -> <:AbstractDict{FusionTree{I,N-2}, <:Number}\n\nPerform an elementary trace of neighbouring uncoupled indices i and i+1 on a fusion tree f, and returns the result as a dictionary of output trees and corresponding coefficients.\n\n\n\n\n\n","category":"function"},{"location":"lib/fusiontrees/#TensorKit.planar_trace-Union{Tuple{N‚ÇÉ}, Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N‚ÇÉ, Int64}, NTuple{N‚ÇÉ, Int64}}} where {I<:Sector, N, N‚ÇÉ}","page":"Fusion trees","title":"TensorKit.planar_trace","text":"planar_trace(f::FusionTree{I,N}, q1::IndexTuple{N‚ÇÉ}, q2::IndexTuple{N‚ÇÉ}) where {I<:Sector,N,N‚ÇÉ}\n    -> <:AbstractDict{FusionTree{I,N-2*N‚ÇÉ}, <:Number}\n\nPerform a planar trace of the uncoupled indices of the fusion tree f at q1 with those at q2, where q1[i] is connected to q2[i] for all i. The result is returned as a dictionary of output trees and corresponding coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#TensorKit.artin_braid","page":"Fusion trees","title":"TensorKit.artin_braid","text":"artin_braid(f::FusionTree, i; inv::Bool = false) -> <:AbstractDict{typeof(f), <:Number}\n\nPerform an elementary braid (Artin generator) of neighbouring uncoupled indices i and i+1 on a fusion tree f, and returns the result as a dictionary of output trees and corresponding coefficients.\n\nThe keyword inv determines whether index i will braid above or below index i+1, i.e. applying artin_braid(f‚Ä≤, i; inv = true) to all the outputs f‚Ä≤ of artin_braid(f, i; inv = false) and collecting the results should yield a single fusion tree with non-zero coefficient, namely f with coefficient 1. This keyword has no effect if BraidingStyle(sectortype(f)) isa SymmetricBraiding.\n\n\n\n\n\n","category":"function"},{"location":"lib/fusiontrees/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I<:Sector, N}","page":"Fusion trees","title":"TensorKit.braid","text":"braid(f::FusionTree{<:Sector, N}, levels::NTuple{N, Int}, p::NTuple{N, Int})\n-> <:AbstractDict{typeof(t), <:Number}\n\nPerform a braiding of the uncoupled indices of the fusion tree f and return the result as a <:AbstractDict of output trees and corresponding coefficients. The braiding is determined by specifying that the new sector at position k corresponds to the sector that was originally at the position i = p[k], and assigning to every index i of the original fusion tree a distinct level or depth levels[i]. This permutation is then decomposed into elementary swaps between neighbouring indices, where the swaps are applied as braids such that if i and j cross, œÑ_ij is applied if levels[i] < levels[j] and œÑ_ji^-1 if levels[i] > levels[j]. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I<:Sector, N}","page":"Fusion trees","title":"TensorKit.permute","text":"permute(f::FusionTree, p::NTuple{N, Int}) -> <:AbstractDict{typeof(t), <:Number}\n\nPerform a permutation of the uncoupled indices of the fusion tree f and returns the result as a <:AbstractDict of output trees and corresponding coefficients; this requires that BraidingStyle(sectortype(f)) isa SymmetricBraiding.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#TensorKit.repartition-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I, N‚ÇÅ}, FusionTree{I, N‚ÇÇ}, Int64}} where {I<:Sector, N‚ÇÅ, N‚ÇÇ}","page":"Fusion trees","title":"TensorKit.repartition","text":"repartition(f‚ÇÅ::FusionTree{I, N‚ÇÅ}, f‚ÇÇ::FusionTree{I, N‚ÇÇ}, N::Int) where {I, N‚ÇÅ, N‚ÇÇ}\n-> <:AbstractDict{Tuple{FusionTree{I, N}, FusionTree{I, N‚ÇÅ+N‚ÇÇ-N}}, <:Number}\n\nInput is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (f‚ÇÅ) and incoming sectors (f‚ÇÇ) respectively (with identical coupled sector f‚ÇÅ.coupled == f‚ÇÇ.coupled). Computes new trees and corresponding coefficients obtained from repartitioning the tree by bending incoming to outgoing sectors (or vice versa) in order to have N outgoing sectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#Base.transpose-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I}, FusionTree{I}, NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}} where {I<:Sector, N‚ÇÅ, N‚ÇÇ}","page":"Fusion trees","title":"Base.transpose","text":"transpose(f‚ÇÅ::FusionTree{I}, f‚ÇÇ::FusionTree{I},\n        p1::NTuple{N‚ÇÅ, Int}, p2::NTuple{N‚ÇÇ, Int}) where {I, N‚ÇÅ, N‚ÇÇ}\n-> <:AbstractDict{Tuple{FusionTree{I, N‚ÇÅ}, FusionTree{I, N‚ÇÇ}}, <:Number}\n\nInput is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (t1) and incoming sectors (t2) respectively (with identical coupled sector t1.coupled == t2.coupled). Computes new trees and corresponding coefficients obtained from repartitioning and permuting the tree such that sectors p1 become outgoing and sectors p2 become incoming.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#TensorKit.braid-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I}, FusionTree{I}, NTuple{N, Int64} where N, NTuple{N, Int64} where N, NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}} where {I<:Sector, N‚ÇÅ, N‚ÇÇ}","page":"Fusion trees","title":"TensorKit.braid","text":"braid(f‚ÇÅ::FusionTree{I}, f‚ÇÇ::FusionTree{I},\n        levels1::IndexTuple, levels2::IndexTuple,\n        p1::IndexTuple{N‚ÇÅ}, p2::IndexTuple{N‚ÇÇ}) where {I<:Sector, N‚ÇÅ, N‚ÇÇ}\n-> <:AbstractDict{Tuple{FusionTree{I, N‚ÇÅ}, FusionTree{I, N‚ÇÇ}}, <:Number}\n\nInput is a fusion-splitting tree pair that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the splitting tree f‚ÇÅ and fusion tree f‚ÇÇ, such that the incoming sectors f‚ÇÇ.uncoupled are fused to f‚ÇÅ.coupled == f‚ÇÇ.coupled and then to the outgoing sectors f‚ÇÅ.uncoupled. Compute new trees and corresponding coefficients obtained from repartitioning and braiding the tree such that sectors p1 become outgoing and sectors p2 become incoming. The uncoupled indices in splitting tree f‚ÇÅ and fusion tree f‚ÇÇ have levels (or depths) levels1 and levels2 respectively, which determines how indices braid. In particular, if i and j cross, œÑ_ij is applied if levels[i] < levels[j] and œÑ_ji^-1 if levels[i] > levels[j]. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/fusiontrees/#TensorKit.permute-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{I}, Tuple{FusionTree{I}, FusionTree{I}, NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}} where {I<:Sector, N‚ÇÅ, N‚ÇÇ}","page":"Fusion trees","title":"TensorKit.permute","text":"permute(f‚ÇÅ::FusionTree{I}, f‚ÇÇ::FusionTree{I},\n        p1::NTuple{N‚ÇÅ, Int}, p2::NTuple{N‚ÇÇ, Int}) where {I, N‚ÇÅ, N‚ÇÇ}\n-> <:AbstractDict{Tuple{FusionTree{I, N‚ÇÅ}, FusionTree{I, N‚ÇÇ}}, <:Number}\n\nInput is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (t1) and incoming sectors (t2) respectively (with identical coupled sector t1.coupled == t2.coupled). Computes new trees and corresponding coefficients obtained from repartitioning and permuting the tree such that sectors p1 become outgoing and sectors p2 become incoming.\n\n\n\n\n\n","category":"method"},{"location":"man/sectors/#ss_sectors","page":"Sectors","title":"Sectors","text":"The first ingredient in order to define and construct symmetric tensors, is a framework to define symmetry sectors and their assocated fusion rules and topological data. TensorKitSectors.jl defines an abstract supertype Sector that all sectors will be subtypes of\n\nAny concrete subtype of Sector should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category. Throughout TensorKit.jl, the method sectortype can be used to query the subtype of Sector associated with a particular object, i.e. a vector space, fusion tree, tensor map, or a sector. It works on both instances and in the type domain, and its use will be illustrated further on.","category":"section"},{"location":"man/sectors/#ss_sectorinterface","page":"Sectors","title":"Minimal sector interface","text":"The minimal data to completely specify a type of sector closely matches the topological data of a fusion category as reviewed in the appendix on category theory, and is given by:\n\nThe fusion rules, i.e. a  b =  N^ab_c c, implemented as the function Nsymbol(a, b, c).\nThe list of fusion outputs from a  b; while this information is contained in N^ab_c, it might be costly or impossible to iterate over all possible values of c and test Nsymbol(a,b,c); instead we require for a ‚äó b, or equivalently, otimes(a, b), to return an iterable object (e.g. tuple or array, but see below for a dedicated iterator struct) that generates all unique c for which N^ab_c  0 (so only once for all c with N^ab_c  1).\nThe identity object u, such that a  u = a = u  a, implemented as the function unit(a) (and also in type domain), but one(a) from Julia Base also works as an alias to unit(a).\nThe dual or conjugate object overlinea for which N^abara_u = 1, implemented as the function dual(a).   Because we restrict to unitary categories, conj(a) from the Julia Base library is also defined as an alias to dual(a).\nThe F-symbol or recoupling coefficients F^abc_d^f_e; implemented as the function Fsymbol(a, b, c, d, e, f).\nIf the category is braided (see below), the R-symbol R^ab_c; implemented as the function Rsymbol(a, b, c).\n\nFurthermore, sectors should provide information about the structure of their fusion rules. For irreps of Abelian groups, we have that for every a and b, there exists a unique c such that a  b = c, i. . there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. In all other cases, there is at least one pair of (a, b) exists such that a  b has multiple fusion outputs. This is often referred to as non-abelian fusion, and is the case for the irreps of a non-abelian group or some more general fusion category. We however still distinguish between the case where all entries of N^ab_c  1, i.e. they are zero or one. In that case, F^abc_d^f_e and R^ab_c are scalars. If some N^ab_c  1, it means that the same sector c can appear more than once in the fusion product of a and b, and we need to introduce some multiplicity label Œº for the different copies, and F^abc_d^f_e and R^ab_c are respectively four- and two-dimensional arrays labelled by these multiplicity indices. To encode these different possibilities, we define a Holy-trait called FusionStyle, i.e. a type hierarchy\n\nabstract type FusionStyle end\nstruct UniqueFusion <: FusionStyle end # unique fusion output when fusing two sectors\nabstract type MultipleFusion <: FusionStyle end\nstruct SimpleFusion <: MultipleFusion end # multiple fusion but multiplicity free\nstruct GenericFusion <: MultipleFusion end # multiple fusion with multiplicities\nconst MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}\n\nNew sector types I <: Sector should then indicate which fusion style they have by defining FusionStyle(::Type{I}).\n\nIn a similar manner, it is useful to distinguish between the structure and the different styles of the braiding of a sector type. Remember that for group representations, braiding acts as swapping or permuting the vector spaces involved. By definition, applying this operation twice leads us back to the original situation. If that is the case, the braiding is said to be symmetric. For more general fusion categories, associated with the physics of anyonic particles, this is generally not the case. Some categories do not even support a braiding rule, as this requires at least that a  b and b  a have the same fusion outputs for every a and b. When braiding is possible, it might not be symmetric, and as a result, permutations of tensor indices are not unambiguously defined. The correct description is in terms of the braid group. This will be discussed in more detail below. Fermions are somewhat in between, as their braiding is symmetric, but they have a non-trivial twist. We thereto define a new trait BraidingStyle with associated the type hierarchy\n\nabstract type HasBraiding <: BraidingStyle end\nstruct NoBraiding <: BraidingStyle end\nabstract type SymmetricBraiding <: HasBraiding end # symmetric braiding => actions of permutation group are well defined\nstruct Bosonic <: SymmetricBraiding end # all twists are one\nstruct Fermionic <: SymmetricBraiding end # twists one and minus one\nstruct Anyonic <: HasBraiding end\n\nNew sector types I <: Sector should then indicate which fusion style they have by defining BraidingStyle(::Type{I}).\n\nNote that Bosonic() braiding does not mean that all permutations are trivial and R^ab_c = 1, but that R^ab_c R^ba_c = 1. For example, for the irreps of mathsfSU_2, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is -1, i.e. the singlet of two spin-1/2 particles is antisymmetric under swapping the two constituents. For a Bosonic() braiding style, all twists are simply +1. The case of fermions and anyons are discussed below.\n\nFor practical reasons, we also require some additional methods to be defined:\n\nhash(a, h) creates a hash of sectors, because sectors and objects created from them are used as keys in lookup tables (i.e. dictionaries).   Julia provides a default implementation of hash for every new type, but it can be useful to overload it for efficiency, or to ensure that the same hash is obtained for different instances that represent the same sector (e.g. when the sector type is not a bitstype).\nisless(a, b) associates a canonical order to sectors (of the same type), in order to unambiguously represent representation spaces V = _a ‚ÑÇ^n_a  R_a.\n\nLastly, we sometimes need to iterate over different values of a sector type I <: Sector, or at least have some basic information about the number of possible values of I Hereto, TensorKitSectors.jl defines Base.values(I::Type{<:Sector}) to return the singleton instance of the parametric type SectorValues{I}, which should behave as an iterator over all possible values of the sector type I. This means the following methods should be implemented for a new sector type I <: Sector:\n\nBase.iterate(::Type{SectorValues{I}} [, state]) should implement the iterator interface so as to enable iterating over all values of the sector I according to the canonical order defined by isless.\nBase.IteratorSize(::Type{SectorValues{I}}) should return HasLength() if the number of different values of sector I is finite and rather small, and SizeUnknown() or IsInfinite() otherwise.   This is used to encode the degeneracies of the different sectors in a GradedSpace object efficiently, as discussed in the next section on Graded spaces.\nIf IteratorSize(::Type{SectorValues{I}}) == HasLength(), then Base.length(::Type{SectorValues{I}}) should return the number of different values of sector I.\n\nFurthermore, the standard definitions Base.IteratorEltype(::Type{SectorValues{I}}) = HasEltype() and Base.eltype(::Type{SectorValues{I}}) = I are provided by default in TensorKitSectors.jl.\n\nnote: Note\nA recent update in TensorKitSectors.jl has extended the minimal interface to also support multi-fusion categories, for which in particular the unit object is non-simple. We do not discuss this extension here, but refer to the documentation of UnitStyle, leftunit, rightunit and allunits for more details.","category":"section"},{"location":"man/sectors/#ss_sectoradditional","page":"Sectors","title":"Additional methods","text":"The sector interface contains a number of additional methods, that are useful, but whose return value can be computed from the minimal interface defined in the previous subsection. However, new sector types can override these default fallbacks with more efficient implementations.\n\nFirstly, the canonical order of sectors allows to enumerate the different values, and thus to associate each value with an integer. Hereto, the following methods are defined:\n\nBase.getindex(::SectorValues{I}, i::Int): returns the sector instance of type I that is associated with integer i.   The fallback implementation simply iterates through values(I) up to the ith value.\nfindindex(::SectorValues{I}, c::I): reverse mapping that associates an index i::Integer ‚àà 1:length(values(I)) to a given sector c::I.   The fallback implementation simply searches linearly through the values(I) iterator.\n\nNote that findindex acts similar to Base.indexin, but with the order of the arguments reversed (so that is more similar to getindex), and returns an Int rather than an Array{0, Union{Int, Nothing}}.\n\nSecondly, it is often useful to know the scalar type in which the topological data in the F- and R-symbols are expressed. For this, the method sectorscalartype(I::Type{<:Sector}) is provided, which has a default implementation that uses type inference on the return values of Fsymbol and Rsymbol. This function is also used to define Base.isreal(I::Type{<:Sector}), which indicates whether all topological data are real numbers. This is important because, if complex numbers appear in the topological data, it means tensor data will necessarily become complex after simple manipulations such as permuting indices, and should therefore probably be stored as complex numbers from the start.\n\nFinally, additional topological data can be extracted from the minimal interface. In particular, the quantum dimensions d_a and Frobenius-Schur phase œá_a and indicator (only if a == overlinea) are encoded in the F-symbol. They are obtained as dim(a), frobenius_schur_phase(a) and frobenius_schur_indicator(a). These functions have default definitions which compute the requested data from Fsymbol(a, conj(a), a, a, unit(a), unit(a)), but they can be overloaded in case the value can be computed more efficiently. The same holds for related fusion manipulations such as the B-symbol, which is obtained as Bsymbol(a, b, c). Finally, the twist associated with a sector a is obtained as twist(a), which also has a default implementation in terms of the R-symbol. In addition, the function isunit is provided to facilitate checking whether a sector is a unit sector, in particular for the non-trivial case of the multi-fusion category case, which we do not discuss here.","category":"section"},{"location":"man/sectors/#ss_sectoradditionaltools","page":"Sectors","title":"Additional tools","text":"The fusion product a ‚äó b of two sectors a and b is required to return an iterable object that generates all unique fusion outputs c for which N^ab_c  0. When this list can easily be computed or constructed, it can be returned as a tuple or an array. However, when taking type stability and (memory) efficiency into account, it is often preferable to return a lazy iterator object that generates the different fusion outputs on the fly. Indeed, a tuple result is only type stable when the number of fusion outputs is constant for all possible inputs a and b, whereas a Vector result requires heap allocation.\n\nBy default, TensorKitSectors.jl defines\n\n‚äó(a::I, b::I) where {I <: Sector} = SectorProductIterator(a, b)\n\nwhere TensorKitSectors.SectorProductIterator is defined as\n\nand can serve as a general iterator type. For defining the fusion rules of a sector I, instead of implementing ‚äó(::I, ::I) directly, it is thus possible to instead implement the iterator interface for SectorProductIterator{I}, i.e. provide definitions for\n\nBase.iterate(::SectorProductIterator{I}[, state])\nBase.IteratorSize(::Type{SectorProductIterator{I}})\nBase.length(::SectorProductIterator{I}) (if applicable)\n\nTensorKitSectors.jl already defines\n\nBase.eltype(::Type{SectorProductIterator{I}}) where {I} = I\n\nand sets Base.IteratorEltype(::Type{SectorProductIterator{I}}) accordingly. Furthermore, it provides custom pretty printing, so that SectorProductIterator{I}(a, b) is displayed as a ‚äó b.","category":"section"},{"location":"man/sectors/#ss_groups","page":"Sectors","title":"Group representations","text":"In this subsection, we give an overview of some existing sector types provided by TensorKitSectors.jl. We also discuss the implementation of some of them in more detail, in order to illustrate the interface defined above.\n\nThe first sector type is called Trivial, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:\n\nstruct Trivial <: Sector end\n\n# basic properties\nunit(::Type{Trivial}) = Trivial()\ndual(::Trivial) = Trivial()\nBase.isless(::Trivial, ::Trivial) = false\n\n# fusion rules\n‚äó(::Trivial, ::Trivial) = (Trivial(),)\nNsymbol(::Trivial, ::Trivial, ::Trivial) = true\nFusionStyle(::Type{Trivial}) = UniqueFusion()\nFsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1\n\n# braiding rules\nRsymbol(::Trivial, ::Trivial, ::Trivial) = 1\nBraidingStyle(::Type{Trivial}) = Bosonic()\n\n# values iterator\nBase.IteratorSize(::Type{SectorValues{Trivial}}) = HasLength()\nBase.length(::SectorValues{Trivial}) = 1\nBase.iterate(::SectorValues{Trivial}, i = false) = return i ? nothing : (Trivial(), true)\nfunction Base.getindex(::SectorValues{Trivial}, i::Int)\n    return i == 1 ? Trivial() : throw(BoundsError(values(Trivial), i))\nend\nfindindex(::SectorValues{Trivial}, c::Trivial) = 1\n\nThe Trivial sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.\n\nThe most important class of sectors are irreducible representations of groups. As we often use the group itself as a type parameter, an associated type hierarchy for groups has been defined, namely\n\nabstract type Group end\nabstract type AbelianGroup <: Group end\n\nabstract type Cyclic{N} <: AbelianGroup end\nabstract type Dihedral{N} <: Group end\nabstract type U‚ÇÅ <: AbelianGroup end\nabstract type CU‚ÇÅ <: Group end\n\nconst ‚Ñ§{N} = Cyclic{N}\nconst ‚Ñ§‚ÇÇ = ‚Ñ§{2}\nconst ‚Ñ§‚ÇÉ = ‚Ñ§{3}\nconst ‚Ñ§‚ÇÑ = ‚Ñ§{4}\nconst D‚ÇÉ = Dihedral{3}\nconst D‚ÇÑ = Dihedral{4}\nconst SU‚ÇÇ = SU{2}\n\nGroups themselves are abstract types without any functionality (at least for now). However, as will become clear instantly, it is useful to identify abelian groups, because their representation theory is particularly simple. We also provide a number of convenient Unicode aliases. These group names are probably self-explanatory, except for CU‚ÇÅ which is explained below.\n\nIrreps of groups will then be defined as subtypes of the abstract type\n\nabstract type AbstractIrrep{G<:Group} <: Sector end # irreps have integer quantum dimensions\nBraidingStyle(::Type{<:AbstractIrrep}) = Bosonic()\n\nWe will need different data structures to represent irreps of different groups, but it would be convenient to easily obtain the relevant structure for a given group G in a uniform manner. Hereto, we define a singleton type IrrepTable with an associated exported constant Irrep = IrrepTable() as the only instance. When a concrete type for representing the the irreps of a certain group G is iplemented, this type can the be \"discovered\" or obtained as Irrep[G], provided it was registered by defining Base.getindex(::IrrepTable, ::Type{G}) to return the concrete type.\n\nFurthermore, we combine the more common functionality for irreps of abelian groups\n\nconst AbelianIrrep{G} = AbstractIrrep{G} where {G <: AbelianGroup}\nFusionStyle(::Type{<:AbelianIrrep}) = UniqueFusion()\nBase.sectorscalartype(::Type{<:AbelianIrrep}) = Int\n\nNsymbol(a::I, b::I, c::I) where {I <: AbelianIrrep} = c == first(a ‚äó b)\nfunction Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I <: AbelianIrrep}\n    return Int(Nsymbol(a, b, e) * Nsymbol(e, c, d) * Nsymbol(b, c, f) * Nsymbol(a, f, d))\nend\nfrobenius_schur_phase(a::AbelianIrrep) = 1\nAsymbol(a::I, b::I, c::I) where {I <: AbelianIrrep} = Int(Nsymbol(a, b, c))\nBsymbol(a::I, b::I, c::I) where {I <: AbelianIrrep} = Int(Nsymbol(a, b, c))\nRsymbol(a::I, b::I, c::I) where {I <: AbelianIrrep} = Int(Nsymbol(a, b, c))\n\nWith these common definition in place, we implement the representation theory of the most common Abelian groups, starting with mathsfU_1, the full implementation of which is given by\n\nstruct U1Irrep <: AbstractIrrep{U‚ÇÅ}\n    charge::HalfInt\nend\nBase.getindex(::IrrepTable, ::Type{U‚ÇÅ}) = U1Irrep\nBase.convert(::Type{U1Irrep}, c::Real) = U1Irrep(c)\n\n# basic properties\ncharge(c::U1Irrep) = c.charge\nunit(::Type{U1Irrep}) = U1Irrep(0)\ndual(c::U1Irrep) = U1Irrep(-charge(c))\n@inline function Base.isless(c1::U1Irrep, c2::U1Irrep)\n    return isless(abs(charge(c1)), abs(charge(c2))) || zero(HalfInt) < charge(c1) == -charge(c2)\nend\n\n# fusion rules\n‚äó(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(charge(c1) + charge(c2)),)\n\n# values iterator\nBase.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()\nfunction Base.iterate(::SectorValues{U1Irrep}, i::Int = 0)\n    return i <= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)\nend\nfunction Base.getindex(::SectorValues{U1Irrep}, i::Int)\n    i < 1 && throw(BoundsError(values(U1Irrep), i))\n    return U1Irrep(iseven(i) ? half(i >> 1) : -half(i >> 1))\nend\nfunction findindex(::SectorValues{U1Irrep}, c::U1Irrep)\n    return (n = twice(charge(c)); 2 * abs(n) + (n <= 0))\nend\n\n# hashing\nBase.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)\n\nA few comments are in order: The getindex definition just below the type definition provides the mechanism to obtain U1Irrep as Irrep[U‚ÇÅ], as discussed above. The Base.convert definition, while not required by the minimal sector interface, allows to convert real numbers to the corresponding type of sector, and thus to omit the type information of the sector whenever this is clear from the context. The charge function is again not part of the minimal sector interface, and is specific to U1Irrep (and ZNIrrep discussed next), as a mere convenience function to access the charge value. Finally, in the definition of U1Irrep, HalfInt <: Number is a Julia type defined in HalfIntegers.jl, which is also used for SU2Irrep below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of U‚ÇÅ can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of HalfInt and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example\n\nIrrep[U‚ÇÅ](0.5)\nU1Irrep(0.4)\nU1Irrep(1) ‚äó Irrep[U‚ÇÅ](1//2)\nu = first(U1Irrep(1) ‚äó Irrep[U‚ÇÅ](1//2))\nNsymbol(u, dual(u), unit(u))\n\nWe similarly implement the irreps of the finite cyclic groups mathbbZ_N, where we distinguish between small and large values of N to optimize storage. The implementation is given by\n\nconst SMALL_ZN_CUTOFF = (typemax(UInt8) + 1) √∑ 2\nstruct ZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\n    n::UInt8\n    function ZNIrrep{N}(n::Integer) where {N}\n        N ‚â§ SMALL_ZN_CUTOFF || throw(DomainError(N, \"N exceeds the maximal value, use `LargeZNIrrep` instead\"))\n        return new{N}(UInt8(mod(n, N)))\n    end\nend\nstruct LargeZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\n    n::UInt\n    function LargeZNIrrep{N}(n::Integer) where {N}\n        N ‚â§ (typemax(UInt) √∑ 2) || throw(DomainError(N, \"N exceeds the maximal value\"))\n        return new{N}(UInt(mod(n, N)))\n    end\n\nend\nBase.getindex(::IrrepTable, ::Type{‚Ñ§{N}}) where {N} = N ‚â§ SMALL_ZN_CUTOFF ? ZNIrrep{N} : LargeZNIrrep{N}\n...\n\nand continues along simular lines of the U1Irrep implementation above, by replacing the arithmetic with modulo N arithmetic.\n\nThe storage benefits for small N are not only due to a smaller integer type in the sector itself, but emerges as a result of the following distinction in the iterator size:\n\nBase.IteratorSize(::Type{SectorValues{<:ZNIrrep}}) = HasLength()\nBase.IteratorSize(::Type{SectorValues{<:LargeZNIrrep}}) = SizeUnknown()\n\nAs a result, the GradedSpace implementation (see next section on Graded spaces) to store general direct sum objects V = _a ‚ÑÇ^n_a  R_a will use a very different internal representation for those two cases.\n\nWe furthermore define some aliases for the first (and most commonly used ‚Ñ§{N} irreps)\n\nconst Z2Irrep = ZNIrrep{2}\nconst Z3Irrep = ZNIrrep{3}\nconst Z4Irrep = ZNIrrep{4}\n\nwhich we can illustrate via\n\nz = Z3Irrep(1)\nZNIrrep{3}(1) ‚äó Irrep[‚Ñ§‚ÇÉ](1)\ndual(z)\nunit(z)\n\nAs a final remark on the irreps of abelian groups, note that even though a ‚äó b is equivalent to a single new label c, we return this result as an iterable container, in this case a one-element tuple (c,).\n\nThe first example of irreps of a non-abelian group is that of mathsfSU_2, the implementation of which is summarized by\n\nstruct SU2Irrep <: AbstractIrrep{SU‚ÇÇ}\n    j::HalfInt\n    function SU2Irrep(j)\n        j >= zero(j) || error(\"Not a valid SU‚ÇÇ irrep\")\n        return new(j)\n    end\nend\nBase.getindex(::IrrepTable, ::Type{SU‚ÇÇ}) = SU2Irrep\nBase.convert(::Type{SU2Irrep}, j::Real) = SU2Irrep(j)\n\n# basic properties\nconst _su2one = SU2Irrep(zero(HalfInt))\nunit(::Type{SU2Irrep}) = _su2one\ndual(s::SU2Irrep) = s\ndim(s::SU2Irrep) = twice(s.j) + 1\nBase.isless(s1::SU2Irrep, s2::SU2Irrep) = isless(s1.j, s2.j)\n\n# fusion product iterator\nconst SU2IrrepProdIterator = SectorProductIterator{SU2Irrep}\nBase.IteratorSize(::Type{SU2IrrepProdIterator}) = Base.HasLength()\nBase.length(it::SU2IrrepProdIterator) = length(abs(it.a.j - it.b.j):(it.a.j + it.b.j))\nfunction Base.iterate(it::SU2IrrepProdIterator, state = abs(it.a.j - it.b.j))\n    return state > (it.a.j + it.b.j) ? nothing : (SU2Irrep(state), state + 1)\nend\n\n# fusion and braidingdata\nFusionStyle(::Type{SU2Irrep}) = SimpleFusion()\nsectorscalartype(::Type{SU2Irrep}) = Float64\n\nNsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.Œ¥(sa.j, sb.j, sc.j)\nfunction Fsymbol(\n        s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,\n        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep\n    )\n    if all(==(_su2one), (s1, s2, s3, s4, s5, s6))\n        return 1.0\n    else\n        return sqrtdim(s5) * sqrtdim(s6) *\n            WignerSymbols.racahW(\n            sectorscalartype(SU2Irrep), s1.j, s2.j, s4.j, s3.j,\n            s5.j, s6.j\n        )\n    end\nend\nfunction Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)\n    Nsymbol(sa, sb, sc) || return zero(sectorscalartype(SU2Irrep))\n    return iseven(convert(Int, sa.j + sb.j - sc.j)) ? one(sectorscalartype(SU2Irrep)) :\n        -one(sectorscalartype(SU2Irrep))\nend\n\n# values iterator\nBase.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()\nBase.iterate(::SectorValues{SU2Irrep}, i::Int = 0) = (SU2Irrep(half(i)), i + 1)\nfunction Base.getindex(::SectorValues{SU2Irrep}, i::Int)\n    return 1 <= i ? SU2Irrep(half(i - 1)) : throw(BoundsError(values(SU2Irrep), i))\nend\nfindindex(::SectorValues{SU2Irrep}, s::SU2Irrep) = twice(s.j) + 1\n\n# hashing\nBase.hash(s::SU2Irrep, h::UInt) = hash(s.j, h)\n\nand some methods for pretty printing and converting from real numbers to irrep labels. Here, the fusion rules are implemented lazily using the SectorProductIterator defined above. Furthermore, the topological data (i.e. Nsymbol and Fsymbol) are provided by the package WignerSymbols.jl. Note that, while WignerSymbols.jl is able to generate the required data in arbitrary precision, we have explicitly restricted the scalar type of SU2Irrep to Float64 for efficiency.\n\nThe following example illustrates the usage of SU2Irrep\n\ns = SU2Irrep(3//2)\ndual(s)\ndim(s)\ncollect(s ‚äó s)\nfor s2 in s ‚äó s\n    @show s2\n    @show Nsymbol(s, s, s2)\n    @show Rsymbol(s, s, s2)\nend\n\nOther non-abelian groups for which the irreps are implemented are the dihedral groups mathsfD_N, the alternating group of order four mathsfA_4 and the semidirect product mathsfU‚ÇÅ  ‚Ñ§_2. In the context of quantum systems, the latter occurs in the case of systems with particle hole symmetry and the non-trivial element of ‚Ñ§_2 acts as charge conjugation C. It has the effect of interchanging mathsfU_1 irreps n and -n, and turns them together in a joint two-dimensional index, except for the case n=0. Irreps are therefore labeled by integers n  0, however for n=0 the ‚Ñ§‚ÇÇ symmetry can be realized trivially or non-trivially, resulting in an even and odd one-dimensional irrep with mathsfU_1 charge 0. Given mathsfU_1  mathsfSO_2, this group is also simply known as mathsfO_2, and the two representations with n = 0 are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as Irrep[CU‚ÇÅ] or CU1Irrep in full.\n\nstruct CU1Irrep <: AbstractIrrep{CU‚ÇÅ}\n    j::HalfInt # value of the U1 charge\n    s::Int # rep of charge conjugation:\n    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),\n    # else s = 2 (two-dimensional representation)\n    # Let constructor take the actual half integer value j\n    function CU1Irrep(j::Real, s::Int = ifelse(j>zero(j), 2, 0))\n        if ((j > zero(j) && s == 2) || (j == zero(j) && (s == 0 || s == 1)))\n            new(j, s)\n        else\n            error(\"Not a valid CU‚ÇÅ irrep\")\n        end\n    end\nend\n\nunit(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)\ndual(c::CU1Irrep) = c\ndim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)\n\nFusionStyle(::Type{CU1Irrep}) = SimpleFusion()\n...\n\nThe rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of Fsymbol. For the dihedrial groups mathsfD_N, which can be intepreted as the semidirect product mathbbZ_N  ‚Ñ§_2, the representation theory is obtained quite similarly, and is implmented as the type DNIrrep{N}.\n\nOf the aforementioned groups, only mathsfA_4 has a representation theory for which FusionStyle(I) == GenericFusion(), i.e. where fusion mulitplicities are required. Another example where this does appear is for the irreps of SU{N} for N  2. Such sectors are supported through SUNRepresentations.jl, which implements numerical routines to compute the topological data of the representation theory of these groups, as no general analytic formula is available.","category":"section"},{"location":"man/sectors/#ss_productsectors","page":"Sectors","title":"Combining different sectors","text":"It is also possible to combine two or more different types of symmetry sectors, e.g. when the total symmetry group is a direct product of individual simple groups. Such combined sectors are obtained using the binary operator ‚ä†, which can be entered as \\boxtimes+TAB. The resulting type is called ProductSector, which simply wraps the individual sectors, but knows how to combine their fusion and braiding data correctly. First some examples\n\na = Z3Irrep(1) ‚ä† Irrep[U‚ÇÅ](1)\ntypeof(a)\ndual(a)\nunit(a)\ndim(a)\ncollect(a ‚äó a)\nFusionStyle(a)\nb = Irrep[‚Ñ§‚ÇÉ](1) ‚ä† Irrep[SU‚ÇÇ](3//2)\ntypeof(b)\ndual(b)\nunit(b)\ndim(b)\ncollect(b ‚äó b)\nFusionStyle(b)\nc = Irrep[SU‚ÇÇ](1) ‚ä† SU2Irrep(3//2)\ntypeof(c)\ndual(c)\nunit(c)\ndim(c)\ncollect(c ‚äó c)\nFusionStyle(c)\n\nWe refer to the source file of ProductSector for implementation details.\n\nThe symbol ‚ä† refers to the Deligne tensor product within the literature on category theory. Indeed, the category of representation of a product group G‚ÇÅ √ó G‚ÇÇ corresponds to the Deligne tensor product of the categories of representations of the two groups separately. But this definition also extends to other categories which are not associated with the representation theory of a group, as discussed below. Note that ‚ä† also works in the type domain, i.e. Irrep[‚Ñ§‚ÇÉ] ‚ä† Irrep[CU‚ÇÅ] can be used to create ProductSector{Tuple{Irrep[‚Ñ§‚ÇÉ], Irrep[CU‚ÇÅ]}}. Instances of this type can be constructed by giving a number of arguments, where the first argument is used to construct the first sector, and so forth. Furthermore, for representations of groups, we also enabled the notation Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ], with √ó obtained using \\times+TAB. However, this is merely for convenience, as Irrep[‚Ñ§‚ÇÉ] ‚ä† Irrep[CU‚ÇÅ] is not a subtype of the abstract type AbstractIrrep{‚Ñ§‚ÇÉ √ó CU‚ÇÅ}. As is often the case with the Julia type system, the purpose of subtyping AbstractIrrep was to share common functionality and thereby simplify the implementation of irreps of the different groups discussed above, but not to express a mathematical hierarchy.\n\nSome more examples:\n\na = Z3Irrep(1) ‚ä† Irrep[CU‚ÇÅ](1.5)\na isa Irrep[‚Ñ§‚ÇÉ] ‚ä† CU1Irrep\na isa Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ]\na isa AbstractIrrep{‚Ñ§‚ÇÉ √ó CU‚ÇÅ}\na == Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ](1, 1.5)","category":"section"},{"location":"man/sectors/#ss_newsectors","page":"Sectors","title":"Defining a new type of sector","text":"By now, it should be clear how to implement a new Sector subtype. Ideally, a new I <: Sector type is a struct I ... end (immutable) that has isbitstype(I) == true (see Julia's manual), and implements the following minimal set of methods\n\nTensorKit.unit(::Type{I}) = I(...)\nTensorKit.dual(a::I) = I(...)\nBase.isless(a::I, b::I)\n\nTensorKit.FusionStyle(::Type{I}) = ... # UniqueFusion(), SimpleFusion(), GenericFusion()\nTensorKit.Nsymbol(a::I, b::I, c::I) = ... # Bool or Integer if FusionStyle(I) == GenericFusion()\n\nTensorKit.:‚äó(a::I, b::I) = ... # some iterable object that generates all possible fusion outputs\n# or\nBase.iterate(::SectorProductIterator{I}[, state]) = ...\nBase.IteratorSize(::Type{SectorProductIterator{I}}) = ... # HasLength() or IsInfinite()\nBase.length(::SectorProductIterator{I}) = ... # if previous function returns HasLength()\n\nTensorKit.Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) = ...\n\nTensorKit.BraidingStyle(::Type{I}) = ... # NoBraiding(), Bosonic(), Fermionic(), Anyonic()\nTensorKit.Rsymbol(a::I, b::I, c::I) = ... # only if BraidingStyle(I) != NoBraiding()\n\nBase.iterate(::TensorKit.SectorValues{I}[, state]) = ...\nBase.IteratorSize(::Type{TensorKit.SectorValues{I}}) = ... # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::TensorKit.SectorValues{I}) = ...\n# optional, but recommended if IteratorSize returns HasLength():\nBase.getindex(::TensorKit.SectorValues{I}, i::Int) = ...\nTensorKit.findindex(::TensorKit.SectorValues{I}, c::I) = ...\n\nBase.hash(a::I, h::UInt)\n\nAdditionally, suitable definitions can be given for\n\nTensorKit.sectorscalartype(::Type{I}) = ... # Int, Float64, ComplexF64, ...\nTensorKit.dim(a::I) = ...\nTensorKit.frobeniusschur_phase(a::I) = ...\nTensorKit.Bsymbol(a::I, b::I, c::I) = ...","category":"section"},{"location":"man/sectors/#ss_fermions","page":"Sectors","title":"Fermionic sectors","text":"All of the sectors discussed in Group representations have a bosonic braiding style. This does not mean that Rsymbol is always trivial, as for example for SU2Irrep the definition was given by\n\nfunction Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)\n    Nsymbol(sa, sb, sc) || return zero(sectorscalartype(SU2Irrep))\n    return iseven(convert(Int, sa.j + sb.j - sc.j)) ? one(sectorscalartype(SU2Irrep)) :\n        -one(sectorscalartype(SU2Irrep))\nend\n\nIt does however mean that all twists Œ∏_a are trivial (equal to 1). We refer to the appendix on Category theory for more details on the meaning of the twist. In summary, triviality of the twists implies that self-crossings of lines in tensor diagrams can be ignored, i.e. they can be removed without changing the value of the diagram.\n\nAs is well known, this becomes more subtle when fermionic degrees are involved. Technically, fermions are described using super vector spaces, which are ‚Ñ§‚ÇÇ-graded vector spaces V = V_0  V_1, i.e. the vector space is decomposed as an (orthogonal) direct sum into an even and odd subspace, corresponding to states with even and odd fermion parity, respectively. The tensor product of two super vector spaces V and W is again graded as (V  W)_0 = (V_0  W_0)  (V_1  W_1) and (V  W)_1 = (V_0  W_1)  (V_1  W_0). However, when exchanging two super vector spaces in such a tensor product, the natural isomorphism V  W  W  V takes into account the fermionic nature by acting with a minus sign in the subspace V_1  W_1. This is known as the Koszul sign rule.\n\nThe super vector space structure fits naturally in the framework of TensorKit.jl. Indeed, the grading naturally corresponds to a ‚Ñ§‚ÇÇ-valued sector structure, which we implement as FermionParity:\n\nstruct FermionParity <: Sector\n    isodd::Bool\nend\nconst f‚Ñ§‚ÇÇ = FermionParity\nfermionparity(f::FermionParity) = f.isodd\n\nwith straightforward fusion rules and associators\n\n‚äó(a::FermionParity, b::FermionParity) = (FermionParity(a.isodd ‚äª b.isodd),)\nfunction Nsymbol(a::FermionParity, b::FermionParity, c::FermionParity)\n    return (a.isodd ‚äª b.isodd) == c.isodd\nend\nfunction Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I <: FermionParity}\n    return Int(Nsymbol(a, b, e) * Nsymbol(e, c, d) * Nsymbol(b, c, f) * Nsymbol(a, f, d))\nend\n\nbut with non-trivial braiding and twist\n\nfunction Rsymbol(a::I, b::I, c::I) where {I <: FermionParity}\n    return a.isodd && b.isodd ? -Int(Nsymbol(a, b, c)) : Int(Nsymbol(a, b, c))\nend\ntwist(a::FermionParity) = a.isodd ? -1 : +1\n\nThe super vector space structure can also be combined with other sector types using the ‚ä† operator discussed above. In some cases, there is a richer symmetry than ‚Ñ§‚ÇÇ associated with the fermionic degrees of freedom, and there is a natural fermion parity associated with the sectors of that symmetry. An example would be a mathsfU_1 symmetry associated with fermion number conservation, where odd mathsfU_1 charges correspond to odd fermion parity. However, it is then always possible to separate out the fermion parity structure as a separate sector, and treat the original sectors as bosonic, by only restricting to combinations of sectors that satisfy the natural fermion parity association.\n\nFor convenience (and partially due to legacy reasons), TensorKitSectors.jl does provide FermionNumber and FermionSpin constructors, which are defined as\n\nconst FermionNumber = U1Irrep ‚ä† FermionParity\nconst fU‚ÇÅ = FermionNumber\nFermionNumber(a::Int) = U1Irrep(a) ‚ä† FermionParity(isodd(a))\n\nconst FermionSpin = SU2Irrep ‚ä† FermionParity\nconst fSU‚ÇÇ = FermionSpin\nFermionSpin(j::Real) = (s = SU2Irrep(j); s ‚ä† FermionParity(isodd(twice(s.j))))\n\nWe conclude this subsection with some examples.\n\np = FermionParity(true)\np ‚äó p\ntwist(p)\nFusionStyle(p)\nBraidingStyle(p)\n\ns = FermionSpin(3//2)\ndim(s)\ntwist(s)\ntypeof(s)\nFusionStyle(s)\nBraidingStyle(s)\ncollect(s ‚äó s)\nfor s2 in s ‚äó s\n    @show s2\n    @show Rsymbol(s, s, s2)\nend\n\nNote in particular how the Rsymbol values have opposite signs to the bosonic case, where the fusion of two equal half-integer spins to the trivial sector is antisymmetric and would thus have Rsymbol value -1.","category":"section"},{"location":"man/sectors/#Anyons","page":"Sectors","title":"Anyons","text":"Both Bosonic and Fermionic braiding styles are SymmetricBraiding styles, which means that exchanging two sectors twice is equivalent to the identity operation. In tensor network diagrams, this implies that lines that cross twice are equivalent to them not crossing at all, or also, that there is no distinction betweeen a line crossing \"above\" or \"below\" another line. More technically, the relevant group describing the exchange processes is the permutation group, whereas in more general cases it would be the braid group.\n\nThis more general case is denoted as the Anyonic braiding style in TensorKit.jl, because examples of this behaviour appear in the context of anyons in topological phases of matter.\n\nThere are currently two well-known sector types with Anyonic braiding style implemented in TensorKitSectors. l, namely FibonacciAnyon and IsingAnyon. Their values represent the (equivalence classes of) simple objects of the well-known Fibonicci and Ising fusion categories. As an example, we illustrate below the Fibonacci anyons, which has only two distinct sectors, namely the unit sector ùüô and one non-trivial sector denoted as œÑ. The fusion rules are given by œÑ ‚äó œÑ = ùüô ‚äï œÑ, and the topological data is summarized by the following code\n\nùüô = FibonacciAnyon(:I)\nœÑ = FibonacciAnyon(:œÑ)\ncollect(œÑ ‚äó œÑ)\nFusionStyle(œÑ)\nBraidingStyle(œÑ)\ndim(ùüô)\ndim(œÑ)\nFùüô = Fsymbol(œÑ,œÑ,œÑ,ùüô,œÑ,œÑ)\nFœÑ = [Fsymbol(œÑ,œÑ,œÑ,œÑ,ùüô,ùüô) Fsymbol(œÑ,œÑ,œÑ,œÑ,ùüô,œÑ); Fsymbol(œÑ,œÑ,œÑ,œÑ,œÑ,ùüô) Fsymbol(œÑ,œÑ,œÑ,œÑ,œÑ,œÑ)]\nFœÑ'*FœÑ\npolar(x) = rationalize.((abs(x), angle(x)/(2pi)))\nRsymbol(œÑ,œÑ,ùüô) |> polar\nRsymbol(œÑ,œÑ,œÑ) |> polar\ntwist(œÑ) |> polar","category":"section"},{"location":"man/sectors/#ss_generalsectors","page":"Sectors","title":"Further generalizations","text":"The Anyonic braiding style is one generalization beyond the bosonic and fermionic representation theory of groups, i.e. the action of groups on vector spaces and super vector spaces. It is also possible to consider fusion categories without braiding structure, represented as NoBraiding in TensorKitSectors.jl. Indeed, the framework for sectors outlined above is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) fusion category, which is reviewed in the appendix on category theory. For such categories, the objects are not necessarily vector spaces and the fusion and splitting tensors X^ab_cŒº do not necessarily exist as actual tensors. However, the morphism spaces c  a  b still behave as vector spaces, and the X^ab_cŒº act as generic basis for that space. As TensorKit.jl does not rely on the X^ab_cŒº themselves (even when they do exist), it can also deal with such general fusion categories. An extensive list of (the topological data of) such fusion categories, with and without braiding, is provided in CategoryData.jl.\n\nWithin TensorKit.jl, the only sector with NoBraiding is the PlanarTrivial sector, which is actually equivalent to the Trivial sector, but where the braiding has been \"disabled\" for testing purposes.\n\nFinally, as mentioned above, a recent extension prepares TensorKitSectors.jl to deal with multi-fusion categories, where the sectors (simple objects) are organized in a matrix-like structure and thus have an additional row and column index. Fusion between sectors is only possible when the row and column indices match appropriately; otherwise the fusion product is empty. In this structure, the different diagonal sectors define separate fusion categories, whereas the off-diagonal sectors define bimodule categories between these fusion categories. Every diagonal set of sectors has its own unit sector, which also acts as the left / right unit for other sectors in the same column / row. The global unit object is not simple, but rather given by the direct sum of all diagonal unit sectors. We do not document or illustrate this structure here, but refer to the relevant functions leftunit, rightunit, allunits and UnitStyle for more information. Furthermore, we refer to MultiTensorKit.jl for examples and ongoing development work on using multi-fusion categories.","category":"section"},{"location":"man/sectors/#TensorKitSectors.Sector-man-sectors","page":"Sectors","title":"TensorKitSectors.Sector","text":"abstract type Sector\n\nAbstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes I <: Sector as the set of labels of a GradedSpace.\n\nEvery new I <: Sector should implement the following methods:\n\nunit(::Type{I}): unit element of I. If there are multiple, implement allunits(::Type{I})   instead.\ndual(a::I): aÃÖ, conjugate or dual label of a\n‚äó(a::I, b::I): iterable with unique fusion outputs of a  b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::I, b::I, c::I): number of times c appears in a ‚äó b, i.e. the   multiplicity\nFusionStyle(::Type{I}): UniqueFusion(), SimpleFusion() or   GenericFusion()\nBraidingStyle(::Type{I}): Bosonic(), Fermionic(), Anyonic(), ...\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I): F-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or rank-4 array (in case of GenericFusion)\nRsymbol(a::I, b::I, c::I): R-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\nisless(a::I, b::I): defines a canonical ordering of sectors\nhash(a::I): hash function for sectors\n\nand optionally\n\ndim(a::I): quantum dimension of sector a\nfrobenius_schur_indicator(a::I): Frobenius-Schur indicator of a (1, 0, -1)\nfrobenius_schur_phase(a::I): Frobenius-Schur phase of a (¬±1)\nsectorscalartype(::Type{I}): scalar type of F- and R-symbols\nBsymbol(a::I, b::I, c::I): B-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\ntwist(a::I) -> twist of sector a\n\nFurthermore, iterate and Base.IteratorSize should be made to work for the singleton type SectorValues{I}.\n\nTo help with the implementation of ‚äó(a::I, b::I) as an iterator, the provided struct type SectorProductIterator{I} can be used, which stores a and b and requires the implementation of Base.iterate(::SectorProductIterator{I}, state...).\n\n\n\n\n\n","category":"type"},{"location":"man/sectors/#TensorKitSectors.SectorProductIterator-man-sectors","page":"Sectors","title":"TensorKitSectors.SectorProductIterator","text":"struct SectorProductIterator{I <: Sector}\nSectorProductIterator(a::I, b::I) where {I <: Sector}\n\nCustom iterator to represent the (unique) fusion outputs of a  b.\n\nCustom sectors that aim to use this have to provide the following functionality:\n\nBase.iterate(::SectorProductIterator{I}, state...) where {I <: Sector}: iterate over   the fusion outputs of a ‚äó b\n\nIf desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength(), in which case Base.length(::SectorProductIterator{I}) has to be implemented.\n\nSee also ‚äó.\n\n\n\n\n\n","category":"type"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/fusiontrees/#s_fusiontrees","page":"Fusion trees","title":"Fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric (equivariant) tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors, i.e. they exhibit block sparsity. To exploit this block diagonal form, it is however essential that we know the basis transformation from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section blocksectors and blockdim defined on the type ProductSpace.\n\nThis basis transformation consists of a basis of inclusion and projection maps, denoted as X^a_1a_2a_N_cŒ± R_c  R_a_1  R_a_2    R_a_N and their adjoints (X^a_1a_2a_N_cŒ±)^, such that\n\n(X^a_1a_2a_N_cŒ±)^  X^a_1a_2a_N_cŒ± = Œ¥_cc Œ¥_Œ±Œ± mathrmid_c\n\nand\n\n_cŒ± X^a_1a_2a_N_cŒ±  (X^a_1a_2a_N_cŒ±)^  = mathrmid_a_1  a_2    a_N = mathrmid_a_1  mathrmid_a_2    mathrmid_a_N\n\nFusion trees provide a particular way to construct such a basis. It is useful to know about the existence of fusion trees and how they are represented, as discussed in the first subsection. The next two subsections discuss possible manipulations that can be performed with fusion trees. These are used under the hood when manipulating the indices of tensors, but a typical user would not need to use these manipulations on fusion trees directly. Hence, these last two sections can safely be skipped.","category":"section"},{"location":"man/fusiontrees/#Canonical-representation","page":"Fusion trees","title":"Canonical representation","text":"To couple or fuse the different sectors together into a single block sector, we can sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector, using the splitting tensors X_ab^cŒº  R_c  R_a  R_b and their adjoints. This amounts to the canonical choice of our tensor product, and for a given tensor mapping from (((W_1  W_2)  W_3)   ) W_N_2) to (((V_1  V_2)  V_3)   ) V_N_1), the corresponding fusion and splitting trees take the form\n\n<img src=\"../img/tree-simple.svg\" alt=\"double fusion tree\" class=\"color-invertible\"/>\n\nfor the specific case N_1 = 4 and N_2 = 3. We can separate this tree into the fusing part (b_1  b_2)  b_3  c and the splitting part c(((a_1  a_2)  a_3)  a_4). Given that the fusion tree can be considered to be the adjoint of a corresponding splitting tree c  (b_1  b_2)  b_3, we now first consider splitting trees in isolation. A splitting tree which goes from one coupled sector c to N uncoupled sectors a_1, a_2, ‚Ä¶, a_N needs N-2 additional internal sector labels e_1, ‚Ä¶, e_N-2, and, if FusionStyle(I) isa GenericFusion, N-1 additional multiplicity labels Œº_1, ‚Ä¶, Œº_N-1. We henceforth refer to them as vertex labels, as they are associated with the vertices of the splitting tree. In the case of FusionStyle(I) isa UniqueFusion, the internal sectors e_1, ‚Ä¶, e_N-2 are completely fixed, for FusionStyle(I) isa MultipleFusion they can also take different values. In our abstract notation of the splitting basis X^a_1a_2a_N_cŒ± used above, Œ± can be considered a collective label, i.e. Œ± = (e_1  e_N-2 Œº‚ÇÅ  Œº_N-1). Indeed, we can check the orthogonality condition (X^a_1a_2a_N_cŒ±)^  X^a_1a_2a_N_cŒ± = Œ¥_cc Œ¥_Œ±Œ± mathrmid_c, which now forces all internal lines e_k and vertex labels Œº_l to be the same.\n\nThere is one subtle remark that we have so far ignored. Within the specific subtypes of Sector, we do not explicitly distinguish between R_a^* (simply denoted as a^* and graphically depicted as an upgoing arrow a) and R_bara (simply denoted as bara and depicted with a downgoing arrow), i.e. between the dual space of R_a on which the conjugated irrep acts, or the irrep bara to which the complex conjugate of irrep a is isomorphic. This distinction is however important, when certain uncoupled sectors in the fusion tree actually originate from a dual space. We use the isomorphisms Z_a  R_a^*  R_bara and its adjoint Z_a^  R_bara  R_a^*, as introduced in the section on topological data of a fusion category, to build fusion and splitting trees that take the distinction between irreps and their conjugates into account. Hence, in the previous example, if e.g. the first and third space in the codomain and the second space in the domain of the tensor were dual spaces, the actual pair of splitting and fusion tree would look as\n\n<img src=\"../img/tree-extended.svg\" alt=\"extended double fusion tree\" class=\"color-invertible\"/>\n\nThe presence of these isomorphisms will be important when we start to bend lines, to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. Note that we can still represent the fusion tree as the adjoint of a corresponding splitting tree, because we also use the adjoint of the Z isomorphisms in the splitting part, and the Z isomorphism in the fusion part. Furthermore, the presence of the Z isomorphisms does not affect the orthonormality.\n\nWe represent splitting trees and their adjoints using a specific immutable type called FusionTree (which actually represents a splitting tree, but fusion tree is a more common term), defined as\n\nstruct FusionTree{I<:Sector,N,M,L}\n    uncoupled::NTuple{N,I}\n    coupled::I\n    isdual::NTuple{N,Bool}\n    innerlines::NTuple{M,I} # fixed to M = N-2\n    vertices::NTuple{L,Int} # fixed to L = N-1\nend\n\nHere, the fields are probably self-explanatory. The isdual field indicates whether an isomorphism is present (if the corresponding value is true) or not. Note that the field uncoupled contains the sectors coming out of the splitting trees, before the possible Z isomorphism, i.e. the splitting tree in the above example would have sectors = (a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, a‚ÇÑ). The FusionTree type has a number of basic properties and capabilities, such as checking for equality with == and support for hash(f::FusionTree, h::UInt), as splitting and fusion trees are used as keys in look-up tables (i.e. AbstractDictionary instances) to look up certain parts of the data of a tensor.\n\nFusionTree instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. The most natural way to create them is by using the fusiontrees(uncoupled::NTuple{N, I}, coupled::I = unit(I)) method, which returns an iterator over all possible fusion trees from a set of N uncoupled sectors to a given coupled sector, which by default is assumed to be the trivial sector of that group or fusion category (i.e. the identity object in categorical nomenclature). The return type of fusiontrees is a custom type FusionTreeIterator which conforms to the complete interface of an iterator, and has a custom length function that computes the number of possible fusion trees without iterating over all of them explicitly. This is best illustrated with some examples\n\ns = Irrep[SU‚ÇÇ](1/2)\ncollect(fusiontrees((s, s, s, s)))\ncollect(fusiontrees((s, s, s, s, s), s, (true, false, false, true, false)))\niter = fusiontrees(ntuple(n -> s, 16))\nsum(n -> 1, iter)\nlength(iter)\n@elapsed sum(n -> 1, iter)\n@elapsed length(iter)\ns2 = s ‚ä† s\ncollect(fusiontrees((s2, s2, s2, s2)))\n\nNote that FusionTree instances are shown (printed) in a way that is valid code to reproduce them, a property which also holds for both instances of Sector and instances of VectorSpace. All of those should be displayed in a way that can be copy pasted as valid code. Furthermore, we use context to determine how to print e.g. a sector. In isolation, s2 is printed as (Irrep[SU‚ÇÇ](1/2) ‚ä† Irrep[SU‚ÇÇ](1/2)), however, within the fusion tree, it is simply printed as (1/2, 1/2), because it will be converted back into a ProductSector, namely Irrep[SU‚ÇÇ] ‚ä† Irrep[SU‚ÇÇ] by the constructor of FusionTree{Irrep[SU‚ÇÇ] ‚ä† Irrep[SU‚ÇÇ]}.","category":"section"},{"location":"man/fusiontrees/#Manipulations-on-a-fusion-tree","page":"Fusion trees","title":"Manipulations on a fusion tree","text":"We now discuss elementary manipulations that we want to perform on or between fusion trees (where we actually mean splitting trees), which will form the building block for more general manipulations on a pair of a fusion and splitting tree discussed in the next subsection, and then for casting a general index manipulation of a tensor map as a linear operation in the basis of canonically ordered splitting and fusion trees. In this section, we will ignore the Z isomorphisms, as they are just trivially reshuffled under the different operations that we describe. These manipulations are used as low-level methods by the TensorMap methods discussed on the next page. As such, they are not exported by TensorKit.jl, nor do they overload similarly named methods from Julia Base (see split and merge below).\n\nThe first operation we discuss is an elementary braid of two neighbouring sectors (indices), i.e. a so-called Artin braid or Artin generator of the braid group. Because these two sectors do not appear on the same fusion vertex, some recoupling is necessary. The following represents two different ways to compute the result of such a braid as a linear combination of new fusion trees in canonical order:\n\n<img src=\"../img/tree-artinbraid.svg\" alt=\"artin braid\" class=\"color-invertible\"/>\n\nWhile the upper path is the most intuitive, it requires two recouplings or F-moves (one forward and one reverse). On the other hand, the lower path requires only one (reverse) F- move, and two R-moves. The latter are less expensive to compute, and so the lower path is computationally more efficient. However, the end result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any new subtype of Sector, and it is up to the user to verify that they are when implementing new custom Sector types. This result is implemented in the function artin_braid(f::FusionTree, i; inv = false) where i denotes the position of the first sector (i.e. labeled b in the above graph) which is then braided with the sector at position i+1 in the fusion tree f. The keyword argument inv allows to select the inverse braiding operation, which amounts to replacing the R-matrix with its inverse (or thus, adjoint) in the above steps. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as value. In the case of FusionStyle(I) isa UniqueFusion, their is only one resulting fusion tree, with corresponding coefficient a complex phase (which is one for the bosonic representation theory of an Abelian group), and the result is a special SingletonDict<:AbstractDict, a struct type defined in TensorKit.jl to hold a single key value pair.\n\nWith the elementary artin_braid, we can then compute a more general braid. For this, we provide an interface\n\nbraid(f::FusionTree{I, N}, levels::NTuple{N, Int}, permutation::NTuple{N, Int})\n\nwhere the braid is specified as a permutation, such that the new sector at position i was originally at position permutation[i], and where every uncoupled sector is also assigned a level or depth. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor. This interface does not allow to specify the most general braid, and in particular will never wind one line around another, but can be used as a more general building block for arbitrary braids than the elementary Artin generators. A graphical example makes this probably more clear, i.e for levels = (1, 2, 3, 4, 5) and permutation = (5, 3, 1, 4, 2), the corresponding braid is given by\n\n<img src=\"../img/tree-braidinterface.svg\" alt=\"braid interface\" class=\"color-invertible\"/>\n\nthat is, the first sector or space goes to position 3, and crosses over all other lines, because it has the lowest level (i.e. think of level as depth in the third dimension), and so forth. We sketch this operation both as a general braid on the left hand side, and as a particular composition of Artin braids on the right hand side.\n\nWhen BraidingStyle(I) == SymmetricBraiding(), there is no distinction between applying the braiding or its inverse (i.e. lines crossing over or under each other in the graphical notation) and the whole operation simplifies down to a permutation. We then also support the interface\n\npermute(f::FusionTree{I, N}, permutation::NTuple{N, Int})\n\nOther manipulations which are sometimes needed are\n\ninsertat(f1::FusionTree{I,N‚ÇÅ}, i::Int, f2::FusionTree{I,N‚ÇÇ}) : inserts a fusion tree f2 at the ith uncoupled sector of fusion tree f1 (this requires that the coupled sector f2 matches with the ith uncoupled sector of f1, and that !f1.isdual[i], i.e. that there is no Z-isomorphism on the ith line of f1), and recouple this into a linear combination of trees in canonical order, with N‚ÇÅ + N‚ÇÇ - 1 uncoupled sectors, i.e. diagrammatically for i = 3\n\n<img src=\"../img/tree-insertat.svg\" alt=\"insertat\" class=\"color-invertible\"/>\n\nsplit(f::FusionTree{I,N}, M::Int) : splits a fusion tree f into two trees f1 and f2, such that f1 has the first M uncoupled sectors of f, and f2 the remaining N - M.   This function is type stable if M is a compile time constant.\nsplit(f, M) is the inverse of insertat in the sense that insertat(f2, 1, f1) should return a dictionary with a single key-value pair f=>1.   Diagrammatically, for M = 4, the function split returns\n\n<img src=\"../img/tree-split.svg\" alt=\"split\" class=\"color-invertible\"/>\n\nmerge(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, c::I, [Œº=1]) : merges two fusion trees f1 and f2 by fusing the coupled sectors of f1 and f2 into a sector c (with vertex label Œº if FusionStyle(I) == GenericFusion()), and reexpressing the result as a linear combination of fusion trees with N‚ÇÅ + N‚ÇÇ uncoupled sectors in canonical order.   This is a simple application of insertat.   Diagrammatically, this operation is represented as:\n\n<img src=\"../img/tree-merge.svg\" alt=\"merge\" class=\"color-invertible\"/>","category":"section"},{"location":"man/fusiontrees/#Manipulations-on-a-splitting-fusion-tree-pair","page":"Fusion trees","title":"Manipulations on a splitting - fusion tree pair","text":"In this subsection we discuss manipulations that act on a splitting and fusion tree pair, which we will always as two separate trees f1, f2, where f1 is the splitting tree and f2 represents the fusion tree, and they should have f1.coupled == f2.coupled.\n\nThe most important manipulation on such a pair is to move sectors from one to the other. Given the canonical order of these trees, we exclusively use the left duality (see the section on categories), for which the evaluation and coevaluation maps establish isomorphisms between\n\nbeginaligned\nmathrmHom((((b_1  b_2)  )  b_N_2) (((a_1  a_2)  )  a_N_1))\nmathrmHom((((b_1  b_2)  )  b_N_2-1) ((((a_1  a_2)  )  a_N_1)  b_N_2^*))\nmathrmHom(1 (((((((a_1  a_2)  )  a_N_1)  b_N_2^*)  )  b_2^*)  b_1^*) )\nendaligned\n\nwhere the last morphism space is then labeled by the basis of only splitting trees. We can then use the manipulations from the previous section, and then again use the left duality to bring this back to a pair of splitting and fusion tree with N‚ÇÇ‚Ä≤ incoming and N‚ÇÅ‚Ä≤ incoming sectors (with N‚ÇÅ‚Ä≤ + N‚ÇÇ‚Ä≤ == N‚ÇÅ + N‚ÇÇ).\n\nWe now discuss how to actually bend lines, and thus, move sectors from the incoming part (fusion tree) to the outgoing part (splitting tree). Hereby, we exploit the relations between the (co)evaluation (exact pairing) and the fusion tensors, discussed in topological data of a fusion category. The main ingredient that we need is summarized in\n\n<img src=\"../img/tree-linebending.svg\" alt=\"line bending\" class=\"color-invertible\"/>\n\nWe will only need the B-symbol and not the A-symbol. Applying the left evaluation on the second sector of a splitting tensor thus yields a linear combination of fusion tensors (when FusionStyle(I) == GenericFusion(), or just a scalar times the corresponding fusion tensor otherwise), with corresponding Z ismorphism. Taking the adjoint of this relation yields the required relation to transform a fusion tensor into a splitting tensor with an added Z^ isomorphism.\n\nHowever, we have to be careful if we bend a line on which a Z isomorphism (or its adjoint) is already present. Indeed, it is exactly for this operation that we explicitly need to take the presence of these isomorphisms into account. Indeed, we obtain the relation\n\n<img src=\"../img/tree-linebending2.svg\" alt=\"dual line bending\" class=\"color-invertible\"/>\n\nHence, bending an isdual sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and of course leads to a normal sector (which is no longer isdual and does thus not come with a Z-isomorphism) on the fusion side. We again use the adjoint of this relation to bend an isdual sector from the fusion tree to the splitting tree.\n\nThe FusionTree interface to duality and line bending is given by\n\nrepartition(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, N::Int)\n\nwhich takes a splitting tree f1 with N‚ÇÅ outgoing sectors, a fusion tree f2 with N‚ÇÇ incoming sectors, and applies line bending such that the resulting splitting and fusion trees have N outgoing sectors, corresponding to the first N sectors out of the list (a_1 a_2  a_N_1 b_N_2^*  b_1^*) and N‚ÇÅ + N‚ÇÇ - N incoming sectors, corresponding to the dual of the last N‚ÇÅ + N‚ÇÇ - N sectors from the previous list, in reverse. This return values are correctly inferred if N is a compile time constant.\n\nGraphically, for N‚ÇÅ = 4, N‚ÇÇ = 3, N = 2 and some particular choice of isdual in both the fusion and splitting tree:\n\n<img src=\"../img/tree-repartition.svg\" alt=\"repartition\" class=\"color-invertible\"/>\n\nThe result is returned as a dictionary with keys (f1‚Ä≤, f2‚Ä≤) and the corresponding coeff as value. Note that the summation is only over the Œ∫_j labels, such that, in the case of FusionStyle(I) isa MultiplicityFreeFusion, the linear combination simplifies to a single term with a scalar coefficient.\n\nWith this basic function, we can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear. The interface provided for this is given by\n\nbraid(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, levels1::NTuple{N‚ÇÅ,Int}, levels2::NTuple{N‚ÇÇ,Int}, p1::NTuple{N‚ÇÅ‚Ä≤,Int}, p2::NTuple{N‚ÇÇ‚Ä≤,Int})\n\nwhere we now have splitting tree f1 with N‚ÇÅ outgoing sectors, a fusion tree f2 with N‚ÇÇ incoming sectors, levels1 and levels2 assign a level or depth to the corresponding uncoupled sectors in f1 and f2, and we represent the new configuration as a pair p1 and p2. Together, (p1..., p2...) represents a permutation of length N‚ÇÅ + N‚ÇÇ = N‚ÇÅ‚Ä≤ + N‚ÇÇ‚Ä≤, where p1 indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and p2 indicates which appear as incoming sectors in the new fusion tree. Hereto, we label the uncoupled sectors of f1 from 1 to N‚ÇÅ, followed by the uncoupled sectors of f2 from N‚ÇÅ + 1 to N‚ÇÅ + N‚ÇÇ. Note that simply repartitioning the splitting and fusion tree such that e.g. all sectors appear in the new splitting tree (i.e. are outgoing), amounts to chosing p1 = (1,..., N‚ÇÅ, N‚ÇÅ + N‚ÇÇ, N‚ÇÅ + N‚ÇÇ - 1, ... , N‚ÇÅ + 1) and p2 = (), because the duality isomorphism reverses the order of the tensor product.\n\nThis routine is implemented by indeed first making all sectors outgoing using the repartition function discussed above, such that only splitting trees remain, then braiding those using the routine from the previous subsection such that the new outgoing sectors appear first, followed by the new incoming sectors (in reverse order), and then again invoking the repartition routine to bring everything in final form. The result is again returned as a dictionary where the keys are (f1‚Ä≤, f2‚Ä≤) and the values the corresponding coefficients.\n\nAs before, there is a simplified interface for the case where BraidingStyle(I) isa SymmetricBraiding and the levels are not needed. This is simply given by\n\npermute(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, p1::NTuple{N‚ÇÅ‚Ä≤,Int}, p2::NTuple{N‚ÇÇ‚Ä≤,Int})\n\nThe braid and permute routines for double fusion trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memoized, i.e. they are stored in some package wide 'least-recently used' cache (from LRUCache.jl) that can be accessed as TensorKit. raidcache. By default, this cache stores up to 10^5 different braid or permute resuls, where one result corresponds to one particular combination of (f1, f2, p1, p2, levels1, levels2). This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to resize!(TensorKit.permutecache) and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type RefValue{Bool}, namely usebraidcache_abelian and usebraidcache_nonabelian. The default values are given by TensorKit.usebraidcache_abelian[] = false and TensorKit.usebraidcache_nonabelian[] = true, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with FusionStyle(f) isa UniqueFusion, but is probably useful for fusion trees with FusionStyle(f) isa MultipleFusion. One can change these values and test the effect on their application.\n\nThe existence of braidcache also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.","category":"section"},{"location":"man/fusiontrees/#Inspecting-fusion-trees-as-tensors","page":"Fusion trees","title":"Inspecting fusion trees as tensors","text":"For those cases where the fusion and splitting tensors have an explicit representation as a tensor, i.e. a morphism in the category Vect (this essentially coincides with the case of group representations), this explicit representation can be created, which can be useful for checking purposes. Hereto, it is necessary that the splitting tensor X^ab_cŒº, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine fusiontensor(a, b, c, Œº = nothing), where the last argument is only necessary in the case of FusionStyle(I) == GenericFusion(). We can then convert a FusionTree{I, N} into an Array, which will yield a rank N + 1 array where the first N dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector. Note that this is mostly useful for the case of FusionStyle(I) isa MultipleFusion groups, as in the case of abelian groups, all irreps are one-dimensional.\n\nSome examples:\n\nusing LinearAlgebra # hide\ns = Irrep[SU‚ÇÇ](1/2)\niter = fusiontrees((s, s, s, s), SU2Irrep(1))\nf = first(iter)\nconvert(Array, f)\n\nLinearAlgebra.I ‚âà convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (false,), ()))\nZ = adjoint(convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (true,), ())))\ntranspose(Z) ‚âà frobenius_schur_phase(SU2Irrep(1/2)) * Z\n\nLinearAlgebra.I ‚âà convert(Array, FusionTree((Irrep[SU‚ÇÇ](1),), Irrep[SU‚ÇÇ](1), (false,), ()))\nZ = adjoint(convert(Array, FusionTree((Irrep[SU‚ÇÇ](1),), Irrep[SU‚ÇÇ](1), (true,), ())))\ntranspose(Z) ‚âà frobenius_schur_phase(Irrep[SU‚ÇÇ](1)) * Z\n\n#check orthogonality\nfor f1 in iter\n  for f2 in iter\n    dotproduct  = dot(convert(Array, f1), convert(Array, f2))\n    println(\"<$f1, $f2> = $dotproduct\")\n  end\nend\n\nNote that we take the adjoint when computing Z, because convert(Array, f) assumes f to be splitting tree, which is built using Z^. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the mathrmid_c when checking the orthogonality by computing dot of the corresponding tensors.","category":"section"},{"location":"man/tutorial/#s_tutorial","page":"Tutorial","title":"Tutorial","text":"Before discussing at length all aspects of this package, both its usage and implementation, we start with a short tutorial to sketch the main capabilities. Thereto, we start by loading TensorKit.jl\n\nusing TensorKit","category":"section"},{"location":"man/tutorial/#Cartesian-tensors","page":"Tutorial","title":"Cartesian tensors","text":"The most important objects in TensorKit.jl are tensors, which we now create with random (normally distributed) entries in the following manner\n\nA = randn(‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4)\n\nNote that we entered the tensor size not as plain dimensions, but by specifying the vector space associated with these tensor indices, in this case ‚Ñù^n, which can be obtained by typing \\bbR+TAB. The tensor then lives in the tensor product of the different spaces, which we can obtain by typing ‚äó (i.e. \\otimes+TAB), although for simplicity also the usual multiplication sign * does the job. Note also that A is printed as an instance of a parametric type TensorMap, which we will discuss below and contains Tensor.\n\nLet us briefly sidetrack into the nature of ‚Ñù^n:\n\nV = ‚Ñù^3\ntypeof(V)\nV == CartesianSpace(3)\nsupertype(CartesianSpace)\nsupertype(ElementarySpace)\n\ni.e. ‚Ñù^n can also be created without Unicode using the longer syntax CartesianSpace(n). It is a subtype of ElementarySpace, with a standard (Euclidean) inner product over the real numbers. Furthermore,\n\nW = ‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4\ntypeof(W)\nsupertype(ProductSpace)\nsupertype(CompositeSpace)\n\ni.e. the tensor product of a number of CartesianSpaces is some generic parametric ProductSpace type, specifically ProductSpace{CartesianSpace,N} for the tensor product of N instances of CartesianSpace.\n\nTensors are itself vectors (but not Vectors or even AbstractArrays), so we can compute linear combinations, provided they live in the same space.\n\nB = randn(‚Ñù^3 * ‚Ñù^2 * ‚Ñù^4);\nC = 0.5 * A + 2.5 * B\n\nGiven that they behave as vectors, they also have a scalar product and norm, which they inherit from the Euclidean inner product on the individual ‚Ñù^n spaces:\n\nscalarBA = dot(B, A)\nscalarAA = dot(A, A)\nnormA¬≤ = norm(A)^2\n\nMore generally, our tensor objects implement the full interface layed out in VectorInterface.jl.\n\nIf two tensors live on different spaces, these operations have no meaning and are thus not allowed\n\nB‚Ä≤ = randn(‚Ñù^4 * ‚Ñù^2 * ‚Ñù^3);\nspace(B‚Ä≤) == space(A)\nC‚Ä≤ = 0.5 * A + 2.5 * B‚Ä≤\nscalarBA‚Ä≤ = dot(B‚Ä≤, A)\n\nHowever, in this particular case, we can reorder the indices of B‚Ä≤ to match space of A, using the routine permute (we deliberately choose not to overload permutedims from Julia Base, for reasons that become clear below):\n\nspace(permute(B‚Ä≤, (3, 2, 1))) == space(A)\n\nWe can contract two tensors using Einstein summation convention, which takes the interface from TensorOperations.jl. TensorKit.jl reexports the @tensor macro\n\n@tensor D[a, b, c, d] := A[a, b, e] * B[d, c, e]\n@tensor d = A[a, b, c] * A[a, b, c]\nd ‚âà scalarAA ‚âà normA¬≤\n\nWe hope that the index convention is clear. The := is to create a new tensor D, without the : the result would be written in an existing tensor D, which in this case would yield an error as no tensor D exists. If the contraction yields a scalar, regular assignment with = can be used.\n\nFinally, we can factorize a tensor, creating a bipartition of a subset of its indices and its complement. With a plain Julia Array, one would apply permutedims and reshape to cast the array into a matrix before applying e.g. the singular value decomposition. With TensorKit.jl, one just specifies which indices go to the left (rows) and right (columns) with a tuple of tuples, selecting the respective indices for either side.\n\nA_matrix = permute(A, ((1, 3), (2,)));\nU, S, Vd = svd_compact(A_matrix);\n@tensor A‚Ä≤[a, b, c] := U[a, c, d] * S[d, e] * Vd[e, b];\nA ‚âà A‚Ä≤\nU\n\nNote that the svd_compact routine returns the decomposition of the linear map as three factors, U, S and Vd, each of them a TensorMap, such that Vd is already what is commonly called V'. Furthermore, observe that U is printed differently then A, i.e. as a TensorMap((‚Ñù^3 ‚äó ‚Ñù^4) ‚Üê ProductSpace(‚Ñù^2)). What this means is that tensors (or more appropriately, TensorMap instances) in TensorKit.jl are always considered to be linear maps between two ProductSpace instances, with\n\ncodomain(U)\ndomain(U)\ncodomain(A)\ndomain(A)\n\nAn instance of TensorMap thus represents a linear map from its domain to its codomain, making it an element of the space of homomorphisms between these two spaces. That space is represented using its own type HomSpace in TensorKit.jl, and which admits a direct constructor as well as a unicode alternative using the symbol ‚Üí (obtained as \\to+TAB or \\rightarrow+TAB) or ‚Üê (obtained as \\leftarrow+TAB).\n\nP = space(U)\nspace(U) == HomSpace(‚Ñù^3 ‚äó ‚Ñù^4, ‚Ñù^2) == (‚Ñù^3 ‚äó ‚Ñù^4 ‚Üê ‚Ñù^2) == (‚Ñù^2 ‚Üí ‚Ñù^3 ‚äó ‚Ñù^4)\n(codomain(P), domain(P))\n\nFurthermore, a Tensor instance such as A is just a specific case of TensorMap with an empty domain, i.e. a ProductSpace{CartesianSpace,0} instance. Analogously, we can represent a vector v and matrix m as\n\nv = randn(‚Ñù^3)\nM‚ÇÅ = randn(‚Ñù^4, ‚Ñù^3)\nM‚ÇÇ = randn(‚Ñù^4 ‚Üí ‚Ñù^2) # alternative syntax for randn(‚Ñù^2, ‚Ñù^4)\nw = M‚ÇÅ * v # matrix-vector product\nM‚ÇÉ = M‚ÇÇ * M‚ÇÅ # matrix-matrix product\nspace(M‚ÇÉ)\n\nNote that for the construction of M‚ÇÅ, in accordance with how one specifies the dimensions of a matrix (e.g. randn(4, 3)), the first space is the codomain and the second the domain. This is somewhat opposite to the general notation for a function f  textdomain rightarrow textcodomain, so that we also support this more mathematical notation, as illustrated in the construction of M‚ÇÇ. However, as this is confusing from the perspective of rows and columns, we also support the syntax codomain ‚Üê domain and actually use this as the default way of printing HomSpace instances.\n\nThe matrix-vector or matrix-matrix product can be computed between any two TensorMap instances for which the domain of the first matches with the codomain of the second, e.g.\n\nv‚Ä≤ = v ‚äó v\nM‚ÇÅ‚Ä≤ = M‚ÇÅ ‚äó M‚ÇÅ\nw‚Ä≤ = M‚ÇÅ‚Ä≤ * v‚Ä≤\nw‚Ä≤ ‚âà w ‚äó w\n\nAnother example involves checking that U from the singular value decomposition is a unitary, or at least a (left) isometric tensor\n\ncodomain(U)\ndomain(U)\nspace(U)\nU' * U # should be the identity on the corresponding domain = codomain\nU' * U ‚âà one(U' * U)\nP = U * U' # should be a projector\nP * P ‚âà P\n\nHere, the adjoint of a TensorMap results in a new tensor map (actually a simple wrapper of type AdjointTensorMap <: AbstractTensorMap) with domain and codomain interchanged.\n\nOur original tensor A living in ‚Ñù^4 * ‚Ñù^2 * ‚Ñù^3 is isomorphic to e.g. a linear map ‚Ñù^3 ‚Üí ‚Ñù^4 * ‚Ñù^2. This is where the full power of permute emerges. It allows to specify a permutation where some indices go to the codomain, and others go to the domain, as in\n\nA2 = permute(A, ((1, 2), (3,)))\ncodomain(A2)\ndomain(A2)\n\nIn fact, this was already what we used in svd_compact(A_matrix) to create the matricized tensor A_matrix, and where svd_compact(A::AbstractTensorMap) will just compute the singular value decomposition according to the given codomain and domain of A.\n\nNote, finally, that the @tensor macro treats all indices at the same footing and thus does not distinguish between codomain and domain. The linear numbering is first all indices in the codomain, followed by all indices in the domain. However, when @tensor creates a new tensor (i.e. when using :=), the default syntax always creates a Tensor, i.e. with all indices in the codomain.\n\n@tensor A‚Ä≤[a, b, c] := U[a, c, d] * S[d, e] * Vd[e, b];\ncodomain(A‚Ä≤)\ndomain(A‚Ä≤)\n@tensor A2‚Ä≤[(a, b); (c,)] := U[a, c, d] * S[d, e] * Vd[e, b];\ncodomain(A2‚Ä≤)\ndomain(A2‚Ä≤)\n@tensor A2‚Ä≤‚Ä≤[a b; c] := U[a, c, d] * S[d, e] * Vd[e, b];\nA2 ‚âà A2‚Ä≤ == A2‚Ä≤‚Ä≤\n\nAs illustrated for A2‚Ä≤ and A2‚Ä≤‚Ä≤, additional syntax is available that enables one to immediately specify the desired codomain and domain indices.","category":"section"},{"location":"man/tutorial/#Complex-tensors","page":"Tutorial","title":"Complex tensors","text":"For applications in e.g. quantum physics, we of course want to work with complex tensors. Trying to create a complex-valued tensor with CartesianSpace indices is of course somewhat contrived and prints a (one-time) warning\n\nA = randn(ComplexF64, ‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4)\n\nalthough most of the above operations will work in the expected way (at your own risk). Indeed, we instead want to work with complex vector spaces\n\nA = randn(ComplexF64, ‚ÑÇ^3 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^4)\n\nwhere ‚ÑÇ is obtained as \\bbC+TAB and we also have the non-Unicode alternative ‚ÑÇ^n == ComplexSpace(n). Most functionality works exactly the same\n\nB = randn(‚ÑÇ^3 * ‚ÑÇ^2 * ‚ÑÇ^4);\nC = im * A + (2.5 - 0.8im) * B\nscalarBA = dot(B, A)\nscalarAA = dot(A, A)\nnormA¬≤ = norm(A)^2\nU, S, Vd = svd_compact(permute(A, ((1, 3), (2,))));\n@tensor A‚Ä≤[a, b, c] := U[a, c, d] * S[d, e] * Vd[e, b];\nA‚Ä≤ ‚âà A\npermute(A, ((1, 3), (2,))) ‚âà U * S * Vd\n\nHowever, trying the following\n\n@tensor D[a, b, c, d] := A[a, b, e] * B[d, c, e]\n@tensor d = A[a, b, c] * A[a, b, c]\n\nwe obtain SpaceMismatch errors. The reason for this is that, with ComplexSpace, an index in a space ‚ÑÇ^n can only be contracted with an index in the dual space dual(‚ÑÇ^n) == (‚ÑÇ^n)'. Because of the complex Euclidean inner product, the dual space is equivalent to the complex conjugate space, but not the space itself.\n\ndual(‚ÑÇ^3) == conj(‚ÑÇ^3) == (‚ÑÇ^3)'\n(‚ÑÇ^3)' == ‚ÑÇ^3\n@tensor d = conj(A[a, b, c]) * A[a, b, c]\nd ‚âà normA¬≤\n\nThis might seem overly strict or puristic, but we believe that it can help to catch errors, e.g. unintended contractions. In particular, contracting two indices both living in ‚ÑÇ^n would represent an operation that is not invariant under arbitrary unitary basis changes.\n\nIt also makes clear the isomorphism between linear maps ‚ÑÇ^n ‚Üí ‚ÑÇ^m and tensors in ‚ÑÇ^m ‚äó (‚ÑÇ^n)':\n\nm = randn(ComplexF64, ‚ÑÇ^3, ‚ÑÇ^4)\nm2 = permute(m, ((1, 2), ()))\ncodomain(m2)\nspace(m, 1)\nspace(m, 2)\n\nHence, spaces become their corresponding dual space if they are 'permuted' from the domain to the codomain or vice versa. Also, spaces in the domain are reported as their dual when probing them with space(A, i). Generalizing matrix-vector and matrix-matrix multiplication to arbitrary tensor contractions require that the two indices to be contracted have spaces which are each others dual. Knowing this, all the other functionality of tensors with CartesianSpace indices remains the same for tensors with ComplexSpace indices.","category":"section"},{"location":"man/tutorial/#ss_tutorial_symmetries","page":"Tutorial","title":"Symmetries","text":"So far, the functionality that we have illustrated seems to be just a convenient (or inconvenient?) wrapper around dense multidimensional arrays, e.g. Julia's Base Array. More power becomes visible when involving symmetries. With symmetries, we imply that there is some symmetry action defined on every vector space associated with each of the indices of a TensorMap, and the TensorMap is then required to be equivariant, i.e. it acts as an intertwiner between the tensor product representation on the domain and that on the codomain. By Schur's lemma, this means that the tensor is block diagonal in some basis corresponding to the irreducible representations that can be coupled to by combining the different representations on the different spaces in the domain or codomain. For Abelian symmetries, this does not require a basis change and it just imposes that the tensor has some block sparsity. Let's clarify all of this with some examples.\n\nWe start with a simple ‚Ñ§‚ÇÇ symmetry:\n\nV1 = ‚Ñ§‚ÇÇSpace(0=>3, 1=>2)\ndim(V1)\nV2 = ‚Ñ§‚ÇÇSpace(0=>1, 1=>1)\ndim(V2)\nA = randn(V1 * V1 * V2')\nconvert(Array, A)\n\nHere, we create a 5-dimensional space V1, which has a three-dimensional subspace associated with charge 0 (the trivial irrep of ‚Ñ§‚ÇÇ) and a two-dimensional subspace with charge 1 (the non-trivial irrep). Similar for V2, where both subspaces are one-dimensional. Representing the tensor as a dense Array, we see that it is zero in those regions where the charges don't add to zero (modulo 2). Of course, the Tensor(Map) type in TensorKit.jl won't store these zero blocks, and only stores the non-zero information, which we can recognize also in the full Array representation.\n\nFrom there on, the resulting tensors support all of the same operations as the ones we encountered in the previous examples.\n\nB = randn(V1' * V1 * V2);\n@tensor C[a, b] := A[a, c, d] * B[c, b, d]\nU, S, V = svd_compact(permute(A, ((1, 3), (2,))));\nU' * U # should be the identity on the corresponding domain = codomain\nU' * U ‚âà one(U'*U)\nP = U * U' # should be a projector\nP * P ‚âà P\n\nWe also support other abelian symmetries, e.g.\n\nV = U‚ÇÅSpace(0 => 2, 1 => 1, -1 => 1)\ndim(V)\nA = randn(V * V, V)\ndim(A)\nconvert(Array, A)\n\nV = Rep[U‚ÇÅ √ó ‚Ñ§‚ÇÇ]((0, 0) => 2, (1, 1) => 1, (-1, 0) => 1)\ndim(V)\nA = randn(V * V, V)\ndim(A)\nconvert(Array, A)\n\nHere, the dim of a TensorMap returns the number of linearly independent components, i.e.  the number of non-zero entries in the case of an abelian symmetry. Also note that we can use √ó (obtained as \\times+TAB) to combine different symmetry groups. The general space associated with symmetries is a GradedSpace, which is parametrized to the type of symmetry. For a group G, the fully specified type can be obtained as Rep[G], while for more general sectortypes I it can be constructed as Vect[I]. Furthermore, ‚Ñ§‚ÇÇSpace (also Z2Space as non-Unicode alternative) and U‚ÇÅSpace (or U1Space) are just convenient synonyms, e.g.\n\nRep[U‚ÇÅ](0 => 3, 1 => 2, -1 => 1) == U1Space(-1 => 1, 1 => 2, 0 => 3)\nV = U‚ÇÅSpace(1 => 2, 0 => 3, -1 => 1)\nfor s in sectors(V)\n  @show s, dim(V, s)\nend\nU‚ÇÅSpace(-1 => 1, 0 => 3, 1 => 2) == GradedSpace(Irrep[U‚ÇÅ](1) => 2, Irrep[U‚ÇÅ](0) => 3, Irrep[U‚ÇÅ](-1) => 1)\nsupertype(GradedSpace)\n\nNote that GradedSpace is not immediately parameterized by some group G, but actually by the set of irreducible representations of G, denoted as Irrep[G]. Indeed, GradedSpace also supports a grading that is derived from the fusion ring of a (unitary) pre-fusion category. Note furthermore that the order in which the charges and their corresponding subspace dimensionality are specified is irrelevant, and that the charges, henceforth called sectors (which is a more general name for charges or quantum numbers) are of a specific type, in this case Irrep[U‚ÇÅ] == U1Irrep. However, the Vect[I] constructor automatically converts the keys in the list of Pairs it receives to the correct type. Alternatively, we can directly create the sectors of the correct type and use the generic GradedSpace constructor. We can probe the subspace dimension of a certain sector s in a space V with dim(V, s). Finally, note that GradedSpace still has the standard Euclidean inner product and we assume all representations to be unitary.\n\nTensorKit.jl also allows for non-abelian symmetries such as SU‚ÇÇ. In this case, the vector space is characterized via the spin quantum number (i.e. the irrep label of SU‚ÇÇ) for each of its subspaces, and is created using SU‚ÇÇSpace (or SU2Space or Rep[SU‚ÇÇ] or Vect[Irrep[SU‚ÇÇ]])\n\nV = SU‚ÇÇSpace(0 => 2, 1/2 => 1, 1 => 1)\ndim(V)\nV == Vect[Irrep[SU‚ÇÇ]](0 => 2, 1 => 1, 1 // 2 => 1)\n\nNote that now V has a two-dimensional subspace with spin zero, and two one-dimensional subspaces with spin 1/2 and spin 1. However, a subspace with spin j has an additional 2j + 1 dimensional degeneracy on which the irreducible representation acts. This brings the total dimension to 2*1 + 1*2 + 1*3. Creating a tensor with SU‚ÇÇ symmetry yields\n\nA = randn(V * V, V)\ndim(A)\nconvert(Array, A)\nnorm(A) ‚âà norm(convert(Array, A))\n\nIn this case, the full Array representation of the tensor has again many zeros, but it is less obvious to recognize the dense blocks, as there are additional zeros and the numbers in the original tensor data do not match with those in the Array. The reason is of course that the original tensor data now needs to be transformed with a construction known as fusion trees, which are made up out of the Clebsch-Gordan coefficients of the group. Indeed, note that the non-zero subblocks are also no longer labeled by a list of sectors, but by pairs of fusion trees. This will be explained further in the manual. However, the Clebsch-Gordan coefficients of the group are only needed to actually convert a tensor to an Array. For working with tensors with SU‚ÇÇSpace indices, e.g. contracting or factorizing them, the Clebsch-Gordan coefficients are never needed explicitly. Instead, recoupling relations are used to symbolically manipulate the basis of fusion trees, and this only requires what is known as the topological data of the group (or its representation theory).\n\nIn fact, this formalism extends beyond the case of group representations on vector spaces, and can also deal with super vector spaces (to describe fermions) and more general (unitary) fusion categories. Support for all of these generalizations is present in TensorKit.jl. Indeed, all of these concepts will be explained throughout the remainder of this manual, including several details regarding their implementation. However, to just use tensors and their manipulations (contractions, factorizations, ...) in higher level algorithms (e.g. tensoer network algorithms), one does not need to know or understand most of these details, and one can immediately refer to the general interface of the TensorMap type, discussed on the last page. Adhering to this interface should yield code and algorithms that are oblivious to the underlying symmetries and can thus work with arbitrary symmetric tensors.","category":"section"},{"location":"lib/spaces/#s_libvectorspaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"lib/spaces/#Type-hierarchy","page":"Vector spaces","title":"Type hierarchy","text":"The following types are defined to characterise vector spaces and their properties:\n\ntogether with the following specific type for encoding the inner product structure of a space:","category":"section"},{"location":"lib/spaces/#Useful-constants","page":"Vector spaces","title":"Useful constants","text":"The following constants are defined to easily create the concrete type of GradedSpace associated with a given type of sector.\n\nIn this respect, there are also a number of type aliases for the GradedSpace types associated with the most common sectors, namely\n\nconst ZNSpace{N} = Vect[ZNIrrep{N}]\nconst Z2Space = ZNSpace{2}\nconst Z3Space = ZNSpace{3}\nconst Z4Space = ZNSpace{4}\nconst U1Space = Rep[U‚ÇÅ]\nconst CU1Space = Rep[CU‚ÇÅ]\nconst SU2Space = Rep[SU‚ÇÇ]\n\n# Unicode alternatives\nconst ‚Ñ§‚ÇÇSpace = Z2Space\nconst ‚Ñ§‚ÇÉSpace = Z3Space\nconst ‚Ñ§‚ÇÑSpace = Z4Space\nconst U‚ÇÅSpace = U1Space\nconst CU‚ÇÅSpace = CU1Space\nconst SU‚ÇÇSpace = SU2Space","category":"section"},{"location":"lib/spaces/#s_spacemethods","page":"Vector spaces","title":"Methods","text":"Methods often apply similar to e.g. spaces and corresponding tensors or tensor maps, e.g.:\n\nThe following methods act specifically on ElementarySpace spaces:\n\nwhile the following also work on both ElementarySpace and ProductSpace\n\nInserting trivial space factors or removing such factors for ProductSpace instances can be done with the following methods.\n\nThere are also specific methods for HomSpace instances, that are used in determining the resulting HomSpace after applying certain tensor operations.","category":"section"},{"location":"lib/spaces/#TensorKit.Field","page":"Vector spaces","title":"TensorKit.Field","text":"abstract type Field end\n\nAbstract type at the top of the type hierarchy for denoting fields over which vector spaces (or more generally, linear categories) can be defined. Two common fields are ‚Ñù and ‚ÑÇ, representing the field of real or complex numbers respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.VectorSpace","page":"Vector spaces","title":"TensorKit.VectorSpace","text":"abstract type VectorSpace end\n\nAbstract type at the top of the type hierarchy for denoting vector spaces, or, more generally, objects in linear monoidal categories.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ElementarySpace","page":"Vector spaces","title":"TensorKit.ElementarySpace","text":"abstract type ElementarySpace <: VectorSpace\n\nElementary finite-dimensional vector space over a field that can be used as the index space corresponding to the indices of a tensor. ElementarySpace is a supertype for all vector spaces (objects) that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace.\n\nEvery elementary vector space should respond to the methods conj and dual, returning the complex conjugate space and the dual space respectively. The complex conjugate of the dual space is obtained as dual(conj(V)) === conj(dual(V)). These different spaces should be of the same type, so that a tensor can be defined as an element of a homogeneous tensor product of these spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GeneralSpace","page":"Vector spaces","title":"TensorKit.GeneralSpace","text":"struct GeneralSpace{ùîΩ} <: ElementarySpace\nGeneralSpace{ùîΩ}(d::Integer = 0; dual::Bool = false, conj::Bool = false)\n\nA finite-dimensional space over an arbitrary field ùîΩ without additional structure. It is thus characterized by its dimension, and whether or not it is the dual and/or conjugate space. For a real field ùîΩ, the space and its conjugate are the same.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CartesianSpace","page":"Vector spaces","title":"TensorKit.CartesianSpace","text":"struct CartesianSpace <: ElementarySpace\nCartesianSpace(d::Integer = 0; dual = false)\n‚Ñù^d\n\nA real Euclidean space ‚Ñù^d. CartesianSpace has no additonal structure and is completely characterised by its dimension d. A dual keyword argument is accepted for compatibility with other space constructors, but is ignored since the dual of a Cartesian space is isomorphic to itself. This is the vector space that is implicitly assumed in most of matrix algebra.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ComplexSpace","page":"Vector spaces","title":"TensorKit.ComplexSpace","text":"struct ComplexSpace <: ElementarySpace\nComplexSpace(d::Integer = 0; dual = false)\n‚ÑÇ^d\n\nA standard complex vector space ‚ÑÇ^d with Euclidean inner product and no additional structure. It is completely characterised by its dimension and whether its the normal space or its dual (which is canonically isomorphic to the conjugate space).\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GradedSpace","page":"Vector spaces","title":"TensorKit.GradedSpace","text":"struct GradedSpace{I<:Sector, D} <: ElementarySpace\nGradedSpace{I,D}(dims; dual::Bool = false) where {I<:Sector, D}\n\nA complex Euclidean space with a grading, i.e. a direct sum structure corresponding to labels in a set I, the objects of which have the structure of a monoid with respect to a monoidal product ‚äó. In practice, we restrict the label set to be a set of superselection sectors of type I<:Sector, e.g. the set of distinct irreps of a finite or compact group, or the isomorphism classes of simple objects of a unitary and pivotal (pre-, multi-) fusion category.\n\nHere dims represents the degeneracy or multiplicity of every sector.\n\nThe data structure D of dims will depend on the result Base.IteratorSize(values(I)). If the result is of type HasLength or HasShape, dims will be stored in a NTuple{N,Int} with N = length(values(I)). This requires that a sector s::I can be transformed into an index via s == getindex(values(I), i) and i == findindex(values(I), s). If Base.IteratorElsize(values(I)) results IsInfinite() or SizeUnknown(), a SectorDict{I,Int} is used to store the non-zero degeneracy dimensions with the corresponding sector as key. The parameter D is hidden from the user and should typically be of no concern.\n\nThe concrete type GradedSpace{I,D} with correct D can be obtained as Vect[I], or if I == Irrep[G] for some G<:Group, as Rep[G].\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CompositeSpace","page":"Vector spaces","title":"TensorKit.CompositeSpace","text":"abstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end\n\nAbstract type for composite spaces that are defined in terms of a number of elementary vector spaces of a homogeneous type S<:ElementarySpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ProductSpace","page":"Vector spaces","title":"TensorKit.ProductSpace","text":"struct ProductSpace{S <: ElementarySpace, N} <: CompositeSpace{S}\nProductSpace(spaces::NTuple{N, S}) where {S <: ElementarySpace, N}\n\nA ProductSpace is a tensor product space of N vector spaces of type S <: ElementarySpace. Only tensor products between ElementarySpace objects of the same type are allowed.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.HomSpace","page":"Vector spaces","title":"TensorKit.HomSpace","text":"struct HomSpace{S<:ElementarySpace, P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}\nHomSpace(codomain::CompositeSpace{S}, domain::CompositeSpace{S}) where {S<:ElementarySpace}\n\nRepresents the linear space of morphisms with codomain of type P1 and domain of type P2. Note that HomSpace is not a subtype of VectorSpace, i.e. we restrict the latter to denote categories and their objects, and keep HomSpace distinct.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.InnerProductStyle","page":"Vector spaces","title":"TensorKit.InnerProductStyle","text":"abstract type InnerProductStyle end\nInnerProductStyle(V::VectorSpace) -> ::InnerProductStyle\nInnerProductStyle(S::Type{<:VectorSpace}) -> ::InnerProductStyle\n\nTrait to describe wether vector spaces exhibit an inner product structure, a.k.a. a unitary structure, which can take the following values:\n\nEuclideanInnerProduct(): the metric is the identity, making dual and conjugate spaces equivalent\nNoInnerProduct(): no metric and thus no relation between dual(V) or conj(V)\n\nFurthermore, EuclideanInnerProduct is a subtype of HasInnerProduct, indicating that an inner product exists, and an isomorphism between the dual space and the conjugate space can be constructed. New inner product styles can be defined that subtype HasInnerProduct, for example to work with vector spaces with non-trivial metrics. However, at the moment TensorKit does not provide built-in support for such non-standard inner products.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.Vect","page":"Vector spaces","title":"TensorKit.Vect","text":"const Vect\n\nA constant of a singleton type used as Vect[I] with I<:Sector a type of sector, to construct or obtain the concrete type GradedSpace{I,D} instances without having to specify D.\n\n\n\n\n\n","category":"constant"},{"location":"lib/spaces/#TensorKit.Rep","page":"Vector spaces","title":"TensorKit.Rep","text":"const Rep\n\nA constant of a singleton type used as Rep[G] with G<:Group a type of group, to construct or obtain the concrete type GradedSpace{Irrep[G],D} instances without having to specify D. Note that Rep[G] == Vect[Irrep[G]].\n\nSee also Irrep and Vect.\n\n\n\n\n\n","category":"constant"},{"location":"lib/spaces/#TensorKit.field","page":"Vector spaces","title":"TensorKit.field","text":"field(a) -> Type{ùîΩ <: Field}\nfield(::Type{T}) -> Type{ùîΩ <: Field}\n\nReturn the type of field over which object a (e.g. a vector space or a tensor) is defined. This also works in type domain.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectortype","page":"Vector spaces","title":"TensorKit.sectortype","text":"sectortype(a) -> Type{<:Sector}\nsectortype(::Type) -> Type{<:Sector}\n\nReturn the type of sector over which object a (e.g. a representation space or a tensor) is defined. Also works in type domain.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectors","page":"Vector spaces","title":"TensorKit.sectors","text":"sectors(V::ElementarySpace)\n\nReturn an iterator over the different sectors of V.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.hassector","page":"Vector spaces","title":"TensorKit.hassector","text":"hassector(V::VectorSpace, a::Sector) -> Bool\n\nReturn whether a vector space V has a subspace corresponding to sector a with non-zero dimension, i.e. dim(V, a) > 0.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKitSectors.dim-Tuple{VectorSpace}","page":"Vector spaces","title":"TensorKitSectors.dim","text":"dim(V::VectorSpace) -> Int\n\nReturn the total dimension of the vector space V as an Int.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKitSectors.dim-Tuple{ElementarySpace, Sector}","page":"Vector spaces","title":"TensorKitSectors.dim","text":"dim(V::ElementarySpace, s::Sector) -> Int\n\nReturn the degeneracy dimension corresponding to the sector s of the vector space V.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.reduceddim","page":"Vector spaces","title":"TensorKit.reduceddim","text":"reduceddim(V::ElementarySpace) -> Int\n\nReturn the sum of all degeneracy dimensions of the vector space V.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKitSectors.dim-Union{Tuple{N}, Tuple{ProductSpace{<:ElementarySpace, N}, NTuple{N, var\"#s603\"} where var\"#s603\"<:Sector}} where N","page":"Vector spaces","title":"TensorKitSectors.dim","text":"dim(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) where {S<:ElementarySpace}\n-> Int\n\nReturn the total degeneracy dimension corresponding to a tuple of sectors for each of the spaces in the tensor product, obtained as prod(dims(P, s))`.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKitSectors.dim-Tuple{HomSpace}","page":"Vector spaces","title":"TensorKitSectors.dim","text":"dim(W::HomSpace)\n\nReturn the total dimension of a HomSpace, i.e. the number of linearly independent morphisms that can be constructed within this space.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.dims","page":"Vector spaces","title":"TensorKit.dims","text":"dims(::ProductSpace{S, N}) -> Dims{N} = NTuple{N, Int}\ndims(V::HomSpace) -> Dims{length(V)}\ndims(t::AbstractTensorMap) -> Dims{numind(t)}\n\nReturn the dimensions of the spaces in the tensor product space(s) as a tuple of integers.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.blocksectors-Union{Tuple{ProductSpace{S, N}}, Tuple{N}, Tuple{S}} where {S, N}","page":"Vector spaces","title":"TensorKit.blocksectors","text":"blocksectors(P::ProductSpace)\n\nReturn an iterator over the different unique coupled sector labels, i.e. the different fusion outputs that can be obtained by fusing the sectors present in the different spaces that make up the ProductSpace instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.blocksectors-Tuple{HomSpace}","page":"Vector spaces","title":"TensorKit.blocksectors","text":"blocksectors(W::HomSpace)\n\nReturn an iterator over the different unique coupled sector labels, i.e. the intersection of the different fusion outputs that can be obtained by fusing the sectors present in the domain, as well as from the codomain.\n\nSee also hasblock.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.hasblock","page":"Vector spaces","title":"TensorKit.hasblock","text":"hasblock(P::ProductSpace, c::Sector)\n\nQuery whether a coupled sector c appears with nonzero dimension in P, i.e. whether blockdim(P, c) > 0.\n\nSee also blockdim and blocksectors.\n\n\n\n\n\nhasblock(W::HomSpace, c::Sector)\n\nQuery whether a coupled sector c appears in both the codomain and domain of W.\n\nSee also blocksectors.\n\n\n\n\n\nhasblock(t::AbstractTensorMap, c::Sector) -> Bool\n\nVerify whether a tensor has a block corresponding to a coupled sector c.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.blockdim","page":"Vector spaces","title":"TensorKit.blockdim","text":"blockdim(P::ProductSpace, c::Sector)\n\nReturn the total dimension of a coupled sector c in the product space, by summing over all dim(P, s) for all tuples of sectors s::NTuple{N, Sector} that can fuse to  c, counted with the correct multiplicity (i.e. number of ways in which s can fuse to c).\n\nSee also hasblock and blocksectors.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.fusiontrees-Union{Tuple{I}, Tuple{N}, Tuple{S}, Tuple{ProductSpace{S, N}, I}} where {S, N, I}","page":"Vector spaces","title":"TensorKit.fusiontrees","text":"fusiontrees(P::ProductSpace, blocksector::Sector)\n\nReturn an iterator over all fusion trees that can be formed by fusing the sectors present in the different spaces that make up the ProductSpace instance into the coupled sector blocksector.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.space","page":"Vector spaces","title":"TensorKit.space","text":"space(a) -> VectorSpace\n\nReturn the vector space associated to object a.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKitSectors.dual-Tuple{VectorSpace}","page":"Vector spaces","title":"TensorKitSectors.dual","text":"dual(V::VectorSpace) -> VectorSpace\n\nReturn the dual space of V; also obtained via V'. This should satisfy dual(dual(V)) == V. It is assumed that typeof(V) == typeof(V').\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#Base.conj","page":"Vector spaces","title":"Base.conj","text":"conj(V::VectorSpace) -> VectorSpace\n\nReturn the conjugate space of V. This should satisfy conj(conj(V)) == V. For vector spaces over the real numbers, it must hold that conj(V) == V. For vector spaces with a Euclidean inner product, it must hold that conj(V) == dual(V).\n\n\n\n\n\nconj(V::S) where {S<:ElementarySpace} -> S\n\nReturn the conjugate space of V. This should satisfy conj(conj(V)) == V.\n\nFor field(V)==‚Ñù, conj(V) == V. It is assumed that typeof(V) == typeof(conj(V)).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.isconj","page":"Vector spaces","title":"TensorKit.isconj","text":"isconj(V::ElementarySpace) -> Bool\n\nReturn whether an ElementarySpace V is normal or rather the conjugated space. Always returns false for spaces where V == conj(V), i.e. vector spaces over ‚Ñù.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.isdual","page":"Vector spaces","title":"TensorKit.isdual","text":"isdual(V::ElementarySpace) -> Bool\n\nReturn whether an ElementarySpace V is normal or rather a dual space. Always returns false for spaces where V == dual(V).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.flip","page":"Vector spaces","title":"TensorKit.flip","text":"flip(V::S) where {S<:ElementarySpace} -> S\n\nReturn a single vector space of type S that has the same value of isdual as dual(V), but yet is isomorphic to V rather than to dual(V). The spaces flip(V) and dual(V) only differ in the case of GradedSpace{I}.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.zerospace","page":"Vector spaces","title":"TensorKit.zerospace","text":"zerospace(V::S) where {S <: ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the zero-dimensional or empty space. This is the zero element of the direct sum of vector spaces. Base.zero falls back to zerospace.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.unitspace","page":"Vector spaces","title":"TensorKit.unitspace","text":"unitspace(V::S) where {S <: ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the trivial one-dimensional space, i.e. the space that is isomorphic to the corresponding field. For vector spaces where I = sectortype(S) has a semi-simple unit structure (UnitStyle(I) == GenericUnit()), this returns a multi-dimensional space corresponding to all unit sectors: dim(unitspace(V), s) == 1 for all s in allunits(I). \n\nnote: Note\nunitspace(V)is different from one(V). The latter returns the empty product space ProductSpace{S,0}(()). Base.oneunit falls back to unitspace.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:‚äï","page":"Vector spaces","title":"TensorKit.:‚äï","text":"‚äï(V‚ÇÅ::S, V‚ÇÇ::S, V‚ÇÉ::S...) where {S<:ElementarySpace} -> S\noplus(V‚ÇÅ::S, V‚ÇÇ::S, V‚ÇÉ::S...) where {S<:ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the direct sum sum of the spaces V‚ÇÅ, V‚ÇÇ, ... Note that all the individual spaces should have the same value for isdual, as otherwise the direct sum is not defined.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:‚äñ","page":"Vector spaces","title":"TensorKit.:‚äñ","text":"‚äñ(V::ElementarySpace, W::ElementarySpace) -> X::ElementarySpace\nominus(V::ElementarySpace, W::ElementarySpace) -> X::ElementarySpace\n\nReturn a space that is equivalent to the orthogonal complement of W in V, i.e. an instance X::ElementarySpace such that V = W ‚äï X.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.supremum","page":"Vector spaces","title":"TensorKit.supremum","text":"supremum(V‚ÇÅ::ElementarySpace, V‚ÇÇ::ElementarySpace, V‚ÇÉ::ElementarySpace...)\n\nReturn the supremum of a number of elementary spaces, i.e. an instance V::ElementarySpace such that V ‚âø V‚ÇÅ, V ‚âø V‚ÇÇ, ... and no other W ‚â∫ V has this property. This requires that all arguments have the same value of isdual( ), and also the return value V will have the same value.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.infimum","page":"Vector spaces","title":"TensorKit.infimum","text":"infimum(V‚ÇÅ::ElementarySpace, V‚ÇÇ::ElementarySpace, V‚ÇÉ::ElementarySpace...)\n\nReturn the infimum of a number of elementary spaces, i.e. an instance V::ElementarySpace such that V ‚âæ V‚ÇÅ, V ‚âæ V‚ÇÇ, ... and no other W ‚âª V has this property. This requires that all arguments have the same value of isdual( ), and also the return value V will have the same value.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.fuse","page":"Vector spaces","title":"TensorKit.fuse","text":"fuse(V‚ÇÅ::S, V‚ÇÇ::S, V‚ÇÉ::S...) where {S<:ElementarySpace} -> S\nfuse(P::ProductSpace{S}) where {S<:ElementarySpace} -> S\n\nReturn a single vector space of type S that is isomorphic to the fusion product of the individual spaces V‚ÇÅ, V‚ÇÇ, ..., or the spaces contained in P.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.one-Tuple{VectorSpace}","page":"Vector spaces","title":"Base.one","text":"one(::S) where {S <: ElementarySpace} -> ProductSpace{S, 0}\none(::ProductSpace{S}) where {S <: ElementarySpace} -> ProductSpace{S, 0}\n\nReturn a tensor product of zero spaces of type S, i.e. this is the unit object under the tensor product operation, such that V ‚äó one(V) == V.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKitSectors.:‚äó-Tuple{VectorSpace, VectorSpace}","page":"Vector spaces","title":"TensorKitSectors.:‚äó","text":"‚äó(V‚ÇÅ::S, V‚ÇÇ::S, V‚ÇÉ::S...) where {S<:ElementarySpace} -> S\n\nCreate a ProductSpace{S}(V‚ÇÅ, V‚ÇÇ, V‚ÇÉ...) representing the tensor product of several elementary vector spaces. For convience, Julia's regular multiplication operator * applied to vector spaces has the same effect.\n\nThe tensor product structure is preserved, see fuse for returning a single elementary space of type S that is isomorphic to this tensor product.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKitSectors.:‚ä†-Tuple{VectorSpace, VectorSpace}","page":"Vector spaces","title":"TensorKitSectors.:‚ä†","text":"‚ä†(V‚ÇÅ::VectorSpace, V‚ÇÇ::VectorSpace)\n\nGiven two vector spaces V‚ÇÅ and V‚ÇÇ (ElementarySpace or ProductSpace), or thus, objects of corresponding fusion categories C‚ÇÅ and C‚ÇÇ, V‚ÇÅ  V‚ÇÇ constructs the Deligne tensor product, an object in C‚ÇÅ  C‚ÇÇ which is the natural tensor product of those categories. In particular, the corresponding type of sectors (simple objects) is given by sectortype(V‚ÇÅ ‚ä† V‚ÇÇ) == sectortype(V‚ÇÅ) ‚ä† sectortype(V‚ÇÇ) and can be thought of as a tuple of the individual sectors.\n\nThe Deligne tensor product also works in the type domain and for sectors and tensors. For group representations, we have Rep[G‚ÇÅ] ‚ä† Rep[G‚ÇÇ] == Rep[G‚ÇÅ √ó G‚ÇÇ], i.e. these are the natural representation spaces of the direct product of two groups.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.ismonomorphic","page":"Vector spaces","title":"TensorKit.ismonomorphic","text":"ismonomorphic(V‚ÇÅ::VectorSpace, V‚ÇÇ::VectorSpace)\nV‚ÇÅ ‚âæ V‚ÇÇ\n\nReturn whether there exist monomorphisms from V‚ÇÅ to V‚ÇÇ, i.e. 'injective' morphisms with left inverses.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.isepimorphic","page":"Vector spaces","title":"TensorKit.isepimorphic","text":"isepimorphic(V‚ÇÅ::VectorSpace, V‚ÇÇ::VectorSpace)\nV‚ÇÅ ‚âø V‚ÇÇ\n\nReturn whether there exist epimorphisms from V‚ÇÅ to V‚ÇÇ, i.e. 'surjective' morphisms with right inverses.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.isisomorphic","page":"Vector spaces","title":"TensorKit.isisomorphic","text":"isisomorphic(V‚ÇÅ::VectorSpace, V‚ÇÇ::VectorSpace)\nV‚ÇÅ ‚âÖ V‚ÇÇ\n\nReturn if V‚ÇÅ and V‚ÇÇ are isomorphic, meaning that there exists isomorphisms from V‚ÇÅ to V‚ÇÇ, i.e. morphisms with left and right inverses.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.insertleftunit-Union{Tuple{i}, Tuple{ProductSpace, Val{i}}} where i","page":"Vector spaces","title":"TensorKit.insertleftunit","text":"insertleftunit(P::ProductSpace, i::Int = length(P) + 1; conj = false, dual = false)\n\nInsert a trivial vector space, isomorphic to the underlying field, at position i, which can be specified as an Int or as Val(i) for improved type stability. More specifically, adds a left monoidal unit or its dual.\n\nSee also insertrightunit, removeunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.insertrightunit-Union{Tuple{i}, Tuple{ProductSpace, Val{i}}} where i","page":"Vector spaces","title":"TensorKit.insertrightunit","text":"insertrightunit(P::ProductSpace, i = length(P); conj = false, dual = false)\n\nInsert a trivial vector space, isomorphic to the underlying field, after position i, which can be specified as an Int or as Val(i) for improved type stability. More specifically, adds a right monoidal unit or its dual.\n\nSee also insertleftunit, removeunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.removeunit-Union{Tuple{i}, Tuple{ProductSpace, Val{i}}} where i","page":"Vector spaces","title":"TensorKit.removeunit","text":"removeunit(P::ProductSpace, i::Int)\n\nThis removes a trivial tensor product factor at position 1 ‚â§ i ‚â§ N, where i can be specified as an Int or as Val(i) for improved type stability. For this to work, that factor has to be isomorphic to the field of scalars.\n\nThis operation undoes the work of insertleftunit  and insertrightunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.flip-Union{Tuple{S}, Tuple{HomSpace{S, P1, P2} where {P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}, Any}} where S","page":"Vector spaces","title":"TensorKit.flip","text":"flip(W::HomSpace, I)\n\nReturn a new HomSpace object by applying flip to each of the spaces in the domain and codomain of W for which the linear index i satisfies i ‚àà I.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.permute-Tuple{HomSpace, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}","page":"Vector spaces","title":"TensorKit.permute","text":"permute(W::HomSpace, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple)\n\nReturn the HomSpace obtained by permuting the indices of the domain and codomain of W according to the permutation p‚ÇÅ and p‚ÇÇ respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.select-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{S}, Tuple{HomSpace{S, P1, P2} where {P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}}}} where {S, N‚ÇÅ, N‚ÇÇ}","page":"Vector spaces","title":"TensorKit.select","text":"select(W::HomSpace, (p‚ÇÅ, p‚ÇÇ)::Index2Tuple{N‚ÇÅ,N‚ÇÇ})\n\nReturn the HomSpace obtained by a selection from the domain and codomain of W according to the indices in p‚ÇÅ and p‚ÇÇ respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.compose-Union{Tuple{S}, Tuple{HomSpace{S, P1, P2} where {P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}, HomSpace{S, P1, P2} where {P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}}} where S","page":"Vector spaces","title":"TensorKit.compose","text":"compose(W::HomSpace, V::HomSpace)\n\nObtain the HomSpace that is obtained from composing the morphisms in W and V. For this to be possible, the domain of W must match the codomain of V.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.insertleftunit-Union{Tuple{i}, Tuple{HomSpace, Val{i}}} where i","page":"Vector spaces","title":"TensorKit.insertleftunit","text":"insertleftunit(W::HomSpace, i = numind(W) + 1; conj = false, dual = false)\n\nInsert a trivial vector space, isomorphic to the underlying field, at position i, which can be specified as an Int or as Val(i) for improved type stability. More specifically, adds a left monoidal unit or its dual.\n\nSee also insertrightunit, removeunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.insertrightunit-Union{Tuple{i}, Tuple{HomSpace, Val{i}}} where i","page":"Vector spaces","title":"TensorKit.insertrightunit","text":"insertrightunit(W::HomSpace, i = numind(W); conj = false, dual = false)\n\nInsert a trivial vector space, isomorphic to the underlying field, after position i, which can be specified as an Int or as Val(i) for improved type stability. More specifically, adds a right monoidal unit or its dual.\n\nSee also insertleftunit, removeunit.\n\n\n\n\n\n","category":"method"},{"location":"lib/spaces/#TensorKit.removeunit-Union{Tuple{i}, Tuple{HomSpace, Val{i}}} where i","page":"Vector spaces","title":"TensorKit.removeunit","text":"removeunit(P::HomSpace, i)\n\nThis removes a trivial tensor product factor at position 1 ‚â§ i ‚â§ N, where i can be specified as an Int or as Val(i) for improved type stability. For this to work, the space at position i has to be isomorphic to the field of scalars.\n\nThis operation undoes the work of insertleftunit  and insertrightunit.\n\n\n\n\n\n","category":"method"},{"location":"man/intro/#s_intro","page":"Introduction","title":"Introduction","text":"Before providing a typical user guide and discussing the implementation of TensorKit.jl on the next pages, let us discuss some of the rationale behind this package.","category":"section"},{"location":"man/intro/#ss_whatistensor","page":"Introduction","title":"What is a tensor?","text":"At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:\n\nA tensor t is an element from the tensor product of N vector spaces V_1  V_2  V_N, where N is referred to as the rank or order of the tensor, i.e.\n\nt in V_1  V_2    V_N\n\nIf you think of a tensor as an object with indices, a rank N tensor has N indices where every index is associated with the corresponding vector space in that it labels a particular basis in that space. We will return to index notation at the very end of this manual.\n\nAs the tensor product of vector spaces is itself a vector space, this implies that a tensor behaves as a vector, i.e. tensors from the same tensor product space can be added and multiplied by scalars. The tensor product is only defined for vector spaces over the same field of scalars, e.g. there is no meaning in ‚Ñù^5  ‚ÑÇ^3. When all the vector spaces in the tensor product have an inner product, this also implies an inner product for the tensor product space. It is hence clear that the different vector spaces in the tensor product should have some form of homogeneity in their structure, yet they do not need to be all equal and can e.g. have different dimensions. It goes without saying that defining the vector spaces and their properties will be an important part of the definition of a tensor. As a consequence, this also constitutes a significant part of the implementation, and is discussed in the section on Vector spaces.\n\nAside from the interpretation of a tensor as a vector, we also want to interpret it as a matrix (or more correctly, a linear map) in order to decompose tensors using linear algebra factorisations (e.g. eigenvalue or singular value decomposition). Henceforth, we use the term \"tensor map\" as follows:\n\nA tensor map t is a linear map from a source or domain W_1  W_2    W_N_2 to a target or codomain V_1  V_2    V_N_1, i.e.\n\nt  W_1  W_2    W_N_2  V_1  V_2    V_N_1\n\nA tensor of rank N is then just a special case of a tensor map with N_1 = N and N_2 = 0. A contraction between two tensors is just a composition of linear maps (i.e.  matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.\n\nIn order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise which vector spaces appear in the domain and the codomain of the tensor map, and in which order. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices (i.e. the vector spaces). For example, a linear map W  V is often denoted as a rank two tensor in V  W^*, where W^* corresponds to the dual space of W. This simple example introduces two new concepts.\n\nTypical vector spaces can appear in the domain and codomain in different related forms, e.g. as normal spaces or dual spaces.  In fact, the most generic case is that every vector space V has associated with it a dual space V^*, a conjugate space overlineV and a conjugate dual space overlineV^*.  The four different vector spaces V, V^*, overlineV and overlineV^* correspond to the representation spaces of respectively the fundamental, dual or contragredient, complex conjugate and dual complex conjugate representation of the general linear group mathsfGL(V).  In index notation these spaces are denoted with respectively contravariant (upper), covariant (lower), dotted contravariant and dotted covariant indices.\nFor real vector spaces, the conjugate (dual) space is identical to the normal (dual) space and we only have upper and lower indices, i.e. this is the setting of e.g. general relativity.  For (complex) vector spaces with a sesquilinear inner product overlineV  V  ‚ÑÇ, the inner product allows to define an isomorphism from the conjugate space to the dual space (known as Riesz representation theorem in the more general context of Hilbert spaces).\nIn particular, in spaces with a Euclidean inner product (the setting of e.g. quantum mechanics), the conjugate and dual space are naturally isomorphic (because the dual and conjugate representation of the unitary group are the same).  Again we only need upper and lower indices (or kets and bras).\nFinally, in ‚Ñù^d with a Euclidean inner product, these four different spaces are all equivalent and we only need one type of index.  The space is completely characterized by its dimension d.  This is the setting of much of classical mechanics and we refer to such tensors as cartesian tensors and the corresponding space as cartesian space.  These are the tensors that can equally well be represented as multidimensional arrays (i.e.  using some AbstractArray{<:Real, N} in Julia) without loss of structure.\nThe implementation of all of this is discussed in Vector spaces.\nIn the generic case, the identification between maps W  V and tensors in V  W^* is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between V  W and W  V that can be non-trivial (e.g. in the case of fermions / super vector spaces).  The correct formalism here is provided by theory of monoidal categories, the details of which are explained in the appendix.  Nonetheless, we try to hide these canonical isomorphisms from the user wherever possible, and one does not need to know category theory to be able to use this package.\n\nThis brings us to our final (yet formal) definition\n\nA tensor (map) is a homomorphism between two objects from the category mathbfVect (or some subcategory thereof).   In practice, this will be mathbfFinVect, the category of finite dimensional vector spaces.   More generally even, our concept of a tensor makes sense, in principle, for any linear (a.k.a. mathbfVect-enriched) monoidal category.   For more details, we refer the curious reader to the appendix on Monoidal categories and their properties.","category":"section"},{"location":"man/intro/#ss_symmetries","page":"Introduction","title":"Symmetries and block sparsity","text":"Physical problems often have some symmetry, i.e. the setup is invariant under the action of a group mathsfG which acts on the vector spaces V in the problem according to a certain representation. Having quantum mechanics in mind, TensorKit.jl is so far restricted to unitary representations. A general representation space V can be specified as the number of times every irreducible representation (irrep) a of mathsfG appears, i.e.\n\nV = bigoplus_a ‚ÑÇ^n_a  R_a\n\nwith R_a the space associated with irrep a of mathsfG, which itself has dimension d_a (often called the quantum dimension), and n_a the number of times this irrep appears in V. If the unitary irrep a for g  mathsfG is given by u_a(g), then there exists a specific basis for V such that the group action of mathsfG on V is given by the unitary representation\n\nu(g) = bigoplus_a ùüô_n_a  u_a(g)\n\nwith ùüô_n_a the n_a  n_a identity matrix. The total dimension of V is given by _a n_a d_a.\n\nThe reason for implementing symmetries is to exploit the computation and memory gains resulting from restricting to tensor maps tW_1  W_2    W_N_2  V_1  V_2    V_N_1 that are equivariant under the symmetry, i.e. that act as intertwiners between the symmetry action on the domain and the codomain. Indeed, such tensors should be block diagonal because of Schur's lemma, but only after we couple the individual irreps in the spaces W_i to a joint irrep, which is then again split into the individual irreps of the spaces V_i. The basis change from the tensor product of irreps in the (co)domain to the joint irrep is implemented by a sequence of Clebsch‚ÄìGordan coefficients, also known as a fusion (or splitting) tree. We implement the necessary machinery to manipulate these fusion trees under index permutations and repartitions for arbitrary groups mathsfG. In particular, this fits with the formalism of monoidal categories, and more specifically fusion categories, and only requires the topological data of the group, i.e. the fusion rules of the irreps, their quantum dimensions and the F-symbol (6j-symbol or more precisely Racah's W-symbol in the case of mathsfSU_2). In particular, we don't actually need the Clebsch‚ÄìGordan coefficients themselves (but they can be useful for checking purposes).\n\nHence, a second major part of TensorKit.jl is the interface and implementation for specifying symmetries, and further details are provided in Sectors, representation spaces and fusion trees.","category":"section"},{"location":"lib/sectors/#Symmetry-sectors","page":"Symmetry sectors","title":"Symmetry sectors","text":"","category":"section"},{"location":"lib/sectors/#Type-hierarchy","page":"Symmetry sectors","title":"Type hierarchy","text":"The fundamental abstract supertype for symmetry sectors is Sector:\n\nVarious concrete subtypes of Sector are provided within the TensorKitSectors library:\n\nSeveral more concrete sector types can be found in other packages such as SUNRepresentations.jl, CategoryData.jl, QWignerSymbols.jl, ...:\n\nSome of these types are parameterized by a type parameter that represents a group. We therefore also provide a number of types to represent groups:\n\nThe following types are used to characterize different properties of the different types of sectors:\n\nFinally, the following auxiliary types are defined to facilitate the implementation of some of the methods on sectors:","category":"section"},{"location":"lib/sectors/#Useful-constants","page":"Symmetry sectors","title":"Useful constants","text":"The following constants are defined to facilitate obtaining the type associated with the group elements or the irreducible representations of a given group:","category":"section"},{"location":"lib/sectors/#Methods-for-characterizing-and-manipulating-Sector-objects","page":"Symmetry sectors","title":"Methods for characterizing and manipulating Sector objects","text":"The following methods can be used to obtain properties such as topological data of sector objects, or to manipulate them or create related sectors:\n\nWe have also the following methods that are specific to certain types of sectors and serve as accessors to their fields:\n\nFurthermore, we also have one specific method acting on groups, represented as types\n\nMapping between sectors and linear indices is only used for sectors I for which Base.IteratorSize(values(I)) == HasLength(). In that case, we map an index i to a sector c via c = getindex(values(I), i), and provide an inverse mapping\n\nBecause we sometimes want to customize the string representation of our sector types, we also have the following method:\n\nFinally, we provide functionality to compile all revelant methods for a sector:","category":"section"},{"location":"lib/sectors/#TensorKitSectors.Sector","page":"Symmetry sectors","title":"TensorKitSectors.Sector","text":"abstract type Sector\n\nAbstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes I <: Sector as the set of labels of a GradedSpace.\n\nEvery new I <: Sector should implement the following methods:\n\nunit(::Type{I}): unit element of I. If there are multiple, implement allunits(::Type{I})   instead.\ndual(a::I): aÃÖ, conjugate or dual label of a\n‚äó(a::I, b::I): iterable with unique fusion outputs of a  b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::I, b::I, c::I): number of times c appears in a ‚äó b, i.e. the   multiplicity\nFusionStyle(::Type{I}): UniqueFusion(), SimpleFusion() or   GenericFusion()\nBraidingStyle(::Type{I}): Bosonic(), Fermionic(), Anyonic(), ...\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I): F-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or rank-4 array (in case of GenericFusion)\nRsymbol(a::I, b::I, c::I): R-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\nisless(a::I, b::I): defines a canonical ordering of sectors\nhash(a::I): hash function for sectors\n\nand optionally\n\ndim(a::I): quantum dimension of sector a\nfrobenius_schur_indicator(a::I): Frobenius-Schur indicator of a (1, 0, -1)\nfrobenius_schur_phase(a::I): Frobenius-Schur phase of a (¬±1)\nsectorscalartype(::Type{I}): scalar type of F- and R-symbols\nBsymbol(a::I, b::I, c::I): B-symbol: scalar (in case of   UniqueFusion/SimpleFusion) or matrix (in case of GenericFusion)\ntwist(a::I) -> twist of sector a\n\nFurthermore, iterate and Base.IteratorSize should be made to work for the singleton type SectorValues{I}.\n\nTo help with the implementation of ‚äó(a::I, b::I) as an iterator, the provided struct type SectorProductIterator{I} can be used, which stores a and b and requires the implementation of Base.iterate(::SectorProductIterator{I}, state...).\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.Trivial","page":"Symmetry sectors","title":"TensorKitSectors.Trivial","text":"struct Trivial <: Sector\nTrivial()\n\nSingleton type to represent the trivial sector, i.e. the trivial representation of the trivial group. This is equivalent to Rep[‚Ñ§‚ÇÅ], or the unit object of the category Vect of ordinary vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.AbstractIrrep","page":"Symmetry sectors","title":"TensorKitSectors.AbstractIrrep","text":"abstract type AbstractIrrep{G <: Group} <: Sector\n\nAbstract supertype for sectors which corresponds to irreps (irreducible representations) of a group G. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.\n\nActual concrete implementations of those irreps can be obtained as Irrep[G], or via their actual name, which generically takes the form (asciiG)Irrep, i.e. the ASCII spelling of the group name followed by Irrep.\n\nAll irreps have BraidingStyle equal to Bosonic() and thus trivial twists.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.ZNIrrep","page":"Symmetry sectors","title":"TensorKitSectors.ZNIrrep","text":"struct ZNIrrep{N} <: AbstractIrrep{‚Ñ§{N}}\nZNIrrep{N}(n::Integer)\nIrrep[‚Ñ§{N}](n::Integer)\n\nRepresents irreps of the group ‚Ñ§_N for some value of N. For N equals 2, 3 or 4, ‚Ñ§{N} can be replaced by ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, and ‚Ñ§‚ÇÑ. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant.\n\nThe type of the stored integer (UInt8) requires N ‚â§ 128. Larger values of N should use the LargeZNIrrep instead. The constructor Irrep[‚Ñ§{N}] should be preferred, as it will automatically select the most efficient storage type for a given value of N.\n\nSee also charge and modulus to extract the relevant data.\n\nFields\n\nn::UInt8: the integer label of the irrep, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.DNIrrep","page":"Symmetry sectors","title":"TensorKitSectors.DNIrrep","text":"struct DNIrrep{N} <: AbstractIrrep{Dihedral{N}}\nDNIrrep{N}(n::Integer, isodd::Bool=false)\nIrrep[Dihedral{N}](n::Integer, isodd::Bool=false)\n\nRepresents irreps of the dihedral group D_N = Z_N  C (Z_N and charge conjugation or reflection).\n\nProperties\n\nj::Int: the value of the Z_N charge.\nisodd::Bool: the representation of charge conjugation.\n\nCombined these take the values +0 -0 1  (N - 1)  2 for odd N, and +0 -0 1  N  2 - 1 +(N2) -(N2) for even N, where the + (-) refer to the even (odd) one-dimensional irreps, while the others are two-dimensional.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.U1Irrep","page":"Symmetry sectors","title":"TensorKitSectors.U1Irrep","text":"struct U1Irrep <: AbstractIrrep{U‚ÇÅ}\nU1Irrep(charge::Real)\nIrrep[U‚ÇÅ](charge::Real)\n\nRepresents irreps of the group U‚ÇÅ. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of U‚ÇÅ subgroups of SU‚ÇÇ, such as the S^z of spin-1/2 system. Hence, the charge is stored as a HalfInt from the package HalfIntegers.jl, but can be entered as arbitrary Real. The sequence of the charges is: 0, 1/2, -1/2, 1, -1, ...\n\nFields\n\ncharge::HalfInt: the label of the irrep, which can be any half integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.SU2Irrep","page":"Symmetry sectors","title":"TensorKitSectors.SU2Irrep","text":"struct SU2Irrep <: AbstractIrrep{SU‚ÇÇ}\nSU2Irrep(j::Real)\nIrrep[SU‚ÇÇ](j::Real)\n\nRepresents irreps of the group SU‚ÇÇ. The irrep is labelled by a half integer j which can be entered as an abitrary Real, but is stored as a HalfInt from the HalfIntegers.jl package.\n\nFields\n\nj::HalfInt: the label of the irrep, which can be any non-negative half integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.CU1Irrep","page":"Symmetry sectors","title":"TensorKitSectors.CU1Irrep","text":"struct CU1Irrep <: AbstractIrrep{CU‚ÇÅ}\nCU1Irrep(j, s = ifelse(j>zero(j), 2, 0))\nIrrep[CU‚ÇÅ](j, s = ifelse(j>zero(j), 2, 0))\n\nRepresents irreps of the group U‚ÇÅ  C (U‚ÇÅ and charge conjugation or reflection), which is also known as just O‚ÇÇ. \n\nFields\n\nj::HalfInt: the value of the U‚ÇÅ charge.\ns::Int: the representation of charge conjugation.\n\nThey can take values:\n\nif j == 0, s = 0 (trivial charge conjugation) or   s = 1 (non-trivial charge conjugation)\nif j > 0, s = 2 (two-dimensional representation)\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.AbstractGroupElement","page":"Symmetry sectors","title":"TensorKitSectors.AbstractGroupElement","text":"abstract type AbstractGroupElement{G <: Group} <: Sector\n\nAbstract supertype for sectors which corresponds to group elements of a group G.\n\nActual concrete implementations of those irreps can be obtained as Element[G], or via their actual name, which generically takes the form (asciiG)Element, i.e. the ASCII spelling of the group name followed by Element.\n\nAll group elements have FusionStyle equal to UniqueFusion(). Furthermore, the BraidingStyle is set to NoBraiding(), although this can be overridden by a concrete implementation of AbstractGroupElement.\n\nFor the fusion structure, a specific SomeGroupElement <: AbstractGroupElement{SomeGroup} should only implement the following methods\n\nBase.:*(c1::GroupElement, c2::GroupElement) -> GroupElement\nBase.one(::Type{GroupElement}) -> GroupElement\nBase.inv(c::GroupElement) -> GroupElement\n# and optionally\nTensorKitSectors.cocycle(c1::GroupElement, c2::GroupElement, c3::GroupElement) -> Number\n\nThe methods conj, dual, ‚äó, Nsymbol, Fsymbol, dim, Asymbol, Bsymbol and frobenius_schur_phase will then be automatically defined. If no cocycle method is defined, the cocycle will be assumed to be trivial, i.e. equal to 1.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.ZNElement","page":"Symmetry sectors","title":"TensorKitSectors.ZNElement","text":"struct ZNElement{N, p} <: AbstractGroupElement{‚Ñ§{N}}\nZNElement{N, p}(n::Integer)\nGroupElement[‚Ñ§{N}, p](n::Integer)\n\nRepresents an element of the group ‚Ñ§_N for some value of N < 64. (We need 2 * (N - 1) <= 127 in order for a ‚äó b to work correctly.) For N equals 2, 3 or 4, ‚Ñ§{N} can be replaced by ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, ‚Ñ§‚ÇÑ. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant. The second type parameter p should also be specified as an integer 0 <= p < N and specifies the 3-cocycle, which is then being given by\n\ncocycle(a, b, c) = cispi(2 * p * a.n * (b.n + c.n - mod(b.n + c.n, N)) / N))\n\nIf p is not specified, it defaults to 0, i.e. the trivial cocycle.\n\nFields\n\nn::Int8: the integer label of the element, modulo N.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.FermionParity","page":"Symmetry sectors","title":"TensorKitSectors.FermionParity","text":"struct FermionParity <: Sector\nFermionParity(isodd::Bool)\n\nRepresents sectors with fermion parity. The fermion parity is a ‚Ñ§‚ÇÇ quantum number that yields an additional sign when two odd fermions are exchanged, corresponding to a BraidingStyle that is Fermionic().\n\nFields\n\nisodd::Bool: indicates whether the fermion parity is odd (true) or even (false).\n\nSee also: FermionNumber, FermionSpin\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.FermionNumber","page":"Symmetry sectors","title":"TensorKitSectors.FermionNumber","text":"const FermionNumber = U1Irrep ‚ä† FermionParity\nFermionNumber(a::Int)\n\nRepresents the fermion number as the direct product of a U‚ÇÅ irrep a and a fermion parity, with the restriction that the fermion parity is odd if and only if a is odd.\n\nSee also: U1Irrep, FermionParity\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.FermionSpin","page":"Symmetry sectors","title":"TensorKitSectors.FermionSpin","text":"const FermionSpin = SU2Irrep ‚ä† FermionParity\nFermionSpin(j::Real)\n\nRepresents the fermion spin as the direct product of a SU‚ÇÇ irrep j and a fermion parity, with the restriction that the fermion parity is odd if 2 * j is odd.\n\nSee also: SU2Irrep, FermionParity\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.FibonacciAnyon","page":"Symmetry sectors","title":"TensorKitSectors.FibonacciAnyon","text":"struct FibonacciAnyon <: Sector\nFibonacciAnyon(s::Symbol)\n\nRepresents the anyons of the Fibonacci modular fusion category. It can take two values, corresponding to the trivial sector FibonacciAnyon(:I) and the non-trivial sector FibonacciAnyon(:œÑ) with fusion rules œÑ  œÑ = 1  œÑ.\n\nFields\n\nisunit::Bool: indicates whether the sector corresponds to the trivial anyon :I (true), or the non-trivial anyon :œÑ (false).\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.IsingAnyon","page":"Symmetry sectors","title":"TensorKitSectors.IsingAnyon","text":"struct IsingAnyon <: Sector\nIsingAnyon(s::Symbol)\n\nRepresents the anyons of the Ising modular fusion category. It can take three values, corresponding to the trivial sector IsingAnyon(:I) and the non-trivial sectors IsingAnyon(:œÉ) and IsingAnyon(:œà), with fusion rules œà  œà = 1, œÉ  œà = œÉ, and œÉ  œÉ = 1  œà.\n\nFields\n\ns::Symbol: the label of the represented anyon, which can be :I, :œÉ, or :œà.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.PlanarTrivial","page":"Symmetry sectors","title":"TensorKitSectors.PlanarTrivial","text":"struct PlanarTrivial <: Sector\nPlanarTrivial()\n\nRepresents a trivial anyon sector, i.e. a trivial sector without braiding. This is mostly useful for testing.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.IsingBimodule","page":"Symmetry sectors","title":"TensorKitSectors.IsingBimodule","text":"struct IsingBimodule <: Sector\n\nType to represent the simple objects in the Ising category reinterpreted as a bimodule category composed of two copies of the category ùíû = ùíü = Irrep[‚Ñ§‚ÇÇ], the two simple objects of which can be identified with the Ising anyons {I, œà}, and the bimodule categories ‚Ñ≥ = ‚Ñ≥·µí·µñ = Vec, with a single simple object that can be identified with the Ising anyon œÉ. This constitutes the easiest example of a multifusion category and is implemented here for testing purposes and to illustrate how to implement such categories in TensorKitSectors.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.TimeReversed","page":"Symmetry sectors","title":"TensorKitSectors.TimeReversed","text":"struct TimeReversed{I <: Sector}\nTimeReversed(a::Sector)\ntimereversed(a::Sector)\n\nRepresents the time-reversed version of the sector a, i.e. the sector with the same fusion rules and F-symbols, but with the inverse braiding. Time reversal acts trivially on sectors with symmetric braiding. In such cases, timereversed(a) simply returns a.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.ProductSector","page":"Symmetry sectors","title":"TensorKitSectors.ProductSector","text":"struct ProductSector{T <: SectorTuple}\nProductSector((s‚ÇÅ, s‚ÇÇ, ...))\n\nRepresents the Deligne tensor product of sectors. The type parameter T is a tuple of the component sectors. The recommended way to construct a ProductSector is using the deligneproduct (‚ä†) operator on the components.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.Group","page":"Symmetry sectors","title":"TensorKitSectors.Group","text":"abstract type Group\n\nAbstract supertype for representing different types of groups. Groups can be used to define Sector subtypes, either via their irreducible representations, or via their group elements, and typically appear as type parameter. As such, they are not meant to be instantiated and are defined as abstract types.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.AbelianGroup","page":"Symmetry sectors","title":"TensorKitSectors.AbelianGroup","text":"abstract type AbelianGroup <: Group\n\nAbstract supertype for representing different types of Abelian groups. Abelian groups have both irreps and group elements that have several simplified properties, that can be defined in general.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.Cyclic","page":"Symmetry sectors","title":"TensorKitSectors.Cyclic","text":"abstract type Cyclic{N} <: AbelianGroup\n\nType to represent the cyclic group of order N, i.e. the multiplicative group of roots of unity of order N, which is a discrete abelian group. The cyclic group of order N is isomorphic to the additive group ‚Ñ§{N}, and we define the latter as a type alias const ‚Ñ§{N} = Cyclic{N}.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.U‚ÇÅ","page":"Symmetry sectors","title":"TensorKitSectors.U‚ÇÅ","text":"abstract type U‚ÇÅ <: AbelianGroup\n\nType to represent the group U(1) of complex numbers of unit modulus, which is a compact Abelian Lie group.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.CU‚ÇÅ","page":"Symmetry sectors","title":"TensorKitSectors.CU‚ÇÅ","text":"abstract type CU‚ÇÅ <: Group\n\nType to represent the group of U‚ÇÅ in combination with charge conjugation, i.e. the group generated by U‚ÇÅ and an additional element that acts as complex conjugation on U‚ÇÅ. This group is isomorphic to the orthogonal group O‚ÇÇ of real orthogonal 2√ó2 matrices, and can be seen as the semidirect product U‚ÇÅ ‚ãä ‚Ñ§‚ÇÇ. This is a compact non-Abelian group.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.SU","page":"Symmetry sectors","title":"TensorKitSectors.SU","text":"abstract type SU{N} <: Group\n\nType to represent the special unitary group SU(N), which is a compact non-Abelian Lie group.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.Dihedral","page":"Symmetry sectors","title":"TensorKitSectors.Dihedral","text":"abstract type Dihedral{N} <: Group\n\nType to represent the dihedral group of order 2N, which is the symmetry group of a regular polygon with N sides, and is a discrete non-Abelian group. \n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.ProductGroup","page":"Symmetry sectors","title":"TensorKitSectors.ProductGroup","text":"abstract type ProductGroup{T <: Tuple{Vararg{Group}}} <: Group\n\nType to represent the direct product of a tuple of groups. This is typically constructed via the √ó operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.FusionStyle","page":"Symmetry sectors","title":"TensorKitSectors.FusionStyle","text":"abstract type FusionStyle\nFusionStyle(::Sector)\nFusionStyle(I::Type{<:Sector})\n\nTrait to describe the fusion behavior of sectors of type I, which can be either\n\nUniqueFusion(): single fusion output when fusing two sectors;\nSimpleFusion(): multiple outputs, but every output occurs at most one,   also known as multiplicity-free (e.g. irreps of SU(2));\nGenericFusion(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\nThere is an abstract supertype MultipleFusion of which both SimpleFusion and GenericFusion are subtypes. Furthermore, there is a type alias MultiplicityFreeFusion for those fusion types which do not require muliplicity labels, i.e. MultiplicityFreeFusion = Union{UniqueFusion,SimpleFusion}.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.BraidingStyle","page":"Symmetry sectors","title":"TensorKitSectors.BraidingStyle","text":"abstract type BradingStyle\nBraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nNoBraiding(): no braiding structure\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R^ab_c phase or matrix (depending on SimpleFusion or   GenericFusion fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.UnitStyle","page":"Symmetry sectors","title":"TensorKitSectors.UnitStyle","text":"abstract type UnitStyle\nUnitStyle(::Sector)\nUnitStyle(I::Type{<:Sector})\n\nTrait to describe the semisimplicity of the unit sector of type I. This can be either\n\nSimpleUnit(): the unit is simple (e.g. fusion categories);\nGenericUnit(): the unit is semisimple.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.SectorValues","page":"Symmetry sectors","title":"TensorKitSectors.SectorValues","text":"struct SectorValues{I <: Sector}\n\nSingleton type to represent an iterator over the possible values of type I, whose instance is obtained as values(I). For a new I::Sector, the following should be defined\n\nBase.iterate(::SectorValues{I}[, state]): iterate over the values\nBase.IteratorSize(::Type{SectorValues{I}}): HasLength(), SizeUnknown()   or IsInfinite() depending on whether the number of values of type I is finite   (and sufficiently small) or infinite; for a large number of values, SizeUnknown() is   recommended because this will trigger the use of GenericGradedSpace.\n\nIf IteratorSize(I) == HasLength(), also the following must be implemented:\n\nBase.length(::SectorValues{I}): the number of different values\nBase.getindex(::SectorValues{I}, i::Int): a mapping between an index i and an   instance of I. A fallback implementation exists that returns the ith value   of the SectorValues iterator.\nfindindex(::SectorValues{I}, c::I): reverse mapping between a value c::I and an   index i::Integer ‚àà 1:length(values(I)). A fallback implementation exists that   linearly searches through the SectorValues iterator.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.SectorProductIterator","page":"Symmetry sectors","title":"TensorKitSectors.SectorProductIterator","text":"struct SectorProductIterator{I <: Sector}\nSectorProductIterator(a::I, b::I) where {I <: Sector}\n\nCustom iterator to represent the (unique) fusion outputs of a  b.\n\nCustom sectors that aim to use this have to provide the following functionality:\n\nBase.iterate(::SectorProductIterator{I}, state...) where {I <: Sector}: iterate over   the fusion outputs of a ‚äó b\n\nIf desired and it is possible to easily compute the number of unique fusion outputs, it is also possible to define Base.IteratorSize(::Type{SectorProductIterator{I}}) = Base.HasLength(), in which case Base.length(::SectorProductIterator{I}) has to be implemented.\n\nSee also ‚äó.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKitSectors.Irrep","page":"Symmetry sectors","title":"TensorKitSectors.Irrep","text":"const Irrep\n\nA constant of a singleton type used as Irrep[G] with G <: Group a type of group, to construct or obtain a concrete subtype of AbstractIrrep{G} that implements the data structure used to represent irreducible representations of the group G.\n\n\n\n\n\n","category":"constant"},{"location":"lib/sectors/#TensorKitSectors.GroupElement","page":"Symmetry sectors","title":"TensorKitSectors.GroupElement","text":"const GroupElement\n\nA constant of a singleton type used as GroupElement[G] or GroupElement[G, œâ] with G <: Group a type of group, to construct or obtain a concrete subtype of AbstractElement{G} that implements the data structure used to represent elements of the group G, possibly with a second argument œâ that specifies the associated 3-cocycle.\n\n\n\n\n\n","category":"constant"},{"location":"lib/sectors/#TensorKitSectors.unit","page":"Symmetry sectors","title":"TensorKitSectors.unit","text":"unit(::Sector) -> Sector\nunit(::Type{<:Sector}) -> Sector\n\nReturn the unit element of this type of sector, provided it is unique.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.isunit","page":"Symmetry sectors","title":"TensorKitSectors.isunit","text":"isunit(a::Sector) -> Bool\n\nReturn whether sector a is a unit element.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.leftunit","page":"Symmetry sectors","title":"TensorKitSectors.leftunit","text":"leftunit(a::Sector) -> Sector\n\nReturn the left unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also rightunit and unit.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.rightunit","page":"Symmetry sectors","title":"TensorKitSectors.rightunit","text":"rightunit(a::Sector) -> Sector\n\nReturn the right unit element corresponding to a; this is necessary for multifusion categories, where the unit may not be unique. See also leftunit and unit.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.allunits","page":"Symmetry sectors","title":"TensorKitSectors.allunits","text":"allunits(I::Type{<:Sector}) -> Tuple{I}\n\nReturn a tuple with all units of the sector type I. For fusion categories, this will contain only one element.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.dual-Tuple{Sector}","page":"Symmetry sectors","title":"TensorKitSectors.dual","text":"dual(a::Sector) -> Sector\n\nReturn the dual label of a, i.e. the unique label aÃÑ = dual(a) such that  Nsymbol(a, aÃÑ, leftunit(a)) == 1 and Nsymbol(aÃÑ, a, rightunit(a)) == 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKitSectors.Nsymbol","page":"Symmetry sectors","title":"TensorKitSectors.Nsymbol","text":"Nsymbol(a::I, b::I, c::I) where {I <: Sector} -> Integer\n\nReturn an Integer representing the number of times c appears in the fusion product a ‚äó b. Could be a Bool if FusionStyle(I) == UniqueFusion() or SimpleFusion().\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.:‚äó","page":"Symmetry sectors","title":"TensorKitSectors.:‚äó","text":"‚äó(a::I, b::I...) where {I <: Sector}\notimes(a::I, b::I...) where {I <: Sector}\n\nReturn an iterable of elements of c::I that appear in the fusion product a ‚äó b.\n\nNote that every element c should appear at most once, fusion degeneracies (if FusionStyle(I) == GenericFusion()) should be accessed via Nsymbol(a, b, c).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.Fsymbol","page":"Symmetry sectors","title":"TensorKitSectors.Fsymbol","text":"Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I <: Sector}\n\nReturn the F-symbol F^abc_d that associates the two different fusion orders of sectors a, b and c into an ouput sector d, using either an intermediate sector a  b  e or b  c  f:\n\na-<-Œº-<-e-<-ŒΩ-<-d                                     a-<-Œª-<-d\n    ‚à®       ‚à®       -> Fsymbol(a,b,c,d,e,f)[Œº,ŒΩ,Œ∫,Œª]      ‚à®\n    b       c                                             f\n                                                          v\n                                                      b-<-Œ∫\n                                                          ‚à®\n                                                          c\n\nIf FusionStyle(I) is UniqueFusion or SimpleFusion, the F-symbol is a number. Otherwise it is a rank 4 array of size (Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d)).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.Rsymbol","page":"Symmetry sectors","title":"TensorKitSectors.Rsymbol","text":"Rsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturns the R-symbol R^ab_c that maps between c  a  b and c  b  a as in\n\na -<-Œº-<- c                                 b -<-ŒΩ-<- c\n     ‚à®        -> Rsymbol(a, b, c)[Œº, ŒΩ]          v\n     b                                           a\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the R-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(b, a, c).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.Bsymbol","page":"Symmetry sectors","title":"TensorKitSectors.Bsymbol","text":"Bsymbol(a::I, b::I, c::I) where {I <: Sector}\n\nReturn the value of B^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-Œº-<- c                                                    a -<-ŒΩ-<- c\n     ‚à®       -> ‚àö(dim(c) / dim(a)) * Bsymbol(a, b, c)[Œº, ŒΩ]         ‚àß\n     b                                                            dual(b)\n\nIf FusionStyle(I) is UniqueFusion() or SimpleFusion(), the B-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(c, dual(b), a).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.dim-Tuple{Sector}","page":"Symmetry sectors","title":"TensorKitSectors.dim","text":"dim(a::Sector)\n\nReturn the (quantum) dimension of the sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKitSectors.frobenius_schur_phase","page":"Symmetry sectors","title":"TensorKitSectors.frobenius_schur_phase","text":"frobenius_schur_phase(a::Sector)\n\nReturn the Frobenius-Schur phase Œ∫‚Çê of a sector a, which is a complex phase that appears in the context of bending lines and is obtained from F^a aÃÖ a_a. When a == dual(a), it is restricted to Œ∫‚Çê  1 -1 and coincides with the group-theoretic version frobenius_schur_indicator. When a != dual(a), the value of Œ∫‚Çê can be gauged to be 1, though is not required to be.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.frobenius_schur_indicator","page":"Symmetry sectors","title":"TensorKitSectors.frobenius_schur_indicator","text":"frobenius_schur_indicator(a::Sector)\n\nReturn the Frobenius-Schur indicator of a sector ŒΩ‚Çê  1 0 -1, which distinguishes between real, complex and quaternionic representations.\n\nSee also frobenius_schur_phase for the category-theoretic version that appears in the context of line bending.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.twist-Tuple{Sector}","page":"Symmetry sectors","title":"TensorKitSectors.twist","text":"twist(a::Sector)\n\nReturn the twist of a sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#Base.isreal-Tuple{Type{<:Sector}}","page":"Symmetry sectors","title":"Base.isreal","text":"isreal(::Type{<:Sector}) -> Bool\n\nReturn whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKitSectors.sectorscalartype","page":"Symmetry sectors","title":"TensorKitSectors.sectorscalartype","text":"sectorscalartype(I::Type{<:Sector}) -> Type{<:Number}\n\nReturn the scalar type of the topological data of the sector I. In particular, this is a combination of the scalar type of both the Fsymbol and Rsymbol, and determines the scalar type of the fusiontensor whenever it is defined.\n\nSee also fusionscalartype and braidingscalartype.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.deligneproduct-Tuple{Sector, Sector}","page":"Symmetry sectors","title":"TensorKitSectors.deligneproduct","text":"‚ä†(s‚ÇÅ::Sector, s‚ÇÇ::Sector)\ndeligneproduct(s‚ÇÅ::Sector, s‚ÇÇ::Sector)\n\nGiven two sectors s‚ÇÅ and s‚ÇÇ, which label an isomorphism class of simple objects in a fusion category C‚ÇÅ and C‚ÇÇ, s1 ‚ä† s2 (obtained as \\boxtimes+TAB) labels the isomorphism class of simple objects in the Deligne tensor product category C‚ÇÅ  C‚ÇÇ.\n\nThe Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have Irrep[G‚ÇÅ] ‚ä† Irrep[G‚ÇÇ] == Irrep[G‚ÇÅ √ó G‚ÇÇ].\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKitSectors.charge","page":"Symmetry sectors","title":"TensorKitSectors.charge","text":"charge(c::ZNIrrep) -> Int\n\nThe charge label of the irrep c.\n\n\n\n\n\ncharge(c::U1Irrep) -> HalfInt\n\nThe charge label of the irrep c.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.modulus","page":"Symmetry sectors","title":"TensorKitSectors.modulus","text":"modulus(c::ZNIrrep{N}) -> N\nmodulus(::Type{<:ZNIrrep{N}}) -> N\n\nThe order of the cyclic group, or the modulus of the charge labels.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.:√ó","page":"Symmetry sectors","title":"TensorKitSectors.:√ó","text":"√ó(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}\ntimes(G::Vararg{Type{<:Group}}) -> ProductGroup{Tuple{G...}}\n\nConstruct the direct product of a (list of) groups.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.findindex","page":"Symmetry sectors","title":"TensorKitSectors.findindex","text":"findindex(v::SectorValues{I}, c::I)\n\nReverse mapping between a value c::I and an index i::Integer ‚àà 1:length(values(I)).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.type_repr","page":"Symmetry sectors","title":"TensorKitSectors.type_repr","text":"type_repr(T::Type)\n\nReturn a string representation of the type T, which is used to modify the default way in which Sector subtypes are displayed in other objects that depend on them.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKitSectors.precompile_sector","page":"Symmetry sectors","title":"TensorKitSectors.precompile_sector","text":"precompile_sector(I::Type{<:Sector})\n\nPrecompile common methods for the given sector type.\n\n\n\n\n\n","category":"function"},{"location":"man/gradedspaces/#s_gradedspaces","page":"Graded spaces","title":"Graded spaces","text":"We have introduced Sector subtypes as a way to label the irreps or sectors in the decomposition V = _a ‚ÑÇ^n_a  R_a. To actually represent such spaces, we now also introduce a corresponding type GradedSpace, which is a subtype of ElementarySpace:\n\nHere, D is a type parameter to denote the data structure used to store the degeneracy or multiplicity dimensions n_a of the different sectors. For convenience, Vect[I] will return the fully concrete type with D specified.\n\nNote that, conventionally, a graded vector space is a space that has a natural direct sum decomposition over some set of labels, i.e. V = _a  I V_a where the label set I has the structure of a semigroup a  b = c  I. Here, we generalize this notation by using for I the fusion ring of a fusion category, a  b = _c  I _Œº = 1^N_ab^c c. However, this is mostly to lower the barrier, as really the instances of GradedSpace represent just general objects in a fusion category (or strictly speaking, a pre-fusion category, as we allow for an infinite number of simple objects, e.g. the irreps of a continuous group).","category":"section"},{"location":"man/gradedspaces/#Implementation-details","page":"Graded spaces","title":"Implementation details","text":"As mentioned, the way in which the degeneracy dimensions n_a are stored depends on the specific sector type I, more specifically on the IteratorSize of values(I). If IteratorSize(values(I)) isa Union{IsInfinite, SizeUnknown}, the different sectors a and their corresponding degeneracy n_a are stored as key value pairs in an Associative array, i.e. a dictionary dims::SectorDict. As the total number of sectors in values(I) can be infinite, only sectors a for which n_a are stored. Here, SectorDict is a constant type alias for a specific dictionary implementation, which currently resorts to SortedVectorDict implemented in TensorKit.jl. Hence, the sectors and their corresponding dimensions are stored as two matching lists (Vector instances), which are ordered based on the property isless(a::I, b::I). This ensures that the space V = _a ‚ÑÇ^n_a  R_a has some unique canonical order in the direct sum decomposition, such that two different but equal instances created independently always match.\n\nIf IteratorSize(values(I)) isa Union{HasLength, HasShape}, the degeneracy dimensions n_a are stored for all sectors a ‚àà values(I) (also if n_a == 0) in a tuple, more specifically a NTuple{N, Int} with N = length(values(I)). The methods getindex(values(I), i) and findindex(values(I), a) are used to map between a sector a ‚àà values(I) and a corresponding index i ‚àà 1:N. As N is a compile time constant, these types can be created in a type stable manner. Note however that this implies that for large values of N, it can be beneficial to define IteratorSize(values(a)) = SizeUnknown() to not overly burden the compiler.","category":"section"},{"location":"man/gradedspaces/#Constructing-instances","page":"Graded spaces","title":"Constructing instances","text":"As mentioned, the convenience method Vect[I] will return the concrete type GradedSpace{I, D} with the matching value of D, so that should never be a user's concern. In fact, for consistency, Vect[Trivial] will just return ComplexSpace, which is not even a specific type of GradedSpace. For the specific case of group irreps as sectors, one can use Rep[G] with G the group, as inspired by the categorical name mathbfRep_mathsfG. Some illustrations:\n\nVect[Trivial]\nVect[U1Irrep]\nVect[Irrep[U‚ÇÅ]]\nRep[U‚ÇÅ]\nRep[‚Ñ§‚ÇÇ √ó SU‚ÇÇ]\nVect[Irrep[‚Ñ§‚ÇÇ √ó SU‚ÇÇ]]\n\nNote that we also have the specific alias U‚ÇÅSpace. In fact, for all the common groups we have a number of aliases, both in ASCII and using Unicode:\n\n# ASCII type aliases\nconst ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}\nconst Z2Space = ZNSpace{2}\nconst Z3Space = ZNSpace{3}\nconst Z4Space = ZNSpace{4}\nconst U1Space = Rep[U‚ÇÅ]\nconst CU1Space = Rep[CU‚ÇÅ]\nconst SU2Space = Rep[SU‚ÇÇ]\n\n# Unicode alternatives\nconst ‚Ñ§‚ÇÇSpace = Z2Space\nconst ‚Ñ§‚ÇÉSpace = Z3Space\nconst ‚Ñ§‚ÇÑSpace = Z4Space\nconst U‚ÇÅSpace = U1Space\nconst CU‚ÇÅSpace = CU1Space\nconst SU‚ÇÇSpace = SU2Space\n\nTo create specific instances of those types, one can e.g. just use V = GradedSpace(a => n_a, b => n_b, c => n_c) or V = GradedSpace(iterator) where iterator is any iterator (e.g. a dictionary or a generator) that yields Pair{I, Int} instances. With those constructions, I is inferred from the type of sectors. However, it is often more convenient to specify the sector type explicitly (using one of the many alias provided), since then the sectors are automatically converted to the correct type. Thereto, one can use Vect[I], or when I corresponds to the irreducible representations of a group, Rep[G]. Some examples:\n\nVect[Irrep[U‚ÇÅ]](0 => 3, 1 => 2, -1 => 1) ==\n    GradedSpace(U1Irrep(0) => 3, U1Irrep(1) => 2, U1Irrep(-1) => 1) == \n    U1Space(0 => 3, 1 => 2, -1 => 1)\n\nThe fact that Rep[G] also works with product groups makes it easy to specify e.g.\n\nRep[‚Ñ§‚ÇÇ √ó SU‚ÇÇ]((0, 0) => 3, (1, 1/2) => 2, (0, 1) => 1) == \n    GradedSpace((Z2Irrep(0) ‚ä† SU2Irrep(0)) => 3, (Z2Irrep(1) ‚ä† SU2Irrep(1/2)) => 2, (Z2Irrep(0) ‚ä† SU2Irrep(1)) => 1)","category":"section"},{"location":"man/gradedspaces/#Methods","page":"Graded spaces","title":"Methods","text":"There are a number of methods to work with instances V of GradedSpace. The function sectortype returns the type of the sector labels. It also works on other vector spaces, in which case it returns Trivial. The function sectors returns an iterator over the different sectors a with non-zero n_a, for other ElementarySpace types it returns (Trivial,). The degeneracy dimensions n_a can be extracted as dim(V, a), it properly returns 0 if sector a is not present in the decomposition of V. With hassector(V, a) one can check if V contains a sector a with dim(V, a) > 0. Finally, dim(V) returns the total dimension of the space V, i.e. _a n_a d_a or thus dim(V) = sum(dim(V, a) * dim(a) for a in sectors(V)). Note that a representation space V has certain sectors a with dimensions n_a, then its dual V' will report to have sectors dual(a), and dim(V', dual(a)) == n_a. There is a subtelty regarding the difference between the dual of a representation space R_a^*, on which the conjugate representation acts, and the representation space of the irrep dual(a) == conj(a) that is isomorphic to the conjugate representation, i.e. R_overlinea  R_a^* but they are not equal. We return to this in the section on fusion trees. This is true also in more general fusion categories beyond the representation categories of groups.\n\nOther methods for ElementarySpace, such as dual, fuse and flip also work. In fact, GradedSpace is the reason flip exists, because in this case it is different than dual. The existence of flip originates from the non-trivial isomorphism between R_overlinea and R_a^*, i.e. the representation space of the dual overlinea of sector a and the dual of the representation space of sector a. In order for flip(V) to be isomorphic to V, it is such that, if V = GradedSpace(a=>n_a,...) then flip(V) = dual(GradedSpace(dual(a)=>n_a,....)).\n\nFurthermore, for two spaces V1 = GradedSpace(a => n1_a, ...) and V2 = GradedSpace(a => n2_a, ...), we have infimum(V1, V2) = GradedSpace(a => min(n1_a, n2_a), ....) and similarly for supremum, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of infimum(V1, V2) or supremum(V1, V2) is neither equal to V1 or V2.\n\nFor W a ProductSpace{Vect[I], N}, sectors(W) returns an iterator that generates all possible combinations of sectors as represented as NTuple{I, N}. The function dims(W, as) returns the corresponding tuple with degeneracy dimensions, while dim(W, as) returns the product of these dimensions. hassector(W, as) is equivalent to dim(W, as) > 0. Finally, there is the function blocksectors(W) which returns a list (of type Vector) with all possible \"block sectors\" or total/coupled sectors that can result from fusing the individual uncoupled sectors in W. Correspondingly, blockdim(W, a) counts the total degeneracy dimension of the coupled sector a in W. The machinery for computing this is the topic of the next section on Fusion trees, but first, it's time for some examples.","category":"section"},{"location":"man/gradedspaces/#Examples","page":"Graded spaces","title":"Examples","text":"Let's start with an example involving mathsfU_1:\n\nV1 = Rep[U‚ÇÅ](0=>3, 1=>2, -1=>1)\nV1 == U1Space(0=>3, 1=>2, -1=>1) == U‚ÇÅSpace(-1=>1, 1=>2,0=>3) # order doesn't matter\n(sectors(V1)...,)\ndim(V1, U1Irrep(1))\ndim(V1', Irrep[U‚ÇÅ](1)) == dim(V1, conj(U1Irrep(1))) == dim(V1, U1Irrep(-1))\nhassector(V1, Irrep[U‚ÇÅ](1))\nhassector(V1, Irrep[U‚ÇÅ](2))\ndual(V1)\nflip(V1)\ndual(V1) ‚âÖ V1\nflip(V1) ‚âÖ V1\nV2 = U1Space(0=>2, 1=>1, -1=>1, 2=>1, -2=>1)\ninfimum(V1, V2)\nsupremum(V1, V2)\n‚äï(V1,V2)\nW = ‚äó(V1,V2)\ncollect(sectors(W))\ndims(W, (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)))\ndim(W, (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)))\nhassector(W, (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)))\nhassector(W, (Irrep[U‚ÇÅ](2), Irrep[U‚ÇÅ](0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, Irrep[U‚ÇÅ](0))\n\nand then with mathsfSU_2:\n\nV1 = Vect[Irrep[SU‚ÇÇ]](0=>3, 1//2=>2, 1=>1)\nV1 == SU2Space(0=>3, 1/2=>2, 1=>1) == SU‚ÇÇSpace(0=>3, 0.5=>2, 1=>1)\n(sectors(V1)...,)\ndim(V1, SU2Irrep(1))\ndim(V1', SU2Irrep(1)) == dim(V1, conj(SU2Irrep(1))) == dim(V1, Irrep[SU‚ÇÇ](1))\ndim(V1)\nhassector(V1, Irrep[SU‚ÇÇ](1))\nhassector(V1, Irrep[SU‚ÇÇ](2))\ndual(V1)\nflip(V1)\nV2 = SU2Space(0=>2, 1//2=>1, 1=>1, 3//2=>1, 2=>1)\ninfimum(V1, V2)\nsupremum(V1, V2)\n‚äï(V1,V2)\nW = ‚äó(V1,V2)\ncollect(sectors(W))\ndims(W, (Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](0)))\ndim(W, (Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](0)))\nhassector(W, (SU2Irrep(0), SU2Irrep(0)))\nhassector(W, (SU2Irrep(2), SU2Irrep(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, SU2Irrep(0))","category":"section"},{"location":"man/gradedspaces/#TensorKit.GradedSpace-man-gradedspaces","page":"Graded spaces","title":"TensorKit.GradedSpace","text":"struct GradedSpace{I<:Sector, D} <: ElementarySpace\nGradedSpace{I,D}(dims; dual::Bool = false) where {I<:Sector, D}\n\nA complex Euclidean space with a grading, i.e. a direct sum structure corresponding to labels in a set I, the objects of which have the structure of a monoid with respect to a monoidal product ‚äó. In practice, we restrict the label set to be a set of superselection sectors of type I<:Sector, e.g. the set of distinct irreps of a finite or compact group, or the isomorphism classes of simple objects of a unitary and pivotal (pre-, multi-) fusion category.\n\nHere dims represents the degeneracy or multiplicity of every sector.\n\nThe data structure D of dims will depend on the result Base.IteratorSize(values(I)). If the result is of type HasLength or HasShape, dims will be stored in a NTuple{N,Int} with N = length(values(I)). This requires that a sector s::I can be transformed into an index via s == getindex(values(I), i) and i == findindex(values(I), s). If Base.IteratorElsize(values(I)) results IsInfinite() or SizeUnknown(), a SectorDict{I,Int} is used to store the non-zero degeneracy dimensions with the corresponding sector as key. The parameter D is hidden from the user and should typically be of no concern.\n\nThe concrete type GradedSpace{I,D} with correct D can be obtained as Vect[I], or if I == Irrep[G] for some G<:Group, as Rep[G].\n\n\n\n\n\n","category":"type"},{"location":"appendix/categories/#s_categories","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The purpose of this page (which can safely be skipped), is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors. In particular, we are interested in the category mathbfVect, but our concept of tensors can be extended to morphisms of any category that shares similar properties. These properties are reviewed below.\n\nIn particular, we will as example also study the more general case of mathbfSVect, i.e. the category of super vector spaces, which contains mathbfVect as a subcategory and which are useful to describe fermions.\n\nIn the end, the goal of identifying tensor manipulations in TensorKit.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following exposition is mostly based on [Turaev], combined with input from [Selinger], [Kassel], [Kitaev], and nLab, to which we refer for further information. Furthermore, we recommend the nice introduction of [Beer].","category":"section"},{"location":"appendix/categories/#ss_categoryfunctor","page":"Optional introduction to category theory","title":"Categories, functors and natural transformations","text":"To start, a category C consists of\n\na class mathrmOb(C) of objects V, W, ‚Ä¶\nfor each pair of objects V and W, a set mathrmHom_C(WV) of morphisms fWV; for a given map f, W is called the domain or source, and V the codomain or target.\ncomposition of morphisms fWV and gXW into (f  g)XV that is associative, such that for hYX we have f  (g  h) = (f  g)  h\nfor each object V, an identity morphism mathrmid_VVV such that f  mathrmid_W = f = mathrmid_V  f.\n\nThe morphisms in mathrmHom_C(VV) are known as endomorphism and this set is also denoted as End_C(V). When the category C is clear, we can drop the subscript in mathrmHom(WV). A morphism fWV is an isomorphism if there exists a morphism f^-1VW called its inverse, such that f^-1  f = mathrmid_W and f  f^-1 = mathrmid_V.\n\nThroughout this manual, we associate a graphical representation to morphisms and compositions thereof, which is sometimes referred to as the Penrose graphical calculus. To morphisms, we associate boxes with an incoming and outgoing line denoting the object in its source and target. The flow from source to target, and thus the direction of morphism composition f  g (sometimes known as the flow of time) can be chosen left to right (like the arrow in fWV), right to left (like the composition order f  g, or the matrix product), bottom to top (quantum field theory convention) or top to bottom (quantum circuit convention). Throughout this manual, we stick to this latter convention (which is not very common in manuscripts on category theory):\n\n<img src=\"../img/diagram_morphism.svg\" alt=\"composition\" class=\"color-invertible\"/>\n\nThe direction of the arrows, which become important once we introduce duals, are also subject to convention, and are here chosen to follow the arrow in fWV, i.e. the source comes in and the target goes out. Strangely enough, this is opposite to the most common convention.\n\nIn the case of interest, i.e. the category mathbf(Fin)Vect_ùïú (or some subcategory thereof), the objects are (finite-dimensional) vector spaces over a field ùïú, and the morphisms are linear maps between these vector spaces with \"matrix multiplication\" as composition. More importantly, the morphism spaces mathrmHom(WV) are themselves vector spaces. More general categories where the morphism spaces are vector spaces over a field ùïú (or modules over a ring ùïú) and the composition of morphisms is a bilinear operation are called ùïú-linear categories (or ùïú-algebroids, or mathbfVect_ùïú-enriched categories). In that case, the endomorphisms mathrmEnd(V) are a ùïú-algebra with mathrmid_V as the identity.\n\nWe also introduce some definitions which will be useful further on. A functor F between two categories C and D is, colloquially speaking, a mapping between categories that preserves morphism composition and identities. More specifically, FCD assigns to every object V  mathrmOb(C) an object F(V)  mathrmOb(D), and to each morphism f  mathrmHom_C(WV) a morphism F(f)  mathrmHom_D(F(W) F(V)) such that F(f) _D F(g) = F(f _C g) and F(mathrmid_V) = mathrmid_F(V) (where we denoted the possibly different composition laws in C and D explicitly with a subscript). In particular, every category C has an identity functor 1_C that acts trivially on objects and morphisms. Functors can also be composed. A ùïú-linear functor between two ùïú-linear categories has a linear action on morphisms.\n\nGiven two categories C and D, and two functors F and G that map from C to D, a natural transformation œÜFG is a family of morphisms œÜ_V  mathrmHom_D(F(V)G(V)) in D, labeled by the objects V of C, such that œÜ_V  F(f) = G(f)  œÜ_W for all morphisms f  mathrmHom_C(WV). If all morphisms œÜ_V are isomorphisms, œÜ is called a natural isomorphism and the two functors F and G are said to be isomorphic.\n\nThe product of two categories C and C, denoted C  C, is the category with objects mathrmOb(CC) = mathrmOb(C)  mathrmOb(C), whose elements are denoted as tuples (V V), and morphisms mathrmHom_CC((WW) (VV)) = mathrmHom_C(WV)  mathrmHom_C(WV). Composition acts as (ff)  (gg) = (ff gg) and the identity is given by mathrmid_VV = (mathrmid_V mathrmid_V). In a similar fashion, we can define the product of functors FCD and FCD as a functor FF (CC)(DD) mapping objects (VV) to (F(V) F(V)) and morphisms (ff) to (F(f) F(f)).","category":"section"},{"location":"appendix/categories/#ss_monoidalcategory","page":"Optional introduction to category theory","title":"Monoidal categories","text":"The next property of the category mathbfVect that we want to highlight and generalize is that which allows to take tensor products. Indeed, a category C is said to be a tensor category (a.k.a. a monoidal category), if it has\n\na binary operation on objects  mathrmOb(C)  mathrmOb(C)  mathrmOb(C)\na binary operation on morphisms, also denoted as , such that  mathrmHom_C(W_1V_1)  mathrmHom_C(W_2V_2)  mathrmHom_C(W_1  W_2 V_1  V_2)\nan identity or unit object I\nthree families of natural isomorphisms:\n V  mathrmOb(C), a left unitor (a.k.a. left unitality constraint) Œª_V I  V  V\n V  mathrmOb(C), a right unitor (a.k.a. right unitality constraint) œÅ_V V  I  V\n V_1 V_2 V_3  mathrmOb(C), an associator (a.k.a. associativity constraint) Œ±_V_1V_2V_3(V_1  V_2)  V_3  V_1  (V_2  V_3) that satisfy certain consistency conditions (coherence axioms), which are known as the pentagon equation (stating that the two possible mappings from (((V_1  V_2)  V_3)  V_4) to (V_1  (V_2  (V_3  V_4))) are compatible) and the triangle equation (expressing compatibility between the two possible ways to map ((V_1  I)  V_2) to (V_1  (I  V_2))).\n\nIn terms of functors and natural transformations,  is a functor from the product category C  C to C. Furthermore, the left (or right) unitor Œª (or œÅ) is a natural isomorphism between a nameless functor CC that maps objects V  I  V (or VV  I) and the identity functor 1_C. Similarly, the associator Œ± is a natural isomorphism between the two functors (  1_C) and (1_C  ) from C  C  C to C. In a k-linear category, the tensor product of morphisms is also a bilinear operation. A monoidal category is said to be strict if I  V = V = V  I and (V_1V_2)V_3 = V_1(V_2V_3), and the left and right unitor and associator are just the identity morphisms for these objects.\n\nFor the category mathbfVect, the identity object I is just the scalar field ùïú over which the vector spaces are defined, and which can be identified with a one-dimensional vector space. This is not automatically a strict category, especially if one considers how to represent tensor maps on a computer. The distinction between V, I  V and V  I amounts to adding or removing an extra factor I to the tensor product structure of the domain or codomain, and so the left and right unitor are analogous to removing extra dimensions of size 1 from a multidimensional array. The fact that arrays with and without additional dimensions 1 are not automatically identical and an actual operation is required to insert or remove them, has led to some discussion in several programming languages that provide native support for multidimensional arrays.\n\nFor what concerns the associator, the distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3) is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We elaborate on this in the context of Fusion categories below. However, we can already note that we will always represent tensor products using a canonical order (((V_1  V_2)  V_3)   V_N). A similar approach can be followed to turn any tensor category into a strict tensor category (see Section XI.5 of [Kassel]).\n\nThe different natural isomorphisms involving the unit object have various relations, such as Œª_VW  Œ±_IVW = Œª_V  mathrmid_W and Œª_I = œÅ_I  I  I  I. The last relation defines an isomorphism between I  I and I, which can also be used to state that for f g  End_C(I), f  g = œÅ_I  (f  g)  Œª_I^-1 = g  f. Hence, the tensor product of morphisms in End_C(I) can be related to morphism composition in End_C(I), and furthermore, the monoid of endomorphisms End_C(I) is commutative (abelian). In the case of a ùïú-linear category, it is an abelian ùïú-algebra. In the case of mathbfVect, mathrmEnd(I) is indeed isomorphic to the field of scalars ùïú. We return to the general case where End_C(I) is isomorphic to ùïú itself in the section on pre-fusion categories.\n\nFurthermore, Mac Lane's coherence theorem states that the triangle and pentagon condition are sufficient to ensure that any consistent diagram made of associators and left and right unitors (involving all possible objects in C) commutes. For what concerns the graphical notation, the natural isomorphisms will not be represented and we make no distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3). Similarly, the identity object I can be added or removed at will, and when drawn, is often represented by a dotted or dashed line. Note that any consistent way of inserting the associator or left or right unitor to convert a graphical representation to a diagram of compositions and tensor products of morphisms gives rise to the same result, by virtue of Mac Lane's coherence theorem. Using the horizontal direction (left to right) to stack tensor products, this gives rise to the following graphical notation for the tensor product of two morphisms, and for a general morphism t between a tensor product of objects in source and target:\n\n<img src=\"../img/diagram-tensorproduct.svg\" alt=\"tensorproduct\" class=\"color-invertible\"/>\n\nAnother relevant example is the category mathbfSVect_ùïú, which has as objects super vector spaces over ùïú, which are vector spaces with a ‚Ñ§‚ÇÇ grading, i.e. they are decomposed as a direct sum V = V_0  V_1. Furthermore, the morphisms between two super vector spaces are restricted to be grading preserving, i.e.  f mathrmHom_mathbfSVect(WV) has f(W_0)  V_0 and f(W_1)  V_1. The graded tensor product between two super vector spaces is defined as (V_mathrmgW) = (V _mathrmg W)_0  (V _mathrmg W)_1 with (V _mathrmg W)_0 = (V_0  W_0)  (V_1  W_1) and (V _mathrmg W)_1 = (V_0  W_1)  (V_1  W_0). The unit object I is again isomorphic to ùïú, i.e. I_0 = ùïú and I_1 = 0, a zero-dimensional vector space. In particular, the category mathbfSVect_ùïú contains mathbfVect_ùïú as a (monoidal) subcategory, by only selecting those objects V for which V_1 = 0. We will return to the example of mathbfSVect throughout the remainder of this page.\n\nFinally, we generalize the notion of a functor between monoidal categories. A monoidal functor between two tensor categories (C _C I_C Œ±_C Œª_C œÅ_C) and (D _D I_D Œ±_D Œª_D œÅ_D) is a functor FCD together with two monoidal constraints, namely\n\na morphism F‚ÇÄI_D  F(I_C);\na natural transformation F_2=F_2(XY) F(X) _D F(Y)  F(X _C Y)  XY mathrmOb(C) between the functors _D(FF) and F _C from CC to D.   A monoidal natural transformation œÜ between two monoidal functors FCD and GCDis a natural transformation œÜFG that furthermore satisfies\nœÜ_I_C F_0 = G_0;\n XY  mathrmOb(C): œÜ_X  Y F_2(XY) = G_2(XY)(œÜ_X  œÜ_Y).\n\nFor further reference, we also define the following categories which can be associated with the category mathcalC = (C  I Œ± Œª œÅ)\n\nmathcalC^mathrmop = (C^mathrmop  I Œ±^mathrmop Œª^mathrmop œÅ^mathrmop) where the opposite category C^mathrmop has the same objects as C but has mathrmHom_C^mathrmop(XY) = mathrmHom_C(YX) and a composition law g ^mathrmop f = f  g, with  the composition law of C.   Furthermore, we have Œ±^mathrmop_XYZ = (Œ±_XYZ)^-1, Œª^mathrmop_X = (Œª_X)^-1 and œÅ^mathrmop_X = (œÅ_X)^-1;\nmathcalC^mathrmop = (C ^mathrmop I Œ±^mathrmop Œª^mathrmop œÅ^mathrmop) where the functor ^mathrmopCC  C is the opposite monoidal product, which acts as X ^mathrmop Y = Y  X on objects and similar on morphisms.   Furthermore, Œ±^mathrmop_XYZ = (Œ±_ZYX)^-1, Œª^mathrmop_X = œÅ_X and œÅ^mathrmop_X = Œª_X;\nThe two previous transformations (which commute) composed: mathcalC^mathrmrev = (C^mathrmop ^mathrmop I Œ±^mathrmrev Œª^mathrmrev œÅ^mathrmrev) with Œ±^mathrmrev_XYZ = Œ±_ZYX, Œª^mathrmrev_X = (œÅ_X)^-1, œÅ^mathrmrev_X = (Œª_X)^-1.","category":"section"},{"location":"appendix/categories/#ss_dual","page":"Optional introduction to category theory","title":"Duality: rigid, pivotal and spherical categories","text":"Another property of the category mathbfVect that we want to generalize is the notion of duals. For a vector space V, i.e. an object of mathbfVect, the dual V^* is itself a vector space. Evaluating the action of dual vector on a vector can, because of linearity, be interpreted as a morphism from V^*  V to I. Note that elements of a vector space V have no categorical counterpart in themselves, but can be interpreted as morphism from I to V. To map morphisms from mathrmHom(WV) to elements of V  W^*, i.e. morphisms in mathrmHom(I V  W^*), we use another morphism mathrmHom(I W  W^*) which can be considered as the inverse of the evaluation map.\n\nHence, duality in a monoidal category is defined via an exact pairing, i.e. two families of non-degenerate morphisms, the evaluation (or co-unit) œµ_V ^V  V  I and the coevaluation (or unit) Œ∑_V I  V  ^V which satisfy the \"snake rules\":\n\nbeginalign*\nœÅ_V  (mathrmid_V  œµ_V)  (Œ∑_V  mathrmid_V)  Œª_V^-1 = mathrmid_V\nŒª_^V^-1  (œµ_V  mathrmid_^V)  (mathrmid_^V  Œ∑_V)  œÅ_^V^-1 = mathrmid_^V\nendalign*\n\nand can be used to define an isomorphism between mathrmHom(W  V U) and mathrmHom(W U  ^V) for any triple of objects U V W  mathrmOb(C). Note that if there are different duals (with corresponding exact pairings) associated to an object V, a mixed snake composition using the evaluation of one and coevaluation of the other duality can be used to construct an isomorphism between the two associated dual objects. Hence, duality is unique up to isomorphisms.\n\nFor (real or complex) vector spaces, we denote the dual as V^*, a notation that we preserve for pivotal categories (see below). Using a bra-ket notation and a generic basis n for V and dual basis m for V^* (such that mn = Œ¥_mn), the evaluation is given by œµ_V^V  V  ‚ÑÇ m  n  Œ¥_mn and the coevaluation or unit is Œ∑_V‚ÑÇ V  ^VŒ±  Œ± _n n  n. Note that this does not require an inner product, i.e. no relation or mapping from n to n was defined. For a general tensor map tW_1  W_2    W_N_2  V_1  V_2    V_N_1, by successively applying Œ∑_W_N_2, Œ∑_W_N_2-1, ‚Ä¶, Œ∑_W_1 (in combination with the left or right unitor), we obtain a tensor in V_1  V_2    V_N_1  W_N_2^*    W_1^*. Hence, we can define or identify (W_1  W_2    W_N_2)^* = W_N_2^*    W_1^*. Indeed, it can be shown that for any category which has duals for objects V and W, an exact pairing between V  W and ^W  ^V can be constructed out of the evaluation and coevaluation of V and W, such that ^W  ^V is at least isomorphic to ^(V  W).\n\nGraphically, we represent the exact pairing and snake rules as\n\n<img src=\"../img/diagram-leftdual.svg\" alt=\"left dual\" class=\"color-invertible\"/>\n\nNote that we denote the dual objects ^V as a line V with arrows pointing in the opposite (i.e. upward) direction. This notation is related to quantum field theory, where anti-particles are (to some extent) interpreted as particles running backwards in time.\n\nThese exact pairings are known as the left evaluation and coevaluation, and ^V is the left dual of V. Likewise, we can also define a right dual V^ of V and associated pairings, the right evaluation tildeœµ_V V  V^  I and coevaluation tildeŒ∑_V I  V^  V, satisfying\n\n<img src=\"../img/diagram-rightdual.svg\" alt=\"right dual\" class=\"color-invertible\"/>\n\nIn particular, one could choose tildeœµ_^V = œµ_V and thus define V as the right dual of ^V. While there might be other choices, this choice must at least be isomorphic, such that (^V)^  V.\n\nIf objects V and W have left (respectively right) duals, then for a morphism f  mathrmHom(WV), we furthermore define the left (respectively right) transpose ^f  mathrmHom(^V ^W) (respectively f^  mathrmHom(V^ W^)) as\n\n<img src=\"../img/diagram-transpose.svg\" alt=\"transpose\" class=\"color-invertible\"/>\n\nwhere on the right we also illustrate the mapping from t  mathrmHom(W_1  W_2  W_3 V_1  V_2) to a morphism in mathrmHom(I V_1  V_2  ^ W_3  ^ W_2  ^ W_1).\n\nNote that the graphical notation, at least the lines with opposite arrows, do not allow to distinguish between the right dual V^ and the left dual ^V. We come back to this point below.\n\nA left (or right) duality in a (monoidal) category is now defined as an association of a left (or right) dual with every object of the category, with corresponding exact pairings, and a category admitting such a duality is a left (or right) rigid category (or left or right autonomous category). Given that left (or right) morphism transposition satisfies ^(f  g)= ^g  ^f= ^f ^mathrmop ^g and recalling ^(V  W) = ^W  ^V (and similar for right duality), we can define duality in a functorial way. A (left or right) rigid category mathcalC is a category which admits a (left or right) duality functor, i.e. a functor from mathcalC to mathcalC^mathrmrev that maps objects to its (left or right) dual, and morphisms to its (left or right) transpose. In particular, the snake rules can now be read as the functioral requirement that ^(mathrmid_V) = mathrmid_^V.\n\nIn all of this, left and right duality can be completely distinct. Equivalently, the left dual of the left dual of an object V, i.e. ^V is not necessarily V itself, nor do the exact pairings enable us to construct an isomorphism between ^V and V. For finite-dimensional vector spaces, however, ^V and V, or thus ^V and V^ are known to be isomorphic. The categorical generalization is that of a pivotal category (or sovereign category), i.e. a monoidal category with two-sided duals X^* = ^X = X^ = X^* such that the left and right duality functor coincide, and thus also the left and right transpose of morphisms, i.e.  f^* = ^f = f^  mathrmHom(V^*W^*) for any fmathrmHom(WV). Given that tildeœµ_X and tildeŒ∑_X can be interpreted as an exact pairing œµ_X^* and Œ∑_X^*, this can be used to recognize X as a left dual of X^*, which is then not necessarily equal but at least isomorphic to X^** with the isomorphism given by the mixed snake composition alluded to in the beginning of this section, i.e. Œ¥_X X  X^** given by Œ¥_X = (tildeœµ_X  mathrmid_X^*)  (mathrmid_X  Œ∑_X^*). A more formal statement is that Œ¥ is a natural isomorphism between the double dual functor and the identity functor of a category C. In a similar manner, such a Œ¥ can be used to define a natural isomorphism between left and right dual functor (which is a slight generalization of the above definition of a pivotal category), and as such it is often called the pivotal structure.\n\nHence, in a pivotal category, left and right duals are the same or isomorphic, and so are objects and their double duals. As such, we will not distinguish between them in the graphical representation and suppress the natural isomorphism Œ¥. Note, as already suggested by the graphical notation above, that we can interpret transposing a morphism as rotating its graphical notation by 180 degrees (either way).\n\nFurthermore, in a pivotal category, we can define a map from mathrmEnd(V), the endomorphisms of an object V to endomorphisms of the identity object I, i.e. the field of scalars in the case of the category mathbfVect, known as the trace of f. In fact, we can define both a left trace as\n\nmathrmtr_mathrml(f) = œµ_V  (mathrmid_V^*  f)  tildeŒ∑_V\n\nand a right trace as\n\nmathrmtr_mathrmr(f) = tildeœµ_V  (f  mathrmid_V^*)  Œ∑_V\n\nThey are graphically represented as\n\n<img src=\"../img/diagram-trace.svg\" alt=\"trace\" class=\"color-invertible\"/>\n\nand they do not need to coincide. Note that mathrmtr_mathrml(f) = mathrmtr_mathrmr(f*) and that mathrmtr_mathrmlmathrmr(fg) = mathrmtr_mathrmlmathrmr(gf). The (left or right) trace of the identity morphism mathrmid_V defines the corresponding (left or right) dimension of the object V, i.e. mathrmdim_mathrmlmathrmr(V) = tr_mathrmlmathrmr(mathrmid_V). In a spherical category, both definitions of the trace coincide for all V and we simply refer to the trace mathrmtr(f) of an endomorphism. The particular value mathrmdim(V) = mathrmtr(mathrmid_V) is known as the (quantum) dimension of the object V, referred to as dim(V) in TensorKit.jl.\n\nFor further information and a more detailed treatment of rigid and pivotal categories, we refer to [Turaev] and [Selinger]. We conclude this section by studying the example of mathbfSVect. Let us, in every super vector space V, define a basis n that is compatible with the grading. The value n=01 indicates that n  V_n. We again define a dual basis m for V^* (such that mn = Œ¥_mn), and then define the left evaluation by œµ_VV^*  V  ‚ÑÇ m _mathrmg n  mn = Œ¥_mn and the left coevaluation by Œ∑_V‚ÑÇ V  V^*Œ±  Œ± _n n _mathrmg n. Note that this does not require an inner product and satisfies the snake rules. For the right evaluation and coevaluation, there are two natural choices, namely tildeœµ_VV  V^*  ‚ÑÇ n _mathrmg m  (1)^n Œ¥_mn and tildeŒ∑_V‚ÑÇ  V^*  V Œ±  _n (1)^n n _mathrmg n. The resulting trace of an endomorphism f  mathrmEnd(V) is given by mathrmtr^mathrml(f) = mathrmtr^mathrmr(f) = mathrmtr(f) = _n ( 1)^n nfn and is known as either the regular trace (in the case of +1) or the supertrace (in the case of -1). In particular, mathrmdim(V) = mathrmdim(V_0)  mathrmdim(V_1), and can be negative in the case of the supertrace. Both are valid choices to make mathbfSVect into a spherical category.","category":"section"},{"location":"appendix/categories/#ss_braiding","page":"Optional introduction to category theory","title":"Braidings, twists and ribbons","text":"While duality and the pivotal structure allow to move vector spaces back and forth between the domain (source) and codomain (target) of a tensor map, reordering vector spaces within the domain or codomain of a tensor map, i.e. within a tensor product V_1  V_2   V_N requires additional structure. In particular, we need at the very least a braided tensor category C, which is endowed with a braiding œÑ, i.e. a natural isomorphism œÑ_VWVW  WV_VW  mathrmOb(C) between the functors  and ^mathrmop such that œÑ_VV(f  g) = (g  f)œÑ_WW for any morphisms f  mathrmHom(WV) and g  mathrmHom(WV). A valid braiding needs to satisfy a coherence condition with the associator Œ± known as the hexagon equation, which expresses that the braiding is -multiplicative, i.e.  œÑ_UVW = (mathrmid_V  œÑ_UW)(œÑ_UVmathrmid_W) and œÑ_UVW = (œÑ_UWmathrmid_VW)(mathrmid_U  œÑ_VW) (where the associator has been omitted). We also have Œª_V  œÑ_VI = œÅ_VI, œÅ_V  œÑ_IV = Œª_V and œÑ_VI = œÑ_IV^-1 for any V  mathrmOb(C).\n\nThe braiding isomorphism œÑ_VW and its inverse are graphically represented as the lines V and W crossing over and under each other:\n\n<img src=\"../img/diagram-braiding.svg\" alt=\"braiding\" class=\"color-invertible\"/>\n\nsuch that we have\n\n<img src=\"../img/diagram-braiding2.svg\" alt=\"braiding relations\" class=\"color-invertible\"/>\n\nwhere the expression on the right hand side, œÑ_WVœÑ_VW can generically not be simplified. Hence, for general braidings, there is no unique choice to identify a tensor in VW and WV, as the isomorphisms œÑ_VW, œÑ_WV^-1, œÑ_VW  œÑ_WV  œÑ_VW, ‚Ä¶ mapping from VW to WV can all be different. In order for there to be a unique map from V_1  V_2   V_N to any permutation of the objects in this tensor product, the braiding needs to be symmetric, i.e. œÑ_VW = œÑ_WV^-1 or, equivalently œÑ_WV  œÑ_VW = mathrmid_VW. The resulting category is then referred to as a symmetric tensor category. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross, where the crossing represents the action of œÑ_VW = œÑ_WV^-1.\n\nIn the case of the category mathbfVect a valid braiding consists of just flipping the the objects/morphisms involved, e.g. for a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia's function permutedims on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries (where the fusion tree needs to be reordered, as discussed in Sectors, representation spaces and fusion trees) or in the case of mathbfSVect, which will again be studied in detail at the end of this section.\n\nThe braiding of a space and a dual space also follows naturally, it is given by œÑ_V^*W = Œª_W  V^*  (œµ_V  mathrmid_W  V^*)  (mathrmid_V^*  œÑ_VW^-1  mathrmid_V^*)  (mathrmid_V^* W  Œ∑_V)  œÅ_V^*  W^-1, i.e.\n\n<img src=\"../img/diagram-braidingdual.svg\" alt=\"braiding dual\" class=\"color-invertible\"/>\n\nBalanced categories C are braided categories that come with a twist Œ∏, a natural transformation from the identity functor 1_C to itself, such that Œ∏_V  f = f  Œ∏_W for all morphisms f  mathrmHom(WV), and for which the main requirement is that\n\nŒ∏_VW = œÑ_WV  (Œ∏_W  Œ∏_V)  œÑ_VW = (Œ∏_V  Œ∏_W)  œÑ_WV  œÑ_VW\n\nIn particular, a braided pivotal category is balanced, as we can even define two such twists, namely a left and right twist given by\n\nŒ∏^mathrml_V = (œµ_V  mathrmid_V)(mathrmid_V*  œÑ_VV) (tildeŒ∑_V  mathrmid_V)\n\nand\n\nŒ∏^mathrmr_V = (mathrmid_V  tildeœµ_V)(œÑ_VV  mathrmid_V*)(mathrmid_V  œµ_V)\n\nwhere we omitted the necessary left and right unitors and associators. Graphically, the twists and their inverse (for which we refer to [Turaev]) are then represented as\n\n<img src=\"../img/diagram-twists.svg\" alt=\"twists\" class=\"color-invertible\"/>\n\nThe graphical representation also makes it straightforward to verify that (Œ∏^mathrml_V)^* = Œ∏^mathrmr_V^*, (Œ∏^mathrmr_V)^* = Œ∏^mathrml_V^* and mathrmtr_mathrml( Œ∏^mathrmr_V ) = mathrmtr_mathrmr( Œ∏^mathrml_V ).\n\nWhen Œ∏^mathrml = Œ∏^mathrmr, or thus, equivalently, Œ∏_V^* = Œ∏_V^* for either Œ∏^mathrml or Œ∏^mathrmr, the category is said to be tortile or also a ribbon category, because its graphical representation is compatible with the isotopy of a ribbon, i.e. where the lines representing objects are depicted as ribbons. For convenience, we continue to denote them as lines. Ribbon categories are necessarily spherical, i.e. one can prove the equivalence of the left and right trace.\n\nAlternatively, one can start from a balanced and rigid category (e.g. with a left duality), and use the twist Œ∏, which should satisfy Œ∏_V^* = Œ∏_V^*, to define a pivotal structure, or, to define the exact pairing for the right dual functor as\n\ntildeŒ∑_V = œÑ_VV^*  (Œ∏_V  mathrmid_V^*)  Œ∑_V = (mathrmid_V^*  Œ∏_V)  œÑ_VV^*  Œ∑_V\n\ntildeœµ_V = œµ_V  (mathrmid_V^*  Œ∏_V)  œÑ_VV^* = œµ_V  œÑ_VV^*  (Œ∏_V  mathrmid_V^*)\n\nor graphically\n\n<img src=\"../img/diagram-pivotalfromtwist.svg\" alt=\"pivotal from twist\" class=\"color-invertible\"/>\n\nwhere we have drawn Œ∏ as Œ∏^mathrml on the left and as Œ∏^mathrmr on the right, but in this case the starting assumption was that they are one and the same, and we defined the pivotal structure so as to make it compatible with the graphical representation. This construction of the pivotal structure can than be used to define the trace, which is spherical, i.e.\n\nmathrmtr(f) = œµ_V  œÑ_VV^*  (( Œ∏_V  f)  mathrmid_V^*)  Œ∑_V = œµ_V  (mathrmid_V^*  (f  Œ∏_V))  œÑ_VV^*  Œ∑_V\n\nNote finally, that a ribbon category where the braiding is symmetric, is known as a compact closed category. For a symmetric braiding, the trivial twist Œ∏_V = mathrmid_V is always a valid choice, but it might not be the choice that one necessarily want to use. Let us study the case of mathbfSVect again. Reinvoking our basis m  V and n  W, the braiding œÑ_VW is given by the Koszul sign rule, i.e. œÑ_VWm _mathrmg n  (-1)^m n n _mathrmg m. Hence, braiding amounts to flipping the two spaces, but picks up an additional minus sign if both m  V_1 and n  W_1. This braiding is symmetric, i.e. œÑ_WV  œÑ_VW = mathrmid_VW. Between spaces and dual spaces, we similarly obtain the braiding rule m _mathrmg n  (-1)^m n n _mathrmg m. Combining the braiding and the pivotal structure gives rise to a ribbon category, and thus, a compact closed category, where the resulting twist is given by Œ∏_V  n  (1)^n n for tildeœµ_VV  V^*  ‚ÑÇ n _mathrmg m  (1)^n Œ¥_mn and corresponding tildeŒ∑_V. Hence, if the right (co)evaluation contains a minus sign, the twist is Œ∏_V = mathrmid_V, which, as mentioned above, is always a valid twist for a symmetric category. However, if the right (co)evaluation contains no minus sign, the twist acts as the parity endomorphism, i.e. as +1 on V_0 and as -1 on V_1, which, as we will see in the next section, corresponds to a choice bearing additional structure.","category":"section"},{"location":"appendix/categories/#ss_adjoints","page":"Optional introduction to category theory","title":"Adjoints and dagger categories","text":"A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A dagger category C is a category together with an involutive functor CC^mathrmop, i.e. it acts as the identity on objects, whereas on morphisms fWV it defines a morphism f^VW such that\n\nmathrmid_V^ = mathrmid_V\n(f  g)^ = f^ ^mathrmop g^ = g^  f^\n(f^)^ = f.\n\nSometimes also the symbol * is used instead of . However, we have already used * to denote dual objects and transposed morphisms in the case of a pivotal category.\n\nIf the category is ‚ÑÇ-linear, the dagger functor is often assumed to be antilinear, i.e.  (Œª f)^ = barŒª f^ for Œª  ‚ÑÇ and f  mathrmHom(VW). In a dagger category, a morphism fWV is said to be unitary if it is an isomorphism and f^-1 = f^. Furthermore, an endomorphism fVV is hermitian or self-adjoint if f^ = f. Finally, we will also use the term isometry for a morphism fWV which has a left inverse f^, i.e. such that f^  f = mathrmid_W, but for which f  f^ is not necessarily the identity (but rather some orthogonal projector, i.e. a hermitian idempotent in mathrmEnd(V)).\n\nIn the graphical representation, the dagger of a morphism can be represented by mirroring the morphism around a horizontal axis, and then reversing all arrows (bringing them back to their original orientation before the mirror operation):\n\n<img src=\"../img/diagram-dagger.svg\" alt=\"dagger\" class=\"color-invertible\"/>\n\nwhere for completeness we have also depicted the graphical representation of the transpose, which is a very different operation. In particular, the dagger does not reverse the order of the tensor product. Note that, for readibility, we have not mirrored or rotated the label in the box, but this implies that we need to use a type of box for which the action of mirroring or rotating can be observed.\n\nA dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.\n\nThere is more to be said about the interplay between the dagger and duals. Given a left evaluation œµ_V V^*  V  I and coevaluation Œ∑_V I  V  V^*, we can define a right evaluation tildeœµ_V = (Œ∑_V)^ and coevaluation tildeŒ∑_V = (œµ_V)^. Hence, left rigid dagger categories are automatically pivotal dagger categories.\n\nThe (right) twist defined via the pivotal structure now becomes\n\nŒ∏_V = (mathrmid_V  (Œ∑_V)^)  (œÑ_VV  mathrmid_V^*)  (mathrmid_V  Œ∑_V)\n\nand is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity, as we discuss for the mathbfSVect example below.\n\nFinally, the dagger allows to define two Hermitian forms on the morphisms, namely  f g _mathrmlmathrmr = mathrmtr_mathrmlmathrmr(f^ g), which coincide for a spherical category. For a unitary ùïú-linear category, these Hermitian forms should be positive definite and thus define an inner product on each of the homomorphism spaces mathrmHom(WV). In particular then, dimensions of objects are positive, as they satisfy mathrmdim_mathrmlmathrmr(V) =  mathrmid_V mathrmid_V _mathrmlmathrmr.\n\nThis concludes the most important categorical definitions and structures that we want to discuss for the category mathbfVect, but which can also be realized in other categories. In particular, the interface of TensorKit.jl could in principle represent morphisms from any ùïú-linear monoidal category, but assumes categories with duals to be pivotal and in fact spherical, and categories with a braiding to be ribbon categories. A dagger ribbon category where the braiding is symmetric, i.e. a dagger category which is also a compact closed category and where the right (co)evaluation is given via the dagger of the left (co)evaluation, is called a dagger compact category. This is the playground of quantum mechanics of bosonic and fermionic systems. However, we also allow for non- symmetric braiding in TensorKit.jl, though this functionality typically requires more careful considerations.\n\nAgain studying the category mathbfSVect_‚ÑÇ (now explicitly over the complex numbers) and using the conventional adjoint or the complex Euclidean inner product to define the dagger functor, the right (co)evaluation that is obtained from applying the dagger to the left (co)evaluation is the definition we gave above with the +1 sign. This choice gives rise to a regular trace (versus the supertrace) of endomorphisms, to positive dimensions, and a non-trivial twist that acts as the parity endomorphism. The resulting category is then a dagger compact category, that can be used for the quantum mechanical description of fermionic systems. The bosonic version is obtained by restricting to the subcategory mathbfVect.","category":"section"},{"location":"appendix/categories/#ss_fusion","page":"Optional introduction to category theory","title":"Direct sums, simple objects and fusion categories","text":"These last two section on fusion categories is also applicable, in a straightforward manner, to mathbfVect and mathbfSVect, but is rather meant to provide the background of working with symmetries. We first need two new concepts:\n\nAn object W  mathrmOb(C) is a direct sum of objects V_1 V_2  V_k  mathrmOb(C) if there exists a family morphisms x_Œ±  mathrmHom(V_Œ±W) and y^Œ±  mathrmHom(WV_Œ±) such that mathrmid_W = _Œ±=1^k x_Œ±  y^Œ± and y^Œ±  x_Œ≤ = Œ¥^Œ±_Œ≤ mathrmid_V_Œ±.   The morphisms x_Œ± and y^Œ± are known as inclusions and projections respectively, and in the context of dagger categories it is natural to assume y^Œ± = x_Œ±^ in order to obtain an orthogonal direct sum decomposition.\nA simple object V  mathrmOb(C) of a ùïú-linear category C is an object for which End_C(V)  ùïú, i.e. the algebra of endomorphisms on V is isomorphic to the field (or ring) ùïú.   As End_C(V) always contains the identity morphism mathrmid_V, and this must be the only linearly independent endomorphism if V is a simple object, the isomorphism between mathrmEnd_C(V) and ùïú is typically of the form k  ùïú  k mathrmid_V  End_C(V).   In particular, for mathbfSVect and its subcategory mathbfVect, the unit object I is a simple object.\n\nIn particular, for a pivotal ùïú-linear category where I is simple, it holds that the left and right dimensions of any simple object V are invertible in ùïú, and that any endomorphism f  mathrmEnd(V) can be written as\n\nf = (mathrmdim_mathrml(V))^-1 mathrmtr_mathrml(f) mathrmid_V =\n(mathrmdim_mathrmr(V))^-1 mathrmtr_mathrmr(f) mathrmid_V\n\nStrictly speaking, this holds only if the category is non-degenerate, which means that I is simple and that any non-degenerate pairing eV  W  I induces a non-degenerate pairing mathrmHom(IV)  mathrmHom(IW)  mathrmEnd(I). This property is always satisfied for a pre-fusion category C, i.e. a monoidal ùïú- linear category having a set mathcalS  mathrmOb(C) of simple objects mathcalS=I V_1 V_2 ldots such that\n\nthe monoidal unit I_C  mathcalS;\nmathrmHom_C(V_iV_j) = 0 (the singleton set containing only the zero homomorphism) for any distinct V_i V_j  mathcalS;\nevery object V  mathrmOb(C) can be written as a direct sum of a finite family of elements from mathcalS.\n\nNote that in the direct sum decomposition of an object V, a particular simple object V_i might appear multiple times. This number is known as the multiplicity index N^V_i, and equal to the rank of mathrmHom(VV_i) or, equivalently, of mathrmHom(V_iV). Hence, we can choose inclusion and projection maps x_iŒºV_iV and y^iŒºVV_i for Œº = 1ldots N^V_i, such that mathrmid_V = sum_isum_Œº=1^N_V^i x_iŒº  y^iŒº and y^iŒº  x_jŒΩ = Œ¥^i_j Œ¥^Œº_ŒΩ. In particular, for a simple object V, it either appears in mathcalS or is isomorphic to an object S. We thus have N^V_i = 1 for one particular object V_i and N^V_j= 0 for all other j, with x_i and y^i = (x_i)^-1 representing the isomorphism between V and V_i.\n\nThe homomorphisms between two general objects W and V in a pre-fusion category can be decomposed as\n\nmathrmHom(WV)  _V_i  mathcalS mathrmHom(WV_i)  mathrmHom(V_iV)\n\nand thus that the rank of mathrmHom(WV) is given by _i N^W_i N^V_i.\n\nA fusion category is a pre-fusion category that has (left or right) duals, i.e. that is rigid, and that only has a finite number of isomorphism classes of simple objects. Note that the duality functor maps mathrmEnd(V) to mathrmEnd(V^*), such that, if V is a simple object, so must be V^*. Henceforth, we will be sloppy about the distinction between a pre-fusion or fusion category, only use the latter term, even when it is not fully justified.\n\nBefore continuing, let us use some examples to sketch the relevance of the concept of fusion categories. As mentioned, the categories mathbfVect_ùïú and mathbfSVect_ùïú have I  ùïú as simple object. For mathbfVect, this is the only simple object, i.e. any other vector space V over ùïú can be thought of as a direct sum over N^V_I = mathrmdim(V) multiple copies of ùïú. In mathbfSVect, the object J = 0  ùïú with J_0=0 the zero dimensional space and J_1  ùïú is another simple object. Clearly, there are no non-zero grading preserving morphisms between I and J, i. . mathrmHom(IJ) = 0, whereas mathrmHom(JJ)  ùïú. Any other super vector space V=V_0  V_1 can be written as a direct sum over N^V_I = mathrmdim(V_0) copies of I and N^V_J = mathrmdim(V_1) copies of J.\n\nA more representative example is that of the category C = mathbfRep_mathsfG, the category of representations of a group mathsfG. Colloquially, this could be thought of as a subcategory of mathbfVect containing as objects vector spaces V on which a representation of mathsfG is defined, denoted as u_V(g) for g  mathsfG, and as morphisms the equivariant transformations, i.e. intertwiners between the representations on the source and target:\n\nmathrmHom_C(WV) = f  mathrmHom_mathbfVect(WV) u_V(g)  f = f  u_W(g)  g  G\n\nNote that the u_V(g) is itself generally not an element from End_C(V). Simple objects V_a are those corresponding irreducible representations (irreps) a of the group mathsfG, for which Schur's lemma implies End_C(V_a)  ùïú and mathrmHom_C(V_a V_b) = 0 if a and b are not equivalent irreps. On the dual space V^*, the group acts with the contragradient representation, i.e.  u_V^*(g) = ((u_V(g))^-1)^* = u_V(g^-1)^*, where one should remind that ^* denotes the transpose. For a finite group or compact Lie group, we can introduce a dagger and restrict to unitary representations, such that u_V(g)^-1 = u_V(g)^ and the contragradient representation becomes the complex conjugated representation, denoted as u_V^*(g) = baru_V(g). The resulting category can then be given the structure of a unitary ribbon (pre-)fusion category. (Note that the number of isomorphism classes of simple objects, i.e. the number of non-equivalent irreps, is finite only in the case of a finite group). This example is very relevant to working with symmetries in TensorKit.jl, and will be expanded upon in more detail below.\n\nFusion categories have a number of simplifying properties. A pivotal fusion category is spherical as soon as mathrmdim_mathrml(V_i) = mathrmdim_mathrmr(V_i) (i.e. the trace of the identity morphism) for all (isomorphism classes of) simple objects (note that all isomorphic simple objects have the same dimension). A braided pivotal fusion category is spherical if and only if it is a ribbon category.","category":"section"},{"location":"appendix/categories/#ss_topologicalfusion","page":"Optional introduction to category theory","title":"Topological data of a unitary pivotal fusion category","text":"More explicitly, the different structures (monoidal structure, duals and pivotal structure, braiding and twists) in a fusion category can be characterized in terms of the simple objects, which we will henceforth denoted with just a instead of V_a. This gives rise to what is known as the topological data of a unitary pivotal fusion category, most importantly the N, F and R symbols, which are introduced in this final section.","category":"section"},{"location":"appendix/categories/#Monoidal-structure","page":"Optional introduction to category theory","title":"Monoidal structure","text":"Starting with the monoidal or tensor product, we start by characterizing how the object a  b can be decomposed as a direct sum over simple objects c, which gives rise to the multiplicity indices N_c^ab, as well as the inclusion maps, which we henceforth denote as X_cŒº^abcab for Œº=1N^c_ab. In the context of a unitary fusion category, on which we now focus, the corresponding projection maps are Y^cŒº_ab = (X_cŒº^ab)^abc such that\n\n(X_cŒº^ab)^  X_cŒº^ab = Œ¥_cc Œ¥_ŒºŒº mathrmid_c\n\nGraphically, we represent these relations as\n\n<img src=\"../img/diagram-fusion.svg\" alt=\"fusion\" class=\"color-invertible\"/>\n\nand also refer to the inclusion and projection maps as splitting and fusion tensor, respectively.\n\nFor both (ab)c and a(bc), which are isomorphic via the associator Œ±_abc, we must thus obtain a direct sum decomposition with the same multiplicity indices, leading to the associativity constraint\n\nN_d^abc= _e N_e^ab N_d^ec = _f N_f^bc N_d^af\n\nThe corresponding inclusion maps can be chosen as\n\nX_d(eŒºŒΩ)^abc = (X_eŒº^ab  mathrmid_c)  X_dŒΩ^ec  d(ab)c\n\nand\n\ntildeX_d(fŒ∫Œª)^abc = (mathrmid_a  X_fŒ∫^bc)  X_dŒª^af  da(bc)\n\nand satisfy\n\n(X_d(eŒºŒΩ)^abc)^  X_d(eŒºŒΩ)^abc = Œ¥_ee Œ¥_ŒºŒº Œ¥_ŒΩŒΩ Œ¥_dd mathrmid_d\n\n_deŒºŒΩ X_d(eŒºŒΩ)^abc  (X_d(eŒºŒΩ)^abc)^ = mathrmid_(ab)c\n\nand similar for tildeX_d(fŒ∫Œª)^abc. Applying the associator leads to a relation\n\nŒ±_abc  X_d(eŒºŒΩ)^abc = _fŒ∫Œª F^abc_d_(eŒºŒΩ)^(fŒ∫Œª) tildeX_d(fŒ∫Œª)^abc\n\nwhich defines the F-symbol, i.e. the matrix elements of the associator\n\n(tildeX_d(fŒ∫Œª)^abc)^  Œ±_abc  X_d(eŒºŒΩ)^abc = Œ¥_dd F^abc_d_(eŒºŒΩ)^(fŒ∫Œª) mathrmid_d\n\nNote that the left hand side represents a map in mathrmHom(dd), which must be zero if d is different from d, hence the Œ¥_dd on the right hand side. In a strict category, or in the graphical notation, the associator Œ± is omitted and these relations thus represent a unitary basis transform between the basis of inclusion maps X_d(eŒºŒΩ)^abc and tildeX_d(fŒ∫Œª)^abc, which is also called an F-move, i.e. graphically:\n\n<img src=\"../img/diagram-Fmove.svg\" alt=\"Fmove\" class=\"color-invertible\"/>\n\nThe matrix F^abc_d is thus a unitary matrix. The pentagon coherence equation can also be rewritten in terms of these matrix elements, and as such yields the celebrated pentagon equation for the F-symbols. In a similar fashion, the unitors result in N^a1_b = N^1a_b = Œ¥^a_b (where we have now written 1 instead of I for the unit object) and the triangle equation leads to additional relations between the F- symbols involving the unit object. In particular, if we identify X^1a_a1a(1a) with Œª_a^ and X^a1_a1a(a1) with œÅ_a^, the triangle equation and its collaries imply that F^1ab_c_(11Œº)^(cŒΩ1) = Œ¥^ŒΩ_Œº, and similar relations for F^a1b_c and F^ab1_c, which are graphically represented as\n\n<img src=\"../img/diagram-Fmove1.svg\" alt=\"Fmove1\" class=\"color-invertible\"/>\n\nIn the case of group representations, i.e. the category mathbfRep_mathsfG, the splitting and fusion tensors are known as the Clebsch-Gordan coefficients, especially in the case of mathsfSU_2. An F-move amounts to a recoupling and the F-symbols can thus be identified with the 6j-symbols (strictly speaking, Racah's W-symbol for mathsfSU_2).","category":"section"},{"location":"appendix/categories/#Duality-and-pivotal-structure","page":"Optional introduction to category theory","title":"Duality and pivotal structure","text":"Next up is duality. Since we are assuming a dagger category, it can be assumed pivotal, where the left dual objects are identical to the right dual objects, and the left and right (co)evaluation are related via the dagger. We have already pointed out above that the dual object a^* of a simple object a is simple, and thus, it must be isomorphic to one of the representatives bara of the different isomorphism classes of simple objects that we have chosen. Note that it can happen that bara=a. Duality implies an isomorphism between mathrmHom(WV) and mathrmHom(IVW^*), and thus, for a simple object a, mathrmEnd(a)  ùïú is isomorphic to mathrmHom(1aa^*), such that the latter is also isomorphic to ùïú, or thus N^abara_1 = 1. Also, all possible duals of a must be isomorphic, and thus there is a single representative bara such that N^ab_1 = Œ¥^bbara, i.e. for all other b  bara, mathrmHom(1ab)  mathrmHom(b^*a) = 0. Note that also barbara=a.\n\nLet us now be somewhat careful with respect to the isomorphism between a^* and bara. If bara  a, we can basically choose the representative of that isomorphism class as bara = a^*. However, this choice might not be valid if bara=a, as in that case the choice is already fixed, and might be different from a. To give a concrete example, the j=12 representation of mathsfSU_2 has a dual (contragradient, but because of unitarity, complex conjugated) representation which is isomorphic to itself, but not equal. In the context of tensors in quantum physics, we would like to be able to represent this representation and its conjugate, so we need to take the distinction and the isomorphism between them into account. This means that mathrmHom(a^*bara) is isomorphic to ùïú and contains a single linearly independent element, Z_a, which is a unitary isomorphism such that Z_a^dagger  Z_a = mathrmid_a^* and Z_a  Z_a^dagger = mathrmid_bara. Using the transpose, we obtain Z_a^*  mathrmHom(bara^*a), and thus it is proportional to Z_bara, i.e. Z_a^* = œá_a Z_bara with œá_a a complex phase (assuming ùïú = ‚ÑÇ). Another transpose results in Z_bara^* = œá_bara Z_a with œá_bara = overlineœá_a, where bar of a scalar quantity denotes its complex conjugate to avoid confusion with the transpose functor. If aand bara are distinct, we can essentially choose Z_bara such that œá_a is 1. However, for a=bara, the value of œá_a cannot be changed, but must satisfy œá_a^2 = 1, or thus œá_a = 1. This value is a topological invariant known as the Frobenius-Schur indicator. Graphically, we represent this isomorphism and its relations as\n\n<img src=\"../img/diagram-Zisomorphism.svg\" alt=\"Zisomorphism\" class=\"color-invertible\"/>\n\nWe can now discuss the relation between the exact pairing and the fusion and splitting tensors. Given that the (left) coevaluation Œ∑_a  mathrmHom(1 aa^*), we can define the splitting tensor as\n\nX^abara_1 = frac1sqrtd_a(mathrmid_a  Z_a)  Œ∑_a = frac1sqrtd_a(Z_a^*  mathrmid_bara)  tildeŒ∑_bara  mathrmHom(1 abara)\n\nThe prefactor takes care of normalization, i.e. with Œ∑_a^ = tildeœµ_a, we find Œ∑_a^  Œ∑_a = tildeœµ_a  Œ∑_a = mathrmtr(mathrmid_a) = d_a mathrmid_1, and thus (X^abara_1)^  X^abara_1 = mathrmid_1. Here, we have denoted d_a = mathrmdim(a) = mathrmtr(mathrmid_a) for the quantum dimension of the simple objects a. With this information, we can then compute F^abaraa_a, which has a single element (it's a 1  1 matrix), and find F^abaraa_a = fracœá_ad_a, where we've used tildeŒ∑_a = œµ_a^ and the snake rules. Hence, both the quantum dimensions and the Frobenius-Schur indicator are encoded in the F-symbol. Hence, they do not represent new independent data. Again, the graphical representation is more enlightning:\n\n<img src=\"../img/diagram-ZtoF.svg\" alt=\"ZtoF\" class=\"color-invertible\"/>\n\nWith these definitions, we can now also evaluate the action of the evaluation map on the splitting tensors, namely\n\n<img src=\"../img/diagram-splittingfusionrelation.svg\" alt=\"splittingfusionrelation\" class=\"color-invertible\"/>\n\nwhere again bar denotes complex conjugation in the second line, and we introduced two new families of matrices A^ab_c and B^ab_c, whose entries are composed out of entries of the F-symbol, namely\n\nA^ab_c^nu_mu = sqrtfracd_a d_bd_c œá_bara   overlineF^baraab_b_(111)^(cŒºŒΩ)\n\nand\n\nB^ab_c^nu_mu = sqrtfracd_a d_bd_c F^abbarb_a^(111)_(cŒºŒΩ)\n\nComposing the left hand side of first graphical equation with its dagger, and noting that the resulting element f  mathrmEnd(a) must satisfy f = d_a^-1 mathrmtr(f) mathrmid_a, i.e.\n\n<img src=\"../img/diagram-Brelation.svg\" alt=\"Brelation\" class=\"color-invertible\"/>\n\nallows to conclude that _ŒΩ B^ab_c^ŒΩ_Œº overlineB^ab_c^ŒΩ_Œº = delta_ŒºŒº, i.e. B^ab_c is a unitary matrix. The same result follows for A^ab_c in analogue fashion.\n\nnote: Note\nIn the context of fusion categories, one often resorts to the so-called isotopic normalization convention, where splitting tensors are normalized as (X^ab_cŒº)^  X^ab_cmu = sqrtfracd_a d_bd_c Œ¥_cc Œ¥_ŒºŒº mathrmid_c. This kills some of the quantum dimensions in formulas like the ones above and essentially allows to rotate the graphical notation of splitting and fusion tensors (up to a unitary transformation). Nonetheless, for our implementation of tensors and manipulations thereof (in particular orthonormal factorizations such as the singular value decomposition), we find it more convenient to work with the original normalization convention.\n\nLet us again study in more detail the example mathbfRep_mathsfG. The quantum dimension d_a of an irrep a is just the normal vector space dimension (over ùïú) of the space on which the irrep acts. The dual of an irrep a is its contragradient representation, which in the case of unitary representations amounts to the complex conjugate representation. This representation can be isomorphic to an already defined irrep bara, for example a itself. If that happens, it does not automatically imply that the irrep a is real-valued. For example, all irreps of mathsfSU_2 are self- dual, with the isomorphism given by a œÄ rotation over the y-axis (in the standard basis). The resulting Frobenius-Schur indicator is +1 for integer spin irreps, and -1 for half-integer spin irreps. The value œá_a=+1 indicates that the representation can be made real, e.g. the integer spin representations can be written as tensor representations of mathsfSO_3 by a change of basis. The value œá_a=-1 indicates that the representation is quaternionic and cannot be made real.\n\nThe (co)evaluation expresses that the standard contraction of a vector with a dual vector yields a scalar, i.e. a representation and its dual (the contragradient) yields the trivial representation when correctly contracted. The coevaluation together with the isomorphism between the conjugate of irrep a and some irrep bara yields a way to define the Clebsch-Gordan coefficients (i.e. the splitting and fusion tensor) for fusing a  bara to the trivial irrep, i.e. to what is called a singlet in the case of mathsfSU_2.","category":"section"},{"location":"appendix/categories/#Braidings-and-twists","page":"Optional introduction to category theory","title":"Braidings and twists","text":"Finally, we can study the braiding structure of a pivotal fusion category. Not all fusion categories have a braiding structure. The existence of a braiding isomorphism œÑ_VWVWWV requires at the very least that N^ab_c = N^ba_c at the level of the simple objects. We can then express œÑ_ab in terms of its matrix elements as\n\nœÑ_ab  X^ab_cŒº = _ŒΩ R^ab_c^ŒΩ_Œº X^ba_cŒΩ\n\nor graphically\n\n<img src=\"../img/diagram-braidingR.svg\" alt=\"braidingR\" class=\"color-invertible\"/>\n\nThe hexagon coherence axiom for the braiding and the associator can then be reexpressed in terms of the F-symbols and R-symbols.\n\nWe can now compute the twist, which for simple objects needs to be scalars (or in fact complex phases because of unitarity) multiplying the identity morphism, i.e.\n\nŒ∏_a =  mathrmid_a sum_bŒº fracd_bd_a R^aa_b^Œº_Œº\n\nor graphically\n\n<img src=\"../img/diagram-simpletwist.svg\" alt=\"simpletwist\" class=\"color-invertible\"/>\n\nHenceforth, we reserve Œ∏_a for the scalar value itself. Note that Œ∏_a = Œ∏_bara as our category is spherical and thus a ribbon category, and that the defining relation of a twist implies\n\nR^ba_c^Œ∫_Œº R^ab_c^Œº_ŒΩ = fractheta_cŒ∏_a Œ∏_b Œ¥^Œ∫_ŒΩ\n\nIf a = bara, we can furthermore relate the twist, the braiding and the Frobenius- Schur indicator via Œ∏_a œá_a R^aa_1 =1, because of\n\n<img src=\"../img/diagram-twistfrobeniusschur.svg\" alt=\"twistfrobeniusschur\" class=\"color-invertible\"/>\n\nFor the recurring example of mathbfRep_mathsfG, the braiding acts simply as the swap of the two vector spaces on which the representations are acting and is thus symmetric, i.e. œÑ_ba  œÑ_ab = mathrmid_ab. All the twists are simply Œ∏_a = 1. For an irrep that is self-dual, i.e. bara=a, the final expression simplifies to R^aa_1 = œá_a and thus states that the fusion from a  a to the trivial sector is either symmetric under swaps if œá_a=1 or antisymmetric if œá_a=-1. For the case of mathsfSU_2, the coupling of two spin j states to a singlet it symmetric for integer j and odd for half-integer j.\n\nWith this, we conclude our exposition of unitary fusion categories. There are many fusion categories that do not originate from the representation theory of groups, but are related to quantum groups and the representation theory of quasi-triangular Hopf algebras. They have non-integer quantum dimensions and generically admit for braidings which are not symmetric. A particular class of interesting fusion categories are modular fusion categories, which provide the mathematical structure for the theory of anyons and topological sectors in topological quantum states of matter. Thereto, one defines the modular S matrix, defined as\n\nS_ab = frac1D mathrmtr(œÑ_ab  œÑ_ba) = frac1D _c N^ab_c d_c fracŒ∏_cŒ∏_a Œ∏_b\n\nThe normalization constant is given by D = sqrtsum_a d_a^2, and thus truly requires a fusion category with a finite number of (isomorphism classes of) simple objects. For a modular fusion category, the symmetric matrix S is non-degenerate, and in fact (for a unitary fusion category) unitary. Note, however, that for a symmetric braiding S_ab = fracd_a d_bD and thus S is a rank 1 matrix. In particular, mathbfRep_mathsfG is never a modular category and the properties associated with this are not of (direct) importance for TensorKit.jl. We refer to the references for further information about modular categories.","category":"section"},{"location":"appendix/categories/#Bibliography","page":"Optional introduction to category theory","title":"Bibliography","text":"[Turaev]:   Turaev, V. G., & Virelizier, A. (2017). Monoidal categories and topological field theory (Vol. 322).  Birkh√§user.\n\n[Selinger]: Selinger, P. (2010). A survey of graphical languages for monoidal categories.  In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.  [https://arxiv.org/abs/0908.3347](https://arxiv.org/abs/0908.3347)\n\n[Kassel]:   Kassel, C. (2012). Quantum groups (Vol. 155).  Springer Science & Business Media.\n\n[Kitaev]:   Kitaev, A. (2006). Anyons in an exactly solved model and beyond.  Annals of Physics, 321(1), 2-111.\n\n[Beer]:     From categories to anyons: a travelogue Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf [https://arxiv.org/abs/1811.06670](https://arxiv.org/abs/1811.06670)","category":"section"},{"location":"appendix/symmetric_tutorial/#s_symmetric_tutorial","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"A symmetric tensor deep dive: constructing your first tensor map","text":"In this tutorial, we will demonstrate how to construct specific TensorMaps which are relevant to some common physical systems, with an increasing degree of complexity. We will assume the reader is somewhat familiar with the notion of a tensor map and has a rough idea of what it means for a tensor map to be symmetric. In going through these examples we aim to provide a relatively gentle introduction to the meaning of symmetry sectors and vector spaces within the context of TensorKit.jl, how to initialize a TensorMap over a given vector space and finally how to manually set the data of a symmetric TensorMap. We will keep our discussion as intuitive and simple as possible, only adding as many technical details as strictly necessary to understand each example. When considering a different physical system of interest, you should then be able to adapt these recipes and the intuition behind them to your specific problem at hand.\n\nnote: Note\nMany of these examples are readily implemented in the TensorKitTensors.jl package, in which case we basically provide a narrated walk-through of the corresponding code.","category":"section"},{"location":"appendix/symmetric_tutorial/#Contents-of-the-tutorial","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Contents of the tutorial","text":"Pages = [\"symmetric_tutorial.md\"]\nDepth = 2:3","category":"section"},{"location":"appendix/symmetric_tutorial/#Setup","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Setup","text":"using LinearAlgebra\nusing TensorKit\nusing WignerSymbols\nusing SUNRepresentations\nusing Test # for showcase testing","category":"section"},{"location":"appendix/symmetric_tutorial/#Level-0:-The-transverse-field-Ising-model","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Level 0: The transverse-field Ising model","text":"As the most basic example, we consider the 1-dimensional transverse-field Ising model, whose Hamiltonian is given by\n\nbeginequation\nlabeleqisingham\nH = -J left (sum_langle i j rangle Z_i Z_j + g sum_i X_iright)\nendequation\n\nHere, X_i and Z_i are the Pauli operators acting on site i, and the first sum runs over pairs of nearest neighbors langle i j rangle. This model has a global mathbbZ_2 symmetry, as it is invariant under the transformation U H U^dagger = H where the symmetry transformation U is given by a global spin flip,\n\nbeginequation\nlabeleqz2gen\nU = prod_i X_i\nendequation\n\nWe will circle back to the implications of this symmetry later.\n\nAs a warmup, we implement the Hamiltonian \\eqref{eq:isingham} in the standard way by encoding the matrix elements of the single-site operators X and Z into an array of complex numbers, and then combine them in a suitable way to get the Hamiltonian terms. Instead of using plain Julia arrays, we use a representation in terms of TensorMaps over complex vector spaces. These are essentially just wrappers around base arrays at this point, but their construction requires some consideration of the notion of spaces, which generalize the notion of size for arrays. Each of the operators X and Z acts on a local two-dimensional complex vector space. In the context of TensorKit.jl, such a space can be represented as ComplexSpace(2), or using the convenient shorthand ‚ÑÇ^2. A single-site Pauli operator maps from a domain physical space to a codomain physical space, and can therefore be represented as instances of a TensorMap(..., ‚ÑÇ^2 ‚Üê ‚ÑÇ^2). The corresponding data can then be filled in by hand according to the familiar Pauli matrices in the following way:\n\n# initialize numerical data for Pauli matrices\nx_mat = ComplexF64[0 1; 1 0]\nz_mat = ComplexF64[1 0; 0 -1]\n\n# construct physical Hilbert space\nV = ‚ÑÇ^2\n\n# construct the physical operators as TensorMaps\nX = TensorMap(x_mat, V ‚Üê V)\nZ = TensorMap(z_mat, V ‚Üê V)\n\n# combine single-site operators into two-site operator\nZZ = Z ‚äó Z\n\nWe can easily verify that our operators have the desired form by checking their data in the computational basis. We can print this data by calling the blocks method (we'll explain exactly what these blocks are further down):\n\nblocks(ZZ)\n\nblocks(X)","category":"section"},{"location":"appendix/symmetric_tutorial/#Level-1:-The-\\mathbb{Z}_2-symmetric-Ising-model","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Level 1: The mathbbZ_2-symmetric Ising model","text":"","category":"section"},{"location":"appendix/symmetric_tutorial/#The-irrep-basis-and-block-sparsity","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"The irrep basis and block sparsity","text":"Let us now return to the global mathbbZ_2 invariance of the Hamiltonian \\eqref{eq:isingham}, and consider what this implies for its local terms ZZ and X. Representing these operators as TensorMaps, the invariance of H under a global mathbbZ_2 transformation implies the following identities for the local tensors:\n\n<center><img src=\"../img/symmetric_tutorial/ZZX_symm.svg\" alt=\"ZZX_symm\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThese identitities precisely mean that these local tensors transform trivially under a tensor product representation of mathbbZ_2. This implies that, recalling the introduction on symmetries, in an appropriate basis for the local physical vector space, our local tensors would become block-diagonal where each so-called matrix block is labeled by a mathbbZ_2 irrep. The appropriate local basis transformation is precisely the one that brings the local representation X into block-diagonal form. Clearly, this transformation is nothing more than the Hadamard transformation which maps the computational basis of Z eigenstates ketuparrow ketdownarrow to that of the X eigenstates ket+ ket- defined as ket+ = fracketuparrow + ketdownarrowsqrt2 and ket- = fracketuparrow - ketdownarrowsqrt2. In the current context, this basis is referred to as the irrep basis of mathbbZ_2, since each basis state corresponds to a one-dimensional irreducible representation of mathbbZ_2. Indeed, the local symmetry transformation X acts trivially on the state ket+, corresponding to the trivial irrep, and yields a minus sign when acting on ket-, corresponding to the sign irrep.\n\nNext, let's make the statement that \"the matrix blocks of the local tensors are labeled by mathbbZ_2 irreps\" more concrete. To this end, consider the action of ZZ in the irrep basis, which is given by the four nonzero matrix elements\n\nbeginalign\nlabeleqzz_matel\nZZ  mathbb C^2 otimes mathbb C^2 to mathbb C^2 otimes mathbb C^2  \nket+ otimes ket+ mapsto ket- otimes ket- nonumber \nket+ otimes ket- mapsto ket- otimes ket+ nonumber \nket- otimes ket+ mapsto ket+ otimes ket- nonumber \nket- otimes ket- mapsto ket+ otimes ket+ nonumber \nendalign\n\nWe will denote the trivial mathbbZ_2 irrep by 0, corresponding to a local ket+ state, and the sign irrep by 1, corresponding to a local ket- state. Given this identification, we can naturally associate the tensor product of basis vectors in the irrep basis to the tensor product of the corresponding mathbbZ_2 irreps. One of the key questions of the representation theory of groups is how the tensor product of two irreps can be decomposed into a direct sum of irreps. This decomposition is encoded in what are often called the fusion rules,\n\na otimes b cong bigoplus_c N_c^ab c\n\nwhere N_ab^c encodes the number of times the irrep c occurs in the tensor product of irreps a and b. These fusion rules are called Abelian if the tensor product of any two irreps corresponds to exactly one irrep. We will return to the implications of irreps with non-Abelian fusion rules later.\n\nnote: Note\nWithin TensorKit.jl, the nature of the fusion rules for charges of a given symmetry are represented by the FusionStyle of the corresponding Sector subtype. What we refer to as \"Abelian\" fusion rules in this tutorial corresponds to UniqueFusion <: FusionStyle. We will also consider examples of two different kinds of non-Abelian\" fusion rules, corresponding to MultipleFusion <: FusionStyle styles.\n\nFor the case of the mathbbZ_2 irreps, the fusion rules are Abelian, and are given by addition modulo 2,\n\n0 otimes 0 cong 0 quad 0 otimes 1 cong 1 quad 1 otimes 0 cong 1 quad 1 otimes 1 cong 0\n\nTo see how these fusion rules arise, we can consider the action of the symmetry transformation XX on the possible two-site basis states, each of which corresponds to a tensor product of representations. We can see that XX acts trivially on both ket+ otimes ket+ and ket- otimes ket-, meaning these transform under the trivial representation, which gives the first and last entries of the fusion rules. Similarly, XX acts with a minus sign on both ket+ otimes ket- and ket- otimes ket+, meaning these transform under the sign representation, which gives the second and third entries of the fusion rules. Having introduced this notion of 'fusing' irreps, we can now associate a well-defined coupled irrep to each of the four two-site basis states, which is given by the tensor product of the two uncoupled irreps associated to each individual site. From the matrix elements of ZZ given above, we clearly see that this operator only maps between states in the domain and codomain that have the same coupled irrep. This means that we can associate each of these matrix elements to a so-called fusion tree of mathbbZ_2 irreps with a corresponding coefficient of 1,\n\n<center><img src=\"../img/symmetric_tutorial/Z2_fusiontrees.svg\" alt=\"Z2_fusiontrees\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThis diagram should be read from top to bottom, where it represents the fusion of the two uncoupled irreps in the domain to the coupled irrep on the middle line, and the splitting of this coupled irrep to the uncoupled irreps in the codomain. From this our previous statement becomes very clear: the ZZ operator indeed consists of two distinct two-dimensional matrix blocks, each of which are labeled by the value of the coupled irrep on the middle line of each fusion tree. The first block corresponds to the even coupled irrep '0', and acts within the two-dimensional subspace spanned by ket++ ket--, while the second block corresponds to the odd coupled irrep '1', and acts within the two-dimensional subspace spanned by ket+- ket-+. In TensorKit.jl, this block-diagonal structure of a symmetric tensor is explicitly encoded into its representation as a TensorMap, where only the matrix blocks corresponding to each coupled irrep are stored. These matrix blocks associated to each coupled irrep are precisely what is accessed by the blocks method we have already used above.\n\nFor our current purposes however, we never really need to explicitly consider these matrix blocks. Indeed, when constructing a TensorMap it is sufficient to set its data by manually assigning a matrix element to each fusion tree of the form above labeled by a given tensor product of irreps. This matrix element is then automatically inserted into the appropriate matrix block. So, for the purpose of this tutorial we will interpret a symmetric TensorMap simply as a list of fusion trees, to each of which corresponds a certain reduced tensor element. In TensorKit.jl, these reduced tensor elements corresponding to the fusion trees of a TensorMap can be accessed through the subblocks method.\n\nnote: Note\nIn general, such a reduced tensor element is not necessarily a scalar, but rather an array whose size is determined by the degeneracy of the irreps in the codomain and domain of the fusion tree. For this reason, a reduced tensor element associated to a given fusion tree is also referred to as a subblock. In the following we will always use terms reduced tensor element or subblock for the reduced tensor elements, to make it clear that these are distinct from the matrix blocks in the block-diagonal decomposition of the tensor.","category":"section"},{"location":"appendix/symmetric_tutorial/#sss_fusion_trees","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Fusion trees and how to use them","text":"This view of the underlying symmetry structure in terms of fusion trees of irreps and corresponding reduced tensor elements is a very convenient way of working with the TensorMap type. In fact, this symmetry structure is inherently ingrained in a TensorMap, and goes beyond the group-like symmetries we have considered until now. In this more general setting, we will refer to the labels that appear on this fusion trees as charges or sectors. These can be thought of as generalization of group irreps, and appear in the context of TensorKit.jl as instances of the Sector type.\n\nConsider a generic fusion tree of the form\n\n<center><img src=\"../img/symmetric_tutorial/fusiontree.svg\" alt=\"fusiontree\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nwhich can be used to label a subblock of a TensorMap corresponding to a two-site operator. This object should actually be seen as a pair of fusion trees. The first member of the pair, related to the codomain of the TensorMap, is referred to as the splitting tree and encodes how the coupled charge c splits into the uncoupled charges s_1 and s_2. The second member of the pair, related to the domain of the TensorMap, is referred to as the fusion tree and encodes how the uncoupled charges f_1 and f_2 fuse to the coupled charge c. Both the splitting and fusion tree can be represented as a FusionTree instance. You will find such a FusionTree has the following properties encoded into its fields:\n\nuncoupled::NTuple{N,I}: a list of N uncoupled charges of type I<:Sector\ncoupled::I: a single coupled charge of type I<:Sector\nisdual::NTuple{N,Bool}: a list of booleans indicating whether the corresponding uncoupled charge is dual\ninnerlines::NTuple{M,I}: a list of inner lines of type I<:Sector of length M = N - 2\nvertices::NTuple{L,T}: list of fusion vertex labels of type T and length L = N - 1\n\nFor our current application only uncoupled and coupled are relevant, since mathbbZ_2 irreps are self-dual and have Abelian fusion rules, so that irreps on the inner lines of a fusion tree are completely determined by the uncoupled irreps. We will come back to these other properties when discussion more involved applications. Given some TensorMap, the method fusiontrees returns an iterator over all pairs of splitting and fusion trees that label the subblocks of t.","category":"section"},{"location":"appendix/symmetric_tutorial/#Constructing-a-\\mathbb{Z}_2-symmetric-TensorMap","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Constructing a mathbbZ_2-symmetric TensorMap","text":"We can now put this into practice by directly constructing the ZZ operator in the irrep basis as a mathbbZ_2-symmetric TensorMap. We will do this in three steps:\n\nFirst we construct the physical space at each site as a mathbbZ_2-graded vector space.\nThen we initialize an empty TensorMap with the correct domain and codomain vector spaces built from the previously constructed physical space.\nAnd finally we iterate over all splitting and fusion tree pairs and manually fill in the corresponding nonzero subblocks of the operator.\n\nIn TensorKit.jl, the representations of mathbbZ_2 are represented as instances of the Z2Irrep <: Sector type. There are two such instances, corresponding to the trivial irrep Z2Irrep(0) and the sign irrep Z2Irrep(1). We can fuse irreps with the ‚äó (\\otimes) operator, which can for example be used to check their fusion rules,\n\nfor a in values(Z2Irrep), b in values(Z2Irrep)\n    println(\"$a ‚äó $b = $(a ‚äó b)\")\nend\n\nAfter the basis transform to the irrep basis, we can view the two-dimensional complex physical vector space we started with as being spanned by the trivial and sign irrep of mathbbZ_2. In the language of TensorKit.jl, this can be implemented as a Z2Space, an alias for a graded vector space Vect[Z2Irrep]. Such a graded vector space V is a direct sum of irreducible representation spaces V^(a) labeled by the irreps a of the group,\n\nV = bigotimes_a N_a  cdot V^(a)\n\nThe number of times N_a each irrep a appears in the direct sum is called the degeneracy of the irrep. To construct such a graded space, we therefore have to specify which irreps it contains, and indicate the degeneracy of each irrep. Here, our physical vector space contains the trivial irrep Z2Irrep(0) with degeneracy 1 and the sign irrep Z2Irrep(1) with degeneracy 1. This means this particular graded space has the form\n\nV = 1 cdot V^(0) oplus 1 cdot V^(1)\n\nwhich can be constructed in the following way,\n\nV = Z2Space(0 => 1, 1 => 1)\n\nAs a consistency check, we can inspect its dimension as well as the degeneracies of the individual irreps:\n\ndim(V)\n\ndim(V, Z2Irrep(0))\n\ndim(V, Z2Irrep(1))\n\nGiven this physical space, we can initialize the ZZ operator as an empty TensorMap with the appropriate structure.\n\nZZ = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\n\nTo assess the underlying structure of a symmetric tensor, it is often useful to inspect its subblocks,\n\nsubblocks(ZZ)\n\nWhile all entries are zero, we see that all eight valid fusion trees with two incoming irreps and two outgoing irreps of the type above are listed with their corresponding subblock data. Each of these subblocks is an array of shape (1 1 1 1) since each irrep occuring in the space V has degeneracy 1. Using the fusiontrees method and the fact that we can index a TensorMap using a splitting/fusion tree pair, we can now fill in the nonzero subblocks of the operator by observing that the ZZ operator flips the irreps of the uncoupled charges in the domain with respect to the codomain, as shown in the diagrams above. Flipping a given Z2Irrep in the codomain can be implemented by fusing them with the sign irrep Z2Irrep(1), giving:\n\nflip_charge(charge::Z2Irrep) = only(charge ‚äó Z2Irrep(1))\nfor (s, f) in fusiontrees(ZZ)\n    if s.uncoupled == map(flip_charge, f.uncoupled)\n        ZZ[s, f] .= 1\n    end\nend\nsubblocks(ZZ)\n\nIndeed, the resulting TensorMap exactly encodes the matrix elements of the ZZ operator shown in the diagrams above. The X operator can be constructed in a similar way. Since it is by definition diagonal in the irrep basis with matrix blocks directly corresponding to the trivial and sign irrep, its construction is particularly simple:\n\nX = zeros(ComplexF64, V ‚Üê V)\nfor (s, f) in fusiontrees(X)\n    if only(f.uncoupled) == Z2Irrep(0)\n        X[s, f] .= 1\n    else\n        X[s, f] .= -1\n    end\nend\nsubblocks(X)\n\nGiven these local operators, we can use them to construct the full manifestly mathbbZ_2-symmetric Hamiltonian.\n\nnote: Note\nAn important observation is that, when explicitly imposing the mathbbZ_2 symmetry, we directly constructed the full ZZ operator as a single symmetric tensor. This in contrast to the case without symmetries, where we constructed a single-site Z operator and then combined them into a two-site operator. Clearly this can no longer be done when imposing mathbbZ_2, since a single Z is not invariant under conjugation with the symmetry operator X. One might wonder whether it is still possible to construct a two-site Hamiltonian term by combining local objects. This is possible if one introduces an auxiliary index on the local tensors that carries a non-trivial charge. The intuition behind this will become more clear in the next example.","category":"section"},{"location":"appendix/symmetric_tutorial/#Level-2:-The-\\mathsf{U}_1-Bose-Hubbard-model","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Level 2: The mathsfU_1 Bose-Hubbard model","text":"For our next example, we consider the Bose-Hubbard model, which describes interacting bosons on a lattice. The Hamiltonian of this model is given by\n\nbeginequation\nlabeleqbhh\nH = -t sum_langle ij rangle left( a_i^+ a_j^- + a_i^- a_j^+ right) - mu sum_i N_i + fracU2 sum_i N_i(N_i - 1)\nendequation\n\nThis Hamiltonian is defined on the Fock space associated to a chain of bosons, where the action bosonic creation, annihilation and number operators a^+, a^- and N = a^+ a^- in the local occupation number basis is given by\n\nbeginalign\nlabeleqbosonopmatel\na^+ ketn = sqrtn + 1 ketn + 1 \na^- ketn = sqrtn ketn - 1 nonumber \nN ketn = n ketn nonumber\nendalign\n\nTheir bosonic nature can be summarized by the familiar the commutation relations\n\nbeginalign*\nlefta_i^- a_j^-right = lefta_i^+ a_j^+right = 0 \nlefta_i^- a_j^+right = delta_ij \nleftN a^+right = a^+ \nleftN a^-right = -a^- \nendalign*\n\nThis Hamiltonian is invariant under conjugation by the global particle number operator, U H U^dagger = H, where\n\nU = sum_i N_i\n\nThis invariance corresponds to a mathsfU_1 particle number symmetry, which can again be manifestly imposed when constructing the Hamiltonian terms as TensorMaps. From the representation theory of mathsfU_1, we know that its irreps are all one-dimensional and can be labeled by integers n where the tensor product of two irreps is corresponds to addition of these labels, giving the Abelian fusion rules\n\nn_1 otimes n_2 cong (n_1 + n_2)","category":"section"},{"location":"appendix/symmetric_tutorial/#Directly-constructing-the-Hamiltonian-terms","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Directly constructing the Hamiltonian terms","text":"We recall from our discussion on the mathbbZ_2 symmetric Ising model that, in order to construct the Hamiltonian terms as symmetric tensors, we should work in the irrep basis where the symmetry transformation is block diagonal. In the current case, the symmetry operation is the particle number operator, which is already diagonal in the occupation number basis. Therefore, we don't need an additional local basis transformation this time, and can just observe that each local basis state can be identified with the mathsfU_1 irrep associated to the corresponding occupation number.\n\nFollowing the same approach as before, we first write down the action of the Hamiltonian terms in the irrep basis:\n\nbeginalign*\na_i^+ a_j^- ketn_i n_j = sqrt(n_i + 1)n_j ketn_i + 1 n_j - 1 \na_i^- a_j^+ ketn_i n_j = sqrtn_i(n_j + 1) ketn_i - 1 n_j + 1 \nN ketn = n ketn\nendalign*\n\nIt is then a simple observation that these matrix elements are exactly captured by the following mathsfU_1 fusion trees with corresponding subblock values:\n\n<center><img src=\"../img/symmetric_tutorial/U1_fusiontrees.svg\" alt=\"U1_fusiontrees\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThis gives us all the information necessary to construct the corresponding TensorMaps. We follow the same steps as outlined in the previous example, starting with the construction of the physical space. This will now be a mathsfU_1 graded vector space U1Space, where each basis state ketn in the occupation number basis is represented by the corresponding mathsfU_1 irrep U1Irrep(n) with degeneracy 1. While this physical space is in principle infinite dimensional, we will impose a cutoff in occupation number at a maximum of 5 bosons per site, giving a 6-dimensional vector space:\n\ncutoff = 5\nV = U1Space(n => 1 for n in 0:cutoff)\n\nWe can now initialize the a^+ a^-, a^- a^+ and N operators as empty TensorMaps with the correct domain and codomain vector spaces, and fill in the nonzero subblocks associated to the fusion trees shown above. To do this we need access to the integer label of the mathsfU_1 irreps in the fusion and splitting trees, which can be accessed through the charge field of the U1Irrep type.\n\na‚Å∫a‚Åª = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(a‚Å∫a‚Åª)\n    if s.uncoupled[1] == only(f.uncoupled[1] ‚äó U1Irrep(1)) && s.uncoupled[2] == only(f.uncoupled[2] ‚äó U1Irrep(-1))\n        a‚Å∫a‚Åª[s, f] .= sqrt(s.uncoupled[1].charge * f.uncoupled[2].charge)\n    end\nend\na‚Å∫a‚Åª\n\na‚Åªa‚Å∫ = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(a‚Åªa‚Å∫)\n    if s.uncoupled[1] == only(f.uncoupled[1] ‚äó U1Irrep(-1)) && s.uncoupled[2] == only(f.uncoupled[2] ‚äó U1Irrep(1))\n        a‚Åªa‚Å∫[s, f] .= sqrt(f.uncoupled[1].charge * s.uncoupled[2].charge)\n    end\nend\na‚Åªa‚Å∫\n\nN = zeros(ComplexF64, V ‚Üê V)\nfor (s, f) in fusiontrees(N)\n    N[s, f] .= f.uncoupled[1].charge\nend\nN\n\nBy inspecting the subblocks of each of these tensors you can directly verify that they each have the correct reduced tensor elements.","category":"section"},{"location":"appendix/symmetric_tutorial/#Creation-and-annihilation-operators-as-symmetric-tensors","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Creation and annihilation operators as symmetric tensors","text":"Just as in the mathbbZ_2 case, it is obvious that we cannot directly construct the creation and annihilation operators as instances of a TensorMap(..., V ‚Üê V) since they are not invariant under conjugation by the symmetry operator. However, it is possible to construct them as TensorMaps using an auxiliary vector space, based on the following intuition. The creation operator a^+ violates particle number conservation by mapping the occupation number n to n + 1. From the point of view of representation theory, this process can be thought of as the fusion of an U1Irrep(n) with an U1Irrep(1), naturally giving the fusion product U1Irrep(n + 1). This means we can represent a^+ as a TensorMap(..., V ‚Üê V ‚äó A), where the auxiliary vector space A contains the +1 irrep with degeneracy 1, A = U1Space(1 => 1). Similarly, the decrease in occupation number when acting with a^- can be thought of as the splitting of an U1Irrep(n) into an U1Irrep(n - 1) and an U1Irrep(1), leading to a representation in terms of a TensorMap(. ., A ‚äó V ‚Üê V). Based on these observations, we can represent the matrix elements \\eqref{eq:bosonopmatel} as subblocks labeled by the mathsfU_1 fusion trees\n\n<center><img src=\"../img/symmetric_tutorial/bosonops.svg\" alt=\"bosonops\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nWe can then combine these operators to get the appropriate Hamiltonian terms,\n\n<center><img src=\"../img/symmetric_tutorial/bosonham.svg\" alt=\"bosonham\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nnote: Note\nAlthough we have made a suggestive distinction between the 'left' and 'right' versions of the operators a_L^pm and a_R^pm, one can actually be obtained from the other by permuting the physical and auxiliary indices of the corresponding TensorMaps. This permutation has no effect on the actual subblocks of the tensors due to the Abelian FusionStyle and bosonic BraidingStyle of mathsfU_1 irreps, so the left and right operators can in essence be seen as the 'same' tensors. This is no longer the case when considering non-Abelian symmetries, or symmetries associated with fermions or anyons. For these cases, permuting indices can in fact change the subblocks, as we will see next. As a consequence, it is much less clear how to construct two-site symmetric operators in terms of local symmetric objects.\n\nThe explicit construction then looks something like\n\nA = U1Space(1 => 1)\n\na‚Å∫ = zeros(ComplexF64, V ‚Üê V ‚äó A)\nfor (s, f) in fusiontrees(a‚Å∫)\n    a‚Å∫[s, f] .= sqrt(f.uncoupled[1].charge+1)\nend\na‚Å∫\n\na‚Åª = zeros(ComplexF64, A ‚äó V ‚Üê V)\nfor (s, f) in fusiontrees(a‚Åª)\n    a‚Åª[s, f] .= sqrt(f.uncoupled[1].charge)\nend\na‚Åª\n\nIt is then simple to check that this is indeed what we expect.\n\n@tensor a‚Å∫a‚Åª_bis[-1 -2; -3 -4] := a‚Å∫[-1; -3 1] * a‚Åª[1 -2; -4]\n@tensor a‚Åªa‚Å∫_bis[-1 -2; -3 -4] := a‚Åª[1 -1; -3] * a‚Å∫[-2; -4 1]\n@tensor N_bis[-1 ; -2] := a‚Å∫[-1; 1 2] * a‚Åª[2 1; -2]\n\n@test a‚Å∫a‚Åª_bis ‚âà a‚Å∫a‚Åª atol=1e-14\n@test a‚Åªa‚Å∫_bis ‚âà a‚Åªa‚Å∫ atol=1e-14\n@test N_bis ‚âà N atol=1e-14\n\nnote: Note\nFrom the construction of the Hamiltonian operators in terms of creation and annihilation operators we clearly see that they are invariant under a transformation a^pm to e^pm itheta a^pm. More generally, for a two-site operator that is defined as the contraction of two one-site operators across an auxiliary space, modifying the one-site operators by applying transformations Q and Q^-1 on their respective auxiliary spaces for any invertible Q leaves the resulting contraction unchanged. This ambiguity in the definition clearly shows that one should really always think in terms of the fully symmetric procucts of a^+ and a^- rather than in terms of these operators themselves. In particular, one can always decompose such a symmetric product into the form above by means of an SVD.","category":"section"},{"location":"appendix/symmetric_tutorial/#Level-3:-Fermions-and-the-Kitaev-model","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Level 3: Fermions and the Kitaev model","text":"While we have already covered quite a lot of ground towards understanding symmetric tensors in terms of fusion trees and corresponding subblocks, the symmetries considered so far have been quite 'simple' in the sense that sectors corresponding to irreps of mathbbZ_2 and mathsfU_1 have Abelian fusion rules and bosonic exchange statistics. This means that the fusion of two irreps always gives a unique irrep as the fusion product, and that exchanging two irreps in a tensor product is trivial. In practice, this implies that for tensors with these symmetries the fusion trees are completely fixed by the uncoupled charges, which uniquely define both the inner lines and the coupled charge, and that tensor indices can be permuted freely without any strange side effects.\n\nIn the following we will consider examples with fermionic and even anyonic exchange statistics, and non-Abelian fusion rules. In going through these examples it will become clear that the fusion trees labeling the subblocks of a symmetric tensor imply more information than just a labeling.","category":"section"},{"location":"appendix/symmetric_tutorial/#Fermion-parity-symmetry","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Fermion parity symmetry","text":"As a simple example we will consider the Kitaev chain, which describes a chain of interacting spinless fermions with nearest-neighbor hopping and pairing terms. The Hamiltonian of this model is given by\n\nbeginequation\nlabeleqkitaev\nH = sum_langle ij rangle left(-fract2(c_i^+ c_j^- - c_i^- c_j^+) + fracDelta2(c_i^+ c_j^+ - c_i^- c_j^-) right) - mu sum_i N_i\nendequation\n\nwhere N_i = c_i^+ c_i^- is the local particle number operator. As opposed to the previous case, the fermionic creation and annihilation operators now satisfy the anticommutation relations\n\nbeginalign*\nleftc_i^- c_j^-right = leftc_i^+ c_j^+right = 0 \nleftc_i^- c_j^+right = delta_ij \nendalign*\n\nThese relations justify the choice of the relative minus sign in the hopping and pairing terms. Indeed, since fermionic operators on different sites always anticommute, these relative minus signs are needed to ensure that the Hamiltonian is Hermitian, since left( c_i^+ c_j^- right)^dagger = c_j^+ c_i^- = - c_i^- c_j^+ and left( c_i^+ c_j^+ right)^dagger = c_j^- c_i^- = - c_i^- c_j^-. The anticommutation relations also naturally restrict the local occupation number to be 0 or 1, leading to a well-defined notion of fermion-parity. The local fermion-parity operator is related to the fermion number operator as Q_i = (-1)^N_i, and is diagonal in the occupation number basis. The Hamiltonian \\eqref{eq:kitaev} is invariant under conjugation by the global fermion-parity operator, Q H Q^dagger = H, where\n\nQ = exp left( i pi sum_i N_i right) = (-1)^sum_i N_i\n\nThis fermion parity symmetry, which we will denote as fmathbbZ_2, is a mathbbZ_2-like symmetry in the sense that it has a trivial representation, which we call even and again denote by '0', and a sign representation which we call odd and denote by '1'. The fusion rules of these irreps are the same as for mathbbZ_2. Similar to the previous case, the local symmetry operator Q_i is already diagonal, so the occupation number basis coincides with the irrep basis and we don't need an additional basis transform. The important difference with a regular mathbbZ_2 symmetry is that the irreps of fmathbbZ_2 have fermionic braiding statistics, in the sense that exchanging two odd irreps gives rise to a minus sign.\n\nIn TensorKit.jl, an fmathbbZ_2-graded vector spaces is represented as a Vect[FermionParity] space, where a given fmathbbZ_2 irrep can be represented as a FermionParity sector instance. Using the simplest instance of a vector space containing a single even and odd irrep, we can already demonstrate the corresponding fermionic braiding behavior by performing a permutation on a simple TensorMap.\n\nV = Vect[FermionParity](0 => 1, 1 => 1)\nt = ones(ComplexF64, V ‚Üê V ‚äó V)\nsubblocks(t)\n\ntp = permute(t, ((1,), (3, 2)))\nsubblocks(tp)\n\nIn other words, when exchanging the two domain vector spaces, the reduced tensor elements of the TensorMap for which both uncoupled irreps in the domain of the corresponding fusion tree are odd picks up a minus sign, exactly as we would expect for fermionic charges.","category":"section"},{"location":"appendix/symmetric_tutorial/#Constructing-the-Hamiltonian","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Constructing the Hamiltonian","text":"We can directly construct the Hamiltonian terms as symmetric TensorMaps using the same procedure as before starting from their matrix elements in the occupation number basis. However, in this case we should be a bit more careful about the precise definition of the basis states in composite systems. Indeed, the tensor product structure of fermionic systems is inherently tricky to deal with, and should ideally be treated in the context of super vector spaces. For two sites, we can define the following basis states on top of the fermionic vacuuum ket00:\n\nbeginalign*\nket01 = c_2^+ ket00 \nket10 = c_1^+ ket00 \nket11 = c_1^+ c_2^+ ket00 \nendalign*\n\nThis definition in combination with the anticommutation relations above give rise to the nonzero matrix elements\n\nbeginalign*\nc_1^+ c_2^- ket0 1 = ket1 0 \nc_1^- c_2^+ ket1 0 = - ket0 1 \nc_1^+ c_2^+ ket0 0 = ket1 1 \nc_1^- c_2^- ket1 1 = - ket0 0 \nN ketn = n ketn\nendalign*\n\nWhile the signs in these expressions may seem a little unintuitive at first sight, they are essential to the fermionic nature of the system. Indeed, if we for example work out the matrix element of c_1^- c_2^+ we find\n\nbeginalign*\nc_1^- c_2^+ ket1 0 = c_1^- c_2^+ c_1^+ ket0 0 = - c_2^+ c_1^- c_1^+ ket0 0 = - c_2^+ (mathbb1 - c_1^+ c_1^-) ket0 0 = - c_2^+ ket0 0 = - ket0 1 \nendalign*\n\nOnce we have these matrix elements the hard part is done, and we can straightforwardly associate these to the following fmathbbZ_2 fusion trees with corresponding reduced tensor elements,\n\n<center><img src=\"../img/symmetric_tutorial/fZ2_fusiontrees.svg\" alt=\"fZ2_fusiontrees\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nGiven this information, we can go through the same procedure again to construct c^+ c^-, c^- c^+ and N operators as TensorMaps over fmathbbZ_2-graded vector spaces.\n\nV = Vect[FermionParity](0 => 1, 1 => 1)\n\nc‚Å∫c‚Åª = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nodd = FermionParity(1)\nfor (s, f) in fusiontrees(c‚Å∫c‚Åª)\n    if s.uncoupled[1] == odd && f.uncoupled[2] == odd && f.coupled == odd\n        c‚Å∫c‚Åª[s, f] .= 1\n    end\nend\nsubblocks(c‚Å∫c‚Åª)\n\nc‚Åªc‚Å∫ = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(c‚Åªc‚Å∫)\n    if f.uncoupled[1] == odd && s.uncoupled[2] == odd && f.coupled == odd\n        c‚Åªc‚Å∫[s, f] .= -1\n    end\nend\nsubblocks(c‚Åªc‚Å∫)\n\nc‚Å∫c‚Å∫ = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nodd = FermionParity(1)\nfor (s, f) in fusiontrees(c‚Å∫c‚Å∫)\n    if s.uncoupled[1] == odd && f.uncoupled[1] != odd && f.coupled != odd\n        c‚Å∫c‚Å∫[s, f] .= 1\n    end\nend\nsubblocks(c‚Å∫c‚Å∫)\n\nc‚Åªc‚Åª = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(c‚Åªc‚Åª)\n    if s.uncoupled[1] != odd && f.uncoupled[2] == odd && f.coupled != odd\n        c‚Åªc‚Åª[s, f] .= -1\n    end\nend\nsubblocks(c‚Åªc‚Åª)\n\nN = zeros(ComplexF64, V ‚Üê V)\nfor (s, f) in fusiontrees(N)\n    N[s, f] .= f.coupled == odd ? 1 : 0\nend\nsubblocks(N)\n\nWe can easily all the reduced tensor elements are indeed correct.\n\nnote: Note\nWorking with fermionic systems is inherently tricky, as can already be seen from something as simple as computing matrix elements of fermionic operators. Similarly, while constructing symmetric tensors that correspond to the symmetric Hamiltonian terms was still quite straightforward, it is far less clear in this case how to construct these terms as contractions of local symmetric tensors representing individual creation and annihilation operators. While such a decomposition can always be in principle obtained using a (now explicitly fermionic) SVD, manually constructing such tensors as we did in the bosonic case is far from trivial. Trying this would be a good exercise in working with fermionic symmetries, but it is not something we will do here.","category":"section"},{"location":"appendix/symmetric_tutorial/#ss_non_abelian","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Level 4: Non-Abelian symmetries and the quantum Heisenberg model","text":"We will now move on to systems which have more complicated non-Abelian symmetries. For a non-Abelian symmetry group G, the fact that its elements do not all commute has a profound impact on its representation theory. In particular, the irreps of such a group can be higher dimensional, and the fusion of two irreps can give rise to multiple different irreps. On the one hand, this means that fusion trees of these irreps are no longer completely determined by the uncoupled charges. Indeed, in this case some of the internal structure of the FusionTree type we have ignored before will become relevant (of which we will give an example below). On the other hand, it follows that fusion trees of irreps now not only label reduced tensor elements, but also encode a certain nontrivial symmetry structure. We will make this statement more precise in the following, but the fact that this is necessary is quite intuitive. If we recall our original statement that symmetric tensors consist of subblocks associated to fusion trees which carry irrep labels, then for higher-dimensional irreps the corresponding fusion trees must encode some additional information that implicitly takes into account the internal structure of the representation spaces. In particular, this means that the conversion of an operator, given its matrix elements in the irrep basis, to the subblocks of the corresponding symmetric TensorMap is less straightforward since it requires an understanding of exactly what this implied internal structure is. Therefore, we require some more discussion before we can actually move on to an example.\n\nWe'll start by discussing the general structure of a TensorMap which is symmetric under a non-Abelian group symmetry. We then given an example based on mathsfSU_2, where we construct the Heisenberg Hamiltonian using two different approaches. Finally, we show how the more intuitive approach can be used to obtain an elegant generalization to the mathsfSU_N-symmetric case.","category":"section"},{"location":"appendix/symmetric_tutorial/#Block-sparsity-revisited:-the-Wigner-Eckart-theorem","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Block sparsity revisited: the Wigner-Eckart theorem","text":"Let us recall some basics of representation theory first. Consider a group G and a corresponding representation space V, such that every element g in G can be realized as a unitary operator U_g  V to V. Let h be a TensorMap whose domain and codomain are given by the tensor product of two of these representation spaces. By definition, the statement that 'h is symmetric under G' means that\n\n<center><img src=\"../img/symmetric_tutorial/symmetric_tensor.svg\" alt=\"symmetric_tensor\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nfor every g in G. If we label the irreducible representations of G by l, then any representation space can be decomposed into a direct sum of irreducible representations, V = bigoplus_l V^(l), in such a way that U_g is block-diagonal where each matrix block is labeled by a particular irrep l. For each irrep space V^(l) we can define an orthonormal basis labeled as ketl m, where the auxiliary label m can take textdimleft( V^(l) right) different values. Since we know that tensors are multilinear maps over tensor product spaces, it is natural to consider the tensor product of representation spaces in more detail.\n\nFrom the representation theory of groups, it is known that the product of two irreps can in turn be decomposed into a direct sum of irreps, V^(l_1) otimes V^(l_2) cong bigoplus_k V^(k). The precise nature of this decomposition, also refered to as the Clebsch-Gordan problem, is given by the so-called Clebsch-Gordan coefficients, which we will denote as C^k_l_1l_2. This set of coefficients, which can be interpreted as a textdimleft( V^(l_1) right) times textdimleft( V^(l_2) right) times textdimleft( V^(k) right) array, encodes how a basis state ketkn in V^(k) corresponding to some term in the direct sum can be decomposed into a linear combination of basis vectors ketl_1m_1 otimes ketl_2m_2 of the tensor product space:\n\nbeginequation\nlabeleqcg_decomposition\nketkn = sum_m_1 m_2 left( C^k_l_1l_2 right)^n_m_1 m_2 ketl_1m_1 otimes ketl_2m_2\nendequation\n\nThese recoupling coefficients turn out to be essential to the structure of symmetric tensors, which can be best understood in the context of the Wigner-Eckart theorem. This theorem implies that for any TensorMap h that is symmetric under G, its matrix elements in the tensor product irrep basis are given by the product of Clebsch-Gordan coefficients which characterize the coupling of the basis states in the domain and codomain, and a so-called reduced tensor element which only depends on the irrep labels. Concretely, the matrix element bral_1m_1 otimes bral_2m_2 h ketl_3m_3 otimes ketl_4m_4 is given by\n\n<center><img src=\"../img/symmetric_tutorial/wignereckart.svg\" alt=\"wignereckart\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nHere, the sum runs over all possible irreps k in the fusion product l_3 otimes l_4 and over all basis states ketkn of V^(k). The reduced tensor elements h_textred are independent of the basis state labels and only depend on the irrep labels themselves. Each reduced tensor element should be interpreted as being labeled by an irrep fusion tree,\n\n<center><img src=\"../img/symmetric_tutorial/anotherfusiontree.svg\" alt=\"anotherfusiontree\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThe fusion tree itself in turn implies the Clebsch-Gordan coefficients C^k_l_1l_2 and conjugate coefficients C^dagger_k^l_1l_2 encode the splitting (decomposition) of the coupled basis state ketkn to the codomain basis states ketl_1m_1 otimes ketl_2m_2 and the coupling of the domain basis states ketl_3m_3 otimes ketl_4m_4 to the coupled basis state ketkn respectively.\n\nThe Wigner-Eckart theorem dictates that this structure in terms of Clebsch-Gordan coefficients is necessary to ensure that the corresponding tensor is symmetric. It is precisely this structure that is inherently encoded into the fusion tree part of a symmetric TensorMap. In particular, the subblock value associated to each fusion tree in a symmetric tensor is precisely the reduced tensor element in the Clebsch-Gordan decomposition.\n\nnote: Note\nIn the Clebsch-Gordan decomposition given above, our notation has actually silently assumed that each irrep k only occurs once in the fusion product of the uncoupled irreps l_1 and l_2. However, there exist symmetries which have fusion multiplicities, where two irreps can fuse to a given coupled irrep in multiple distinct ways. In TensorKit.jl, these correspond to Sector types with a GenericFusion <: FusionStyle fusion style. In the presence of fusion multiplicities, the Clebsch-Gordan coefficients actually have an additional index which labels the particular fusion channel according to which l_1 and l_2 fuse to k. Since the fusion of mathsfSU_2 irreps is multiplicity-free, we could safely ignore this nuance here. We will encounter the implication of fusion multiplicities shortly, and will consider an example of a symmetry which has these multiplicities below.\n\nAs a small demonstration of this fact, we can make a simple mathsfSU_2-symmetric tensor with trivial subblock values and verify that its implied symmetry structure exactly corresponds to the expected Clebsch-Gordan coefficient. First, we recall that the irreps of mathsfSU_2 can be labeled by a halfinteger spin that takes values l = 0 frac12 1 frac32 , and where the dimension of the spin-l representation is equal to 2l + 1. The fusion rules of mathsfSU_2 are given by\n\nbeginequation\nlabeleqsu2_fusion_rules\nl_1 otimes l_2 cong bigoplus_k=l_1-l_2^l_1+l_2k\nendequation\n\nThese are clearly non-Abelian since multiple terms appear on the right hand side, for example frac12 otimes frac12 cong 0 oplus 1. In TensorKit.jl, a mathsfSU_2-graded vector space is represented as an SU2Space, where a given mathsfSU_2 irrep can be represented as an SU2Irrep instance of integer or halfinteger spin as encoded in its j field. If we construct a TensorMap whose symmetry structure corresponds to the coupling of two spin-frac12 irreps to a spin-1 irrep in the sense of \\eqref{eq:cgdecomposition}, we can then convert it to a plain array and compare it to the ``\\mathsf{SU}2`` Clebsch-Gordan coefficients implemented in the WignerSymbols.jl package.\n\nV1 = SU2Space(1//2 => 1)\nV2 = SU2Space(1 => 1)\nt = ones(ComplexF64, V1 ‚äó V1 ‚Üê V2)\n\nta = convert(Array, t)\n\nThe conversion gives us a 2 times 2 times 3 array, which exactly corresponds to the size of the C^1_frac12frac12 Clebsch-Gordan array. In order to explicitly compare whether the entries match we need to know the ordering of basis states assumed by TensorKit.jl when converting the tensor to its matrix elements in the irrep basis. For mathsfSU_2 the irrep basis is ordered in ascending magnetic quantum number m, which gives us a map m = i - (l+1) for mapping an array index to a corresponding magnetic quantum number for the spin-l irrep.\n\nchecks = map(Iterators.product(1:dim(V1), 1:dim(V1), 1:dim(V2))) do (i1, i2, i3)\n    # map basis state index to magnetic quantum number\n    m1 = i1 - (1//2 + 1)\n    m2 = i2 - (1//2 + 1)\n    m3 = i3 - (1 + 1)\n    # check the corresponding array entry\n    return ta[i1, i2, i3] ‚âà clebschgordan(1//2, m1, 1//2, m2, 1, m3)\nend\n@test all(checks)\n\nBased on this discussion, we can quantify the aforementioned 'difficulties' in the inverse operation of what we just demonstrated, namely converting a given operator to a symmetric TensorMap given only its matrix elements in the irrep basis. Indeed, it is now clear that this precisely requires isolating the reduced tensor elements introduced above. Given the matrix elements of the operator in the irrep basis, this can in general be done by solving the system of equations implied by the Clebsch-Gordan decomposition. A simpler way to achieve the same thing is to make use of the fact that the Clebsch-Gordan tensors form a complete orthonormal basis on the coupled space. Indeed, by projecting out the appropriate Clebsch-Gordan coefficients and using their orthogonality relations, we can construct a diagonal operator on each coupled irrep space V^(k). Each of these diagonal operators is proportional to the identity, where the proportionality factor is precisely the reduced tensor element associated to the corresponding irrep fusion tree.\n\n<center><img src=\"../img/symmetric_tutorial/none2symm.svg\" alt=\"none2symm\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThis procedure works for any group symmetry, and all we need are matrix elements of the operator in the irrep basis and the Clebsch-Gordan coefficients. In the following, we demonstrate this explicit procedure for the particular example of G = mathsfSU_2. However, it should be noted that, for other non-Abelian groups, the Clebsch-Gordan coefficients may not be as easy to compute (generically, no closed formulas exist). In addition, the procedure for manually projecting out the reduced tensor elements requires being particularly careful about the correspondence between the basis states used to define the original matrix elements and those implied by the Clebsch-Gordan coefficients. Finally, for some symmetries supported in TensorKit. l, there are simply no Clebsch-Gordan coefficients. Therefore, it is often easier and sometimes simply necessary to directly construct the symmetric tensor and then fill in its reduced tensor elements based on some representation theory. We will cover some examples of this below.\n\nHaving introduced and demonstrated the Clebsch-Gordan decomposition, the corresponding coefficients and their role in symmetric tensors for the example of mathsfSU_2 using the WignerSymbols.jl package, we now continue our discussion using only TensorKit.jl internals. Within TensorKit.jl, the textdimleft( V^(l_1) right) times textdimleft( V^(l_2) right) times textdimleft( V^(k) right) array of coefficients that encodes the splitting of the irrep space V^(k) to the tensor product of irrep spaces V^(l_1) otimes V^(l_2) according to the Clebsch-Gordan decomposition \\eqref{eq:cg_decomposition} above can be explicitly constructed by calling the TensorKitSectors.fusiontensor method on the corresponding Sector instances, fusiontensor(l‚ÇÅ, l‚ÇÇ, k). This fusiontensor is defined for any sector type corresponding to a symmetry which admits Clebsch-Gordan coefficients. For our example above, we can build the corresponding fusion tensor as\n\nusing TensorKit: fusiontensor\nf = fusiontensor(SU2Irrep(1//2), SU2Irrep(1//2), SU2Irrep(1))\n\nWe see that this fusion tensor has a size 2√ó2√ó3√ó1, which contains an additional trailing 1 to what we might expect. In the general case, fusiontensor returns a four-dimensional array, where the size of the first three dimensions corresponds to the dimensions of the irrep spaces under consideration, and the last index lables the different fusion channels, where its dimension corresponds to the number of distinct ways the irreps l_1 and l_2 can fuse to irrep k. This is precicely the extra label of the Clebsch-Gordan coefficients that is required in the the presence of fusion multiplicities. Since mathsfSU_2 is multiplicity-free, we can just discard this last index here.\n\nWe can now explicitly verify that this fusiontensor indeed does what we expect it to do:\n\n@test ta ‚âà f[:, :, :, 1]\n\nOf course, in this case fusiontensor just calls Wignersymbols.clebschgordan under the hood. However, TensorKitSectors.fusiontensor works for general symmetries, and makes it so that we never have to manually assemble the coefficients into an array.","category":"section"},{"location":"appendix/symmetric_tutorial/#The-'generic'-approach-to-the-spin-1-Heisenberg-model:-Wigner-Eckart-in-action","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"The 'generic' approach to the spin-1 Heisenberg model: Wigner-Eckart in action","text":"Consider the spin-1 Heisenberg model with Hamiltonian\n\nH = J sum_langle ij rangle vecS_i cdot vecS_j\n\nwhere vecS = (S^x S^y S^z) are the spin operators. The physical Hilbert space at each site is the three-dimensional spin-1 irrep of mathsfSU_2. Each two-site exchange operator vecS_i cdot vecS_j in the sum commutes with a global transformation g in mathsfSU_2, so that it satisfies the above symmetry condition. Therefore, we can represent it as an mathsfSU_2-symmetric TensorMap, as long as we can isolate its reduced tensor elements.\n\nIn order to apply the above procedure, we first require the matrix elements in the irrep basis. These can be constructed as a 3 times 3 times 3 times 3 array SS using the familiar representation of the mathsfSU_2 generators in the spin-1 representation, with respect to the ket1-1 ket10 ket11 basis.\n\nSx = 1 / sqrt(2) * ComplexF64[0 1 0; 1 0 1; 0 1 0]\nSy = 1 / sqrt(2) * ComplexF64[0 1im 0; -1im 0 1im; 0 -1im 0]\nSz = ComplexF64[-1 0 0; 0 0 0; 0 0 1]\n\n@tensor SS_arr[-1 -2; -3 -4] := Sx[-1; -3] * Sx[-2; -4] + Sy[-1; -3] * Sy[-2; -4] + Sz[-1; -3] * Sz[-2; -4]\nnothing #hide\n\nThe next step is to project out the reduced tensor elements by taking the overlap with the appropriate Clebsch-Gordan coefficients. In our current case of a spin-1 physical space, we have l_1 = l_2 = l_3 = l_4 = 1, and the coupled irrep k can therefore take the values 0 1 2. The reduced tensor element for a given k can be implemented in the following way:\n\nfunction get_reduced_element(k::SU2Irrep)\n    # construct Clebsch-Gordan coefficients for coupling 1 ‚äó 1 to k   \n    f = fusiontensor(SU2Irrep(1), SU2Irrep(1), k)[:, :, :, 1]\n    # project out diagonal matrix on coupled irrep space\n    @tensor reduced_matrix[-1; -2] := conj(f[1 2; -1]) * SS_arr[1 2; 3 4] * f[3 4; -2]\n    # check that it is proportional to the identity\n    @assert isapprox(reduced_matrix, reduced_matrix[1, 1] * I; atol=1e-12)\n    # return the proportionality factor\n    return reduced_matrix[1, 1]\nend\n\nIf we use this to compute the reduced tensor elements for k = 0 1 2,\n\nget_reduced_element(SU2Irrep(0))\n\nget_reduced_element(SU2Irrep(1))\n\nget_reduced_element(SU2Irrep(2))\n\nwe can read off the entries\n\nrenewcommandthickspacekern 01ex\nleft (vecS_i cdot vecS_j)_textred right \nbeginsmallmatrix\n    11\n    0\n    11\nendsmallmatrix = -2 quad\nleft (vecS_i cdot vecS_j)_textred right \nbeginsmallmatrix\n    11\n    1\n    11\nendsmallmatrix = -1 quad\nleft (vecS_i cdot vecS_j)_textred right \nbeginsmallmatrix\n    11\n    2\n    11\nendsmallmatrix = 1 quad\n\nThese can then be used to construct the symmetric TensorMap representing the exchange interaction:\n\nV = SU2Space(1 => 1)\nSS = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(SS)\n    k = f.coupled\n    SS[s, f] .= get_reduced_element(k)\nend\nsubblocks(SS)\n\nWe demonstrated this entire procedure of extracting the reduced tensor elements of a symmetric tensor map for each fusion tree by projecting out the corresponding fusion tensors as an explicit illustration of how symmetric tensor maps work under the hood. In practice however, there is no need to perform this procedure explicitly. Given a dense array representing the matrix elements of a tensor map in the irrep basis, we can convert this to the corresponding symmetric tensor map by passing the data array to the TensorMap constructor along with the corresponding spaces,\n\nSS_auto = TensorMap(SS_arr, V ‚äó V ‚Üê V ‚äó V)\n@test SS_auto ‚âà SS\n\nwarning: Warning\nWhile the example demonstrated here seems fairly straightforward, there's some inherent challenges to directly initializing a symmetric tensor map from a full dense array. A first important point to reiterate here is that in order for this procedure to work, we had to initialize SS_arr by assuming an internal basis convention for the mathsfSU_2 representation space V^(1) that is consistent with the convention used by fusiontensor. While that choice here, corresponding to an ascending magnetic quantum number m = -1 0 1, seems quite natural, for many symmetries there is no transparent natural choice. In those cases, the only way to use this approach is to explicitly check the basis convention used by TensorKitSectors.fusiontensor for that specific symmetry. On top of this, there are some additional complications when considering graded spaces which contain multiple sectors with non-trivial degeneracies. In that case, to even initialize the dense data array in the first place, you would need to know the order in which the sectors appear in each space internally. This information can be obtained by calling axes(V, c), where V and c are either an ElementarySpace and a Sector, or a ProductSpace and a Tuple of Sectors respectively.","category":"section"},{"location":"appendix/symmetric_tutorial/#An-'elegant'-approach-to-the-Heisenberg-model","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"An 'elegant' approach to the Heisenberg model","text":"As noted above, the explicit procedure of projecting out the reduced tensor elements from the action of an operator in the irrep basis can be a bit cumbersome for more complicated groups. However, using some basic representation theory we can bypass this step altogether for the Heisenberg model. First, we rewrite the exchange interaction in the following way:\n\nbeginequation\nlabeleqcasimir_decomp\nvecS_i cdot vecS_j = frac12 left( left( vecS_i + vecS_j right)^2 - vecS_i^2 - vecS_j^2 right)\nendequation\n\nHere, vecS_i and vecS_j are spin operators on the physical irrep, while total spin operator vecS_i + vecS_j can be decomposed onto the different coupled irreps k. It is a well known fact that the quadratic sum of the generators of mathsfSU_2, often refered to as the quadratic Casimir, commutes with all generators. By Schur's lemma, it must then act proportionally to the identity on every irrep, where the corresponding eigenvalue is determined by the spin irrep label. In particular, we have for each irrep l\n\nvecS^2 ketlm = l(l+1) ketlm\n\nIt then follows from Eq. \\eqref{eq:casimir_decomp} that the reduced tensor elements of the exchange interaction are completely determined by the eigenvalue of the quadratic Casimir on the uncoupled and coupled irreps. Indeed, to each fusion tree we can associate a well-defined value\n\n<center><img src=\"../img/symmetric_tutorial/SU2_fusiontrees.svg\" alt=\"SU2_fusiontrees\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThis gives us all we need to directly construct the exchange interaction as a symmetric TensorMap,\n\nV = SU2Space(1 => 1)\nSS = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(SS)\n    l3 = f.uncoupled[1].j\n    l4 = f.uncoupled[2].j\n    k = f.coupled.j\n    SS[s, f] .= (k * (k + 1) - l3 * (l3 + 1) - l4 * (l4 + 1)) / 2\nend\nsubblocks(SS)\n\nwhich gives exactly the same result as the previous approach.\n\nnote: Note\nThis last construction for the exchange interaction immediately generalizes to any value of the physical spin. All we need is to fill in the appropriate values for the uncoupled irreps l_1, l_2, l_3 and l_4.","category":"section"},{"location":"appendix/symmetric_tutorial/#sss_sun_heisenberg","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"mathsfSU_N generalization","text":"We end this subsection with some comments on the generalization of the above discussion to mathsfSU_N. As foreshadowed above, the irreps of mathsfSU_N in general have an even more complicated structure. In particular, they can admit so-called fusion multiplicities, where the fusion of two irreps can have not only multiple distinct outcomes, but they can even fuse to a given irrep in multiple inequivalent ways. We can demonstrate this behavior for the adjoint representation of mathsfSU_3. For this we can use the the SUNRepresentations.jl package which provides an interface for working with irreps of mathsfSU_N and their Clebsch-Gordan coefficients. A particular representation is represented by an SUNIrrep{N} which can be used with TensorKit.jl. The eight-dimensional adjoint representation of mathsfSU_3 is given by\n\nl = SU3Irrep(\"8\")\n\nIf we look at the possible outcomes of fusing two adjoint irreps, we find the by now familiar non-Abelian fusion behavior,\n\ncollect(l ‚äó l)\n\nHowever, this particular fusion has multiplicities, since the adjoint irrep can actually fuse to itself in two distinct ways. The full decomposition of this fusion product is given by\n\nmathbf8 otimes mathbf8 = mathbf1 oplus mathbf3 oplus 2 cdot mathbf8 oplus mathbf10 oplus mathbfoverline10 oplus mathbf27\n\nThis fusion multiplicity can be detected by using Nsymbol method from TensorKit.jl to inspect the number of times l appears in the fusion product l ‚äó l,\n\nNsymbol(l, l, l)\n\nWhen working with irreps with fusion multiplicities, each FusionTree carries additional vertices labels which label which of the distinct fusion vertices is being referred to. We will return to this at the end of this section.\n\nGiven the generators T^k of mathsfSU_N, we can define a generalized Heisenberg model using a similar exchange interaction, giving the Hamiltonian\n\nH = J sum_langle ij rangle vecT_i cdot vecT_j\n\nFor a particular choice of physical irrep, the exchange interaction can again be constructed as a symmetric TensorMap by first rewriting it as\n\nvecT_i cdot vecT_j = frac12 left( left( vecT_i + vecT_j right)^2 - vecT_i^2 - vecT_j^2 right)\n\nFor any N, the quadratic Casimir\n\nOmega = sum_k T^k T^k\n\ncommutes with all mathsfSU_N generators, meaning it has a well defined eigenvalue in each irrep. This observation then immediately given the reduced tensor elements of the exchange interaction as\n\n<center><img src=\"../img/symmetric_tutorial/SUN_fusiontrees.svg\" alt=\"SUN_fusiontrees\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nUsing these to directly construct the corresponding symmetric TensorMap is much simpler than going through the explicit projection procedure using Clebsch-Gordan coefficients.\n\nFor the particular example of mathsfSU_3, the generators are given by T^k = frac12 lambda^k , where lambda^k are the Gell-Mann matrices. Each irrep can be labeled as l = D(pq) where p and q are refered to as the Dynkin labels. The eigenvalue of the quadratic Casimir for a given irrep is given by Freudenthal's formula,\n\nOmega(D(pq)) = frac13 (p^2 + q^2 + 3p + 3q + pq)\n\nUsing SUNRepresentations.jl, we can compute the Casimir as\n\nfunction casimir(l::SU3Irrep)\n    p, q = dynkin_label(l)\n    return (p^2 + q^2 + 3 * p + 3 * q + p * q) / 3\nend\n\nIf we use the adjoint representation of mathsfSU_3 as physical space, the Heisenberg exchange interaction can then be constructed as\n\nV = Vect[SUNIrrep{3}](SU3Irrep(\"8\") => 1)\nTT = zeros(ComplexF64, V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(TT)\n    l3 = f.uncoupled[1]\n    l4 = f.uncoupled[2]\n    k = f.coupled\n    TT[s, f] .= (casimir(k) - casimir(l3) - casimir(l4)) / 2\nend\nsubblocks(TT)\n\nCircling back to our earlier remark, we clearly see that the fusion trees of this tensor indeed have non-trivial vertex labels.\n\nf = collect(fusiontrees(TT))[4][2]\n\nf.vertices\n\nnote: Note\nWhile we have given an explicit example using mathsfSU_3 with the adoint irrep on the physical level, the same construction holds for the general mathsfSU_N with arbitrary physical irreps. All we require is the expression for the eigenvalues of the quadratic Casimir in each irrep.","category":"section"},{"location":"appendix/symmetric_tutorial/#Level-5:-Anyonic-Symmetries-and-the-Golden-Chain","page":"A symmetric tensor deep dive: constructing your first tensor map","title":"Level 5: Anyonic Symmetries and the Golden Chain","text":"While we have focussed exclusively on group-like symmetries in our discussion so far, the framework of symmetric tensors actually extends beyond groups to so-called categorical symmetries. These are quite exotic symmetries characterized in terms of the topological data of a unitary fusion category. While the precise details of all the terms in these statements fall beyond the scope of this tutorial, we can give a simple example of a Hamiltonian model with a categorical symmetry called the golden chain.\n\nThis is a one-dimensional system defined as a spin chain, where each physical 'spin' corresponds to a so-called Fibonacci anyon. There are two such Fibonacci anyons, which we will denote as 1 and tau. They obey the fusion rules\n\n1 otimes 1 = 1 quad 1 otimes tau = tau quad tau otimes tau = 1 oplus tau\n\nThe Hilbert space of a chain of Fibonacci anyons is not a regular tensor product space, but rather a constrained Hilbert space where the only allowed basis states are labeled by valid Fibonacci fusion configurations. In the golden chain model, we define a nearest-neighbor Hamiltonian on this Hilbert space by imposing an energy penalty when two neighboring anyons fuse to a tau anyon.\n\nEven just writing down an explicit expression for this interaction on such a constrained Hilbert space is not entirely straightforward. However, using the framework of symmetric tensors it can actually be explicitly constructed in a very straightforward way. Indeed, TensorKit.jl supports a dedicated FibonacciAnyon sector type which can be used to construct precisely such a constrained Fibonacci-graded vector space. A Hamiltonian\n\nH = sum_langle ij rangle h_ij\n\nwhich favors neighboring anyons fusing to the vacuum can be constructed as a TensorMap on the product space of two Fibonacci-graded physical spaces\n\nV = Vect[FibonacciAnyon](:œÑ => 1)\n\nand assigning the following nonzero subblock value to the two-site fusion trees\n\n<center><img src=\"../img/symmetric_tutorial/Fib_fusiontrees.svg\" alt=\"Fib_fusiontrees\" class=\"color-invertible\" style=\"zoom: 170%\"/></center>\n\nThis allows us to define this, at first sight, exotic and complicated Hamiltonian in a few simple lines of code,\n\nh = ones(V ‚äó V ‚Üê V ‚äó V)\nfor (s, f) in fusiontrees(h)\n    h[s, f] .= f.coupled == FibonacciAnyon(:I) ? -1 : 0\nend\nsubblocks(h)\n\nnote: Note\nIn the previous section we have stressed the role of Clebsch-Gordan coefficients in the structure of symmetric tensors, and how they can be used to map between the representation of an operator in the irrep basis and its symmetric tensor representation. However, for categorical symmetries such as the Fibonacci anyons, there are no Clebsch-Gordan coefficients. Therefore, the 'matrix elements of the operator in the irrep basis' are not well-defined, meaning that a Fibonacci-symmetric tensor cannot actually be converted to a plain array in a straightforward way.","category":"section"},{"location":"#TensorKit.jl","page":"Home","title":"TensorKit.jl","text":"A Julia package for large-scale tensor computations, with a hint of category theory.","category":"section"},{"location":"#Package-summary","page":"Home","title":"Package summary","text":"TensorKit.jl aims to be a generic package for working with tensors as they appear throughout the physical sciences. TensorKit implements a parametric type Tensor (which is actually a specific case of the type TensorMap) and defines for these types a number of vector space operations (scalar multiplication, addition, norms and inner products), index operations (permutations) and linear algebra operations (multiplication, factorizations). Finally, tensor contractions can be performed using the @tensor macro from TensorOperations.jl.\n\nCurrently, most effort is oriented towards tensors as they appear in the context of quantum many-body physics and in particular the field of tensor networks. Such tensors often have large dimensions and take on a specific structure when symmetries are present. By employing concepts from category theory, we can represent and manipulate tensors with a large variety of symmetries, including abelian and non-abelian symmetries, fermionic statistics, as well as generalized (a.k.a. non-invertible or anyonic) symmetries.\n\nAt the same time, TensorKit.jl focusses on computational efficiency and performance. The underlying storage of a tensor's data can be any DenseArray. When the data is stored in main memory (corresponding to Array), multiple CPUs can be leveraged as many operations come with multithreaded implementations, either by distributing the different blocks in case of a structured tensor (i.e. with symmetries) or by using multithreading provided by the package Strided.jl. Support for storing and manipulating tensors on Nvidia and AMD GPUs is currently being developed, whereas support for distributed arrays is planned for the future.","category":"section"},{"location":"#Contents-of-the-manual","page":"Home","title":"Contents of the manual","text":"Pages = [\"man/intro.md\", \"man/spaces.md\", \"man/symmetries.md\", \"man/sectors.md\", \"man/gradedspaces.md\", \"man/fusiontrees.md\", \"man/tensors.md\", \"man/tensormanipulations.md\"]\nDepth = 2","category":"section"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"Pages = [\"lib/sectors.md\",\"lib/fusiontrees.md\",\"lib/spaces.md\",\"lib/tensors.md\"]\nDepth = 2","category":"section"},{"location":"#Appendix","page":"Home","title":"Appendix","text":"Pages = [\"appendix/symmetric_tutorial.md\", \"appendix/categories.md\"]\nDepth = 2","category":"section"}]
}
