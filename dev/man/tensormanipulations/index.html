<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manipulating tensors ¬∑ TensorKit.jl</title><meta name="title" content="Manipulating tensors ¬∑ TensorKit.jl"/><meta property="og:title" content="Manipulating tensors ¬∑ TensorKit.jl"/><meta property="twitter:title" content="Manipulating tensors ¬∑ TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../symmetries/">Symmetries</a></li><li><a class="tocitem" href="../sectors/">Sectors</a></li><li><a class="tocitem" href="../gradedspaces/">Graded spaces</a></li><li><a class="tocitem" href="../fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../tensors/">Constructing tensors and the <code>TensorMap</code> type</a></li><li class="is-active"><a class="tocitem" href>Manipulating tensors</a><ul class="internal"><li><a class="tocitem" href="#ss_tensor_linalg"><span>Vector space and linear algebra operations</span></a></li><li><a class="tocitem" href="#ss_indexmanipulation"><span>Index manipulations</span></a></li><li><a class="tocitem" href="#ss_tensor_factorization"><span>Tensor factorizations</span></a></li><li><a class="tocitem" href="#ss_tensor_contraction"><span>Bosonic tensor contractions and tensor networks</span></a></li><li><a class="tocitem" href="#Fermionic-tensor-contractions"><span>Fermionic tensor contractions</span></a></li><li><a class="tocitem" href="#Anyonic-tensor-contractions"><span>Anyonic tensor contractions</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors</a></li><li><a class="tocitem" href="../../lib/fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/symmetric_tutorial/">A symmetric tensor deep dive: constructing your first tensor map</a></li><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li><li><a class="tocitem" href="../../Changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Manipulating tensors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manipulating tensors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/man/tensormanipulations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="s_tensormanipulations"><a class="docs-heading-anchor" href="#s_tensormanipulations">Manipulating tensors</a><a id="s_tensormanipulations-1"></a><a class="docs-heading-anchor-permalink" href="#s_tensormanipulations" title="Permalink"></a></h1><h2 id="ss_tensor_linalg"><a class="docs-heading-anchor" href="#ss_tensor_linalg">Vector space and linear algebra operations</a><a id="ss_tensor_linalg-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_linalg" title="Permalink"></a></h2><p><code>AbstractTensorMap</code> instances <code>t</code> represent linear maps, i.e. homomorphisms in a <code>ùïú</code>-linear category, just like matrices. To a large extent, they follow the interface of <code>Matrix</code> in Julia&#39;s <code>LinearAlgebra</code> standard library. Many methods from <code>LinearAlgebra</code> are (re)exported by TensorKit.jl, and can then us be used without <code>using LinearAlgebra</code> explicitly. In all of the following methods, the implementation acts directly on the underlying matrix blocks (typically using the same method) and never needs to perform any basis transforms.</p><p>In particular, <code>AbstractTensorMap</code> instances can be composed, provided the domain of the first object coincides with the codomain of the second. Composing tensor maps uses the regular multiplication symbol as in <code>t = t1 * t2</code>, which is also used for matrix multiplication. TensorKit.jl also supports (and exports) the mutating method <code>mul!(t, t1, t2)</code>. We can then also try to invert a tensor map using <code>inv(t)</code>, though this can only exist if the domain and codomain are isomorphic, which can e.g. be checked as <code>fuse(codomain(t)) == fuse(domain(t))</code>. If the inverse is composed with another tensor <code>t2</code>, we can use the syntax <code>t1 \ t2</code> or <code>t2 / t1</code>. However, this syntax also accepts instances <code>t1</code> whose domain and codomain are not isomorphic, and then amounts to <code>pinv(t1)</code>, the Moore-Penrose pseudoinverse. This, however, is only really justified as minimizing the least squares problem if <code>InnerProductStyle(t) &lt;: EuclideanProduct</code>.</p><p><code>AbstractTensorMap</code> instances behave themselves as vectors (i.e. they are <code>ùïú</code>-linear) and so they can be multiplied by scalars and, if they live in the same space, i.e. have the same domain and codomain, they can be added to each other. There is also a <code>zero(t)</code>, the additive identity, which produces a zero tensor with the same domain and codomain as <code>t</code>. In addition, <code>TensorMap</code> supports basic Julia methods such as <code>fill!</code> and <code>copy!</code>, as well as <code>copy(t)</code> to create a copy with independent data. Aside from basic <code>+</code> and <code>*</code> operations, TensorKit.jl reexports a number of efficient in-place methods from <code>LinearAlgebra</code>, such as <code>axpy!</code> (for <code>y ‚Üê Œ± * x + y</code>), <code>axpby!</code> (for <code>y ‚Üê Œ± * x + Œ≤ * y</code>), <code>lmul!</code> and <code>rmul!</code> (for <code>y ‚Üê Œ± * y</code> and <code>y ‚Üê y * Œ±</code>, which is typically the same) and <code>mul!</code>, which can also be used for out-of-place scalar multiplication <code>y ‚Üê Œ± * x</code>.</p><p>For <code>S = spacetype(t)</code> where <code>InnerProductStyle(S) &lt;: EuclideanProduct</code>, we can compute <code>norm(t)</code>, and for two such instances, the inner product <code>dot(t1, t2)</code>, provided <code>t1</code> and <code>t2</code> have the same domain and codomain. Furthermore, there is <code>normalize(t)</code> and <code>normalize!(t)</code> to return a scaled version of <code>t</code> with unit norm. These operations should also exist for <code>InnerProductStyle(S) &lt;: HasInnerProduct</code>, but require an interface for defining a custom inner product in these spaces. Currently, there is no concrete subtype of <code>HasInnerProduct</code> that is not an <code>EuclideanProduct</code>. In particular, <code>CartesianSpace</code>, <code>ComplexSpace</code> and <code>GradedSpace</code> all have <code>InnerProductStyle(S) &lt;: EuclideanProduct</code>.</p><p>With tensors that have <code>InnerProductStyle(t) &lt;: EuclideanProduct</code> there is associated an adjoint operation, given by <code>adjoint(t)</code> or simply <code>t&#39;</code>, such that <code>domain(t&#39;) == codomain(t)</code> and <code>codomain(t&#39;) == domain(t)</code>. Note that for an instance <code>t::TensorMap{S, N‚ÇÅ, N‚ÇÇ}</code>, <code>t&#39;</code> is simply stored in a wrapper called <code>AdjointTensorMap{S, N‚ÇÇ, N‚ÇÅ}</code>, which is another subtype of <code>AbstractTensorMap</code>. This should be mostly invisible to the user, as all methods should work for this type as well. It can be hard to reason about the index order of <code>t&#39;</code>, i.e. index <code>i</code> of <code>t</code> appears in <code>t&#39;</code> at index position <code>j = TensorKit.adjointtensorindex(t, i)</code>, where the latter method is typically not necessary and hence unexported. There is also a plural <code>TensorKit.adjointtensorindices</code> to convert multiple indices at once. Note that, because the adjoint interchanges domain and codomain, we have <code>space(t&#39;, j) == space(t, i)&#39;</code>.</p><p><code>AbstractTensorMap</code> instances can furthermore be tested for exact (<code>t1 == t2</code>) or approximate (<code>t1 ‚âà t2</code>) equality, though the latter requires that <code>norm</code> can be computed.</p><p>When tensor map instances are endomorphisms, i.e. they have the same domain and codomain, there is a multiplicative identity which can be obtained as <code>one(t)</code> or <code>one!(t)</code>, where the latter overwrites the contents of <code>t</code>. The multiplicative identity on a space <code>V</code> can also be obtained using <code>id(A, V)</code> as discussed <a href="../tensors/#ss_tensor_construction">above</a>, such that for a general homomorphism <code>t‚Ä≤</code>, we have <code>t‚Ä≤ == id(codomain(t‚Ä≤)) * t‚Ä≤ == t‚Ä≤ * id(domain(t‚Ä≤))</code>. Returning to the case of endomorphisms <code>t</code>, we can compute the trace via <code>tr(t)</code> and exponentiate them using <code>exp(t)</code>, or if the contents of <code>t</code> can be destroyed in the process, <code>exp!(t)</code>. Furthermore, there are a number of tensor factorizations for both endomorphisms and general homomorphism that we discuss below.</p><p>Finally, there are a number of operations that also belong in this paragraph because of their analogy to common matrix operations. The tensor product of two <code>TensorMap</code> instances <code>t1</code> and <code>t2</code> is obtained as <code>t1 ‚äó t2</code> and results in a new <code>TensorMap</code> with <code>codomain(t1 ‚äó t2) = codomain(t1) ‚äó codomain(t2)</code> and <code>domain(t1 ‚äó t2) = domain(t1) ‚äó domain(t2)</code>. If we have two <code>TensorMap{T, S, N, 1}</code> instances <code>t1</code> and <code>t2</code> with the same codomain, we can combine them in a way that is analogous to <code>hcat</code>, i.e. we stack them such that the new tensor <code>catdomain(t1, t2)</code> has also the same codomain, but has a domain which is <code>domain(t1) ‚äï domain(t2)</code>. Similarly, if <code>t1</code> and <code>t2</code> are of type <code>TensorMap{T, S, 1, N}</code> and have the same domain, the operation <code>catcodomain(t1, t2)</code> results in a new tensor with the same domain and a codomain given by <code>codomain(t1) ‚äï codomain(t2)</code>, which is the analogy of <code>vcat</code>. Note that direct sum only makes sense between <code>ElementarySpace</code> objects, i.e. there is no way to give a tensor product meaning to a direct sum of tensor product spaces.</p><p>Time for some more examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚ÑÇ^2</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = randn(V1 ‚Üê V1 ‚äó V1 ‚äó V1)</code><code class="nohighlight hljs ansi" style="display:block;">2‚Üê2√ó2√ó2 TensorMap{Float64, ComplexSpace, 1, 3, Vector{Float64}}:
 codomain: ‚äó(‚ÑÇ^2)
 domain: (‚ÑÇ^2 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^2)
 blocks:
 * Trivial() =&gt; 2√ó8 reshape(view(::Vector{Float64}, 1:16), 2, 8) with eltype Float64:
  0.465901  -0.254498  -0.5337     ‚Ä¶  -0.128005  -0.167546  -0.887983
 -0.660226  -2.36314    0.0548958      0.346756  -2.032     -0.0142979</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t == t + zero(t) == t * id(domain(t)) == id(codomain(t)) * t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = randn(ComplexF64, codomain(t), domain(t));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t)</code><code class="nohighlight hljs ansi" style="display:block;">0.8938816886605802 - 2.6614120270181156im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tr(t2&#39; * t)</code><code class="nohighlight hljs ansi" style="display:block;">0.8938816886605803 - 2.6614120270181156im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t) ‚âà dot(t&#39;, t2&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t2)</code><code class="nohighlight hljs ansi" style="display:block;">15.447439316127337 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(t2)^2</code><code class="nohighlight hljs ansi" style="display:block;">15.447439316127333</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 = copy!(similar(t, ComplexF64), t);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 == t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rmul!(t3, 0.8);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 ‚âà 0.8 * t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; axpby!(0.5, t2, 1.3im, t3);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 ‚âà 0.5 * t2 + 0.8 * 1.3im * t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 = randn(fuse(codomain(t)), codomain(t));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t5 = TensorMap{Float64}(undef, fuse(codomain(t)), domain(t));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mul!(t5, t4, t) == t4 * t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; inv(t4) * t4 ‚âà id(codomain(t))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 * inv(t4) ‚âà id(fuse(codomain(t)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 \ (t4 * t) ‚âà t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t6 = randn(ComplexF64, V1, codomain(t));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numout(t4) == numout(t6) == 1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t7 = catcodomain(t4, t6);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foreach(println, (codomain(t4), codomain(t6), codomain(t7)))</code><code class="nohighlight hljs ansi" style="display:block;">‚äó(‚ÑÇ^2)
‚äó(‚ÑÇ^2)
‚äó(‚ÑÇ^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(t7) ‚âà sqrt(norm(t4)^2 + norm(t6)^2)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t8 = t4 ‚äó t6;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foreach(println, (codomain(t4), codomain(t6), codomain(t8)))</code><code class="nohighlight hljs ansi" style="display:block;">‚äó(‚ÑÇ^2)
‚äó(‚ÑÇ^2)
(‚ÑÇ^2 ‚äó ‚ÑÇ^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foreach(println, (domain(t4), domain(t6), domain(t8)))</code><code class="nohighlight hljs ansi" style="display:block;">‚äó(‚ÑÇ^2)
‚äó(‚ÑÇ^2)
(‚ÑÇ^2 ‚äó ‚ÑÇ^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(t8) ‚âà norm(t4)*norm(t6)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="ss_indexmanipulation"><a class="docs-heading-anchor" href="#ss_indexmanipulation">Index manipulations</a><a id="ss_indexmanipulation-1"></a><a class="docs-heading-anchor-permalink" href="#ss_indexmanipulation" title="Permalink"></a></h2><p>In many cases, the bipartition of tensor indices (i.e. <code>ElementarySpace</code> instances) between the codomain and domain is not fixed throughout the different operations that need to be performed on that tensor map, i.e. we want to use the duality to move spaces from domain to codomain and vice versa. Furthermore, we want to use the braiding to reshuffle the order of the indices.</p><p>For this, we use an interface that is closely related to that for manipulating splitting- fusion tree pairs, namely <a href="../../lib/fusiontrees/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>braid</code></a> and <a href="../../lib/fusiontrees/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute</code></a>, with the interface</p><pre><code class="language-julia hljs">braid(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, (p1, p2)::Index2Tuple{N‚ÇÅ‚Ä≤,N‚ÇÇ‚Ä≤}, levels::IndexTuple{N‚ÇÅ+N‚ÇÇ,Int})</code></pre><p>and</p><pre><code class="language-julia hljs">permute(t::AbstractTensorMap{T,S,N‚ÇÅ,N‚ÇÇ}, (p1, p2)::Index2Tuple{N‚ÇÅ‚Ä≤,N‚ÇÇ‚Ä≤}; copy = false)</code></pre><p>both of which return an instance of <code>AbstractTensorMap{T, S, N‚ÇÅ‚Ä≤, N‚ÇÇ‚Ä≤}</code>.</p><p>In these methods, <code>p1</code> and <code>p2</code> specify which of the original tensor indices ranging from <code>1</code> to <code>N‚ÇÅ + N‚ÇÇ</code> make up the new codomain (with <code>N‚ÇÅ‚Ä≤</code> spaces) and new domain (with <code>N‚ÇÇ‚Ä≤</code> spaces). Hence, <code>(p1..., p2...)</code> should be a valid permutation of <code>1:(N‚ÇÅ + N‚ÇÇ)</code>. Note that, throughout TensorKit.jl, permutations are always specified using tuples of <code>Int</code>s, for reasons of type stability. For <code>braid</code>, we also need to specify <code>levels</code> or depths for each of the indices of the original tensor, which determine whether indices will braid over or underneath each other (use the braiding or its inverse). We refer to the section on <a href="@ref ss_fusiontrees">manipulating fusion trees</a> for more details.</p><p>When <code>BraidingStyle(sectortype(t)) isa SymmetricBraiding</code>, we can use the simpler interface of <code>permute</code>, which does not require the argument <code>levels</code>. <code>permute</code> accepts a keyword argument <code>copy</code>. When <code>copy == true</code>, the result will be a tensor with newly allocated data that can independently be modified from that of the input tensor <code>t</code>. When <code>copy</code> takes the default value <code>false</code>, <code>permute</code> can try to return the result in a way that it shares its data with the input tensor <code>t</code>, though this is only possible in specific cases (e.g. when <code>sectortype(S) == Trivial</code> and <code>(p1..., p2...) = (1:(N‚ÇÅ+N‚ÇÇ)...)</code>).</p><p>Both <code>braid</code> and <code>permute</code> come in a version where the result is stored in an already existing tensor, i.e. <a href="../../lib/tensors/#TensorKit.braid!"><code>braid!(tdst, tsrc, (p1, p2), levels)</code></a> and <a href="../../lib/tensors/#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><code>permute!(tdst, tsrc, (p1, p2))</code></a>.</p><p>Another operation that belongs under index manipulations is taking the <code>transpose</code> of a tensor, i.e. <code>LinearAlgebra.transpose(t)</code> and <code>LinearAlgebra.transpose!(tdst, tsrc)</code>, both of which are reexported by TensorKit.jl. Note that <code>transpose(t)</code> is not simply equal to reshuffling domain and codomain with <code>braid(t, (1:(N‚ÇÅ+N‚ÇÇ)...), reverse(domainind(tsrc)), reverse(codomainind(tsrc))))</code>. Indeed, the graphical representation (where we draw the codomain and domain as a single object), makes clear that this introduces an additional (inverse) twist, which is then compensated in the <code>transpose</code> implementation.</p><img src="../img/tensor-transpose.svg" alt="transpose" class="color-invertible"/><p>In categorical language, the reason for this extra twist is that we use the left coevaluation <span>$Œ∑$</span>, but the right evaluation <span>$\tilde{œµ}$</span>, when repartitioning the indices between domain and codomain.</p><p>There are a number of other index related manipulations. We can apply a twist (or inverse twist) to one of the tensor map indices via <a href="../../lib/sectors/#TensorKitSectors.twist-Tuple{Sector}"><code>twist(t, i; inv = false)</code></a> or <a href="../../lib/tensors/#TensorKit.twist!"><code>twist!(t, i; inv = false)</code></a>. Note that the latter method does not store the result in a new destination tensor, but just modifies the tensor <code>t</code> in place. Twisting several indices simultaneously can be obtained by using the defining property</p><p class="math-container">\[Œ∏_{V‚äóW} = œÑ_{W,V} ‚àò (Œ∏_W ‚äó Œ∏_V) ‚àò œÑ_{V,W} = (Œ∏_V ‚äó Œ∏_W) ‚àò œÑ_{W,V} ‚àò œÑ_{V,W},\]</p><p>but is currently not implemented explicitly.</p><p>For all sector types <code>I</code> with <code>BraidingStyle(I) == Bosonic()</code>, all twists are <code>1</code> and thus have no effect. Let us start with some examples, in which we illustrate that, albeit <code>permute</code> might act highly non-trivial on the fusion trees and on the corresponding data, after conversion to a regular <code>Array</code> (when possible), it just acts like <code>permutedims</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t) ‚Üí codomain(t)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2 ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ta = convert(Array, t);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤ = permute(t, (1, 2, 3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t‚Ä≤) ‚Üí codomain(t‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó (‚ÑÇ^2)&#39; ‚äó (‚ÑÇ^2)&#39; ‚äó (‚ÑÇ^2)&#39;) ‚Üê one(ComplexSpace)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, t‚Ä≤) ‚âà ta</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤‚Ä≤ = permute(t, ((4, 2, 3), (1,)));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t‚Ä≤‚Ä≤) ‚Üí codomain(t‚Ä≤‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^2)&#39; ‚äó (‚ÑÇ^2)&#39; ‚äó (‚ÑÇ^2)&#39;) ‚Üê (‚ÑÇ^2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, t‚Ä≤‚Ä≤) ‚âà permutedims(ta, (4, 2, 3, 1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(t)</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2√ó2‚Üê2 TensorMap{Float64, ComplexSpace, 3, 1, Vector{Float64}}:
 codomain: ((‚ÑÇ^2)&#39; ‚äó (‚ÑÇ^2)&#39; ‚äó (‚ÑÇ^2)&#39;)
 domain: ‚äó((‚ÑÇ^2)&#39;)
 blocks:
 * Trivial() =&gt; 8√ó2 reshape(view(::Vector{Float64}, 1:16), 8, 2) with eltype Float64:
  0.465901  -0.660226
 -0.169138  -0.635855
 -0.5337     0.0548958
 -0.167546  -2.032
 -0.254498  -2.36314
 -0.128005   0.346756
 -0.20509   -0.595731
 -0.887983  -0.0142979</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, transpose(t)) ‚âà permutedims(ta, (4, 3, 2, 1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t) ‚âà dot(transpose(t2), transpose(t))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(transpose(t)) ‚âà t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(t, 3) ‚âà t</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Note that <code>transpose</code> acts like one would expect on a <code>TensorMap{T, S, 1, 1}</code>. On a <code>TensorMap{T, S, N‚ÇÅ, N‚ÇÇ}</code>, because <code>transpose</code> replaces the codomain with the dual of the domain, which has its tensor product operation reversed, this in the end amounts in a complete reversal of all tensor indices when representing it as a plain multi-dimensional <code>Array</code>. Also, note that we have not defined the conjugation of <code>TensorMap</code> instances. One definition that one could think of is <code>conj(t) = adjoint(transpose(t))</code>. However note that <code>codomain(adjoint(tranpose(t))) == domain(transpose(t)) == dual(codomain(t))</code> and similarly <code>domain(adjoint(tranpose(t))) == dual(domain(t))</code>, where <code>dual</code> of a <code>ProductSpace</code> is composed of the dual of the <code>ElementarySpace</code> instances, in reverse order of tensor product. This might be very confusing, and as such we leave tensor conjugation undefined. However, note that we have a conjugation syntax within the context of <a href="#ss_tensor_contraction">tensor contractions</a>.</p><p>To show the effect of <code>twist</code>, we now consider a type of sector <code>I</code> for which <code>BraidingStyle(I) != Bosonic()</code>. In particular, we use <code>FibonacciAnyon</code>. We cannot convert the resulting <code>TensorMap</code> to an <code>Array</code>, so we have to rely on indirect tests to verify our results.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = GradedSpace{FibonacciAnyon}(:I =&gt; 3, :œÑ =&gt; 2)</code><code class="nohighlight hljs ansi" style="display:block;">Vect[FibonacciAnyon](‚Ä¶) of dim 6.23606797749979:
 :I =&gt; 3
 :œÑ =&gt; 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = GradedSpace{FibonacciAnyon}(:I =&gt; 2, :œÑ =&gt; 1)</code><code class="nohighlight hljs ansi" style="display:block;">Vect[FibonacciAnyon](‚Ä¶) of dim 3.618033988749895:
 :I =&gt; 2
 :œÑ =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = randn(Float32, V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:33
6.23606797749979‚Üê3.618033988749895 TensorMap{Float32, Vect[FibonacciAnyon], 1, 1, Vector{Float32}}:
 codomain: ‚äó(Vect[FibonacciAnyon](:I =&gt; 3, :œÑ =&gt; 2))
 domain: ‚äó(Vect[FibonacciAnyon](:I =&gt; 2, :œÑ =&gt; 1))
 blocks:
 * FibonacciAnyon(:I) =&gt; 3√ó2 reshape(view(::Vector{Float32}, 1:6), 3, 2) with eltype Float32:
  2.03919   -0.120783
  0.990168   1.24442
 -0.781404   1.16911

 * FibonacciAnyon(:œÑ) =&gt; 2√ó1 reshape(view(::Vector{Float32}, 7:8), 2, 1) with eltype Float32:
 -1.0096807
 -0.6959048</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(m)</code><code class="nohighlight hljs ansi" style="display:block;">3.618033988749895‚Üê6.23606797749979 TensorMap{ComplexF32, Vect[FibonacciAnyon], 1, 1, Vector{ComplexF32}}:
 codomain: ‚äó(Vect[FibonacciAnyon](:I =&gt; 2, :œÑ =&gt; 1)&#39;)
 domain: ‚äó(Vect[FibonacciAnyon](:I =&gt; 3, :œÑ =&gt; 2)&#39;)
 blocks:
 * FibonacciAnyon(:I) =&gt; 2√ó3 reshape(view(::Vector{ComplexF32}, 1:6), 2, 3) with eltype ComplexF32:
   2.03919+0.0im  0.990168+0.0im  -0.781404+0.0im
 -0.120783+0.0im   1.24442+0.0im    1.16911+0.0im

 * FibonacciAnyon(:œÑ) =&gt; 1√ó2 reshape(view(::Vector{ComplexF32}, 7:8), 1, 2) with eltype ComplexF32:
 -1.00968+0.0im  -0.695905+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(braid(m, ((2,), (1,)), (1, 2)), 1)</code><code class="nohighlight hljs ansi" style="display:block;">3.618033988749895‚Üê6.23606797749979 TensorMap{ComplexF32, Vect[FibonacciAnyon], 1, 1, Vector{ComplexF32}}:
 codomain: ‚äó(Vect[FibonacciAnyon](:I =&gt; 2, :œÑ =&gt; 1)&#39;)
 domain: ‚äó(Vect[FibonacciAnyon](:I =&gt; 3, :œÑ =&gt; 2)&#39;)
 blocks:
 * FibonacciAnyon(:I) =&gt; 2√ó3 reshape(view(::Vector{ComplexF32}, 1:6), 2, 3) with eltype ComplexF32:
   2.03919+0.0im  0.990168+0.0im  -0.781404+0.0im
 -0.120783+0.0im   1.24442+0.0im    1.16911+0.0im

 * FibonacciAnyon(:œÑ) =&gt; 1√ó2 reshape(view(::Vector{ComplexF32}, 7:8), 1, 2) with eltype ComplexF32:
 -1.00968+1.21554f-8im  -0.695905-2.1942f-8im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = randn(V1 * V2&#39;, V2 * V1);</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:33</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = randn(ComplexF64, V1 * V2&#39;, V2 * V1);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t1, t2) ‚âà dot(transpose(t1), transpose(t2))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(transpose(t1)) ‚âà t1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>A final operation that one might expect in this section is to fuse or join indices, and its inverse, to split a given index into two or more indices. For a plain tensor (i.e. with <code>sectortype(t) == Trivial</code>) amount to the equivalent of <code>reshape</code> on the multidimensional data. However, this represents only one possibility, as there is no canonically unique way to embed the tensor product of two spaces <code>V1 ‚äó V2</code> in a new space <code>V = fuse(V1 ‚äó V2)</code>. Such a mapping can always be accompagnied by a basis transform. However, one particular choice is created by the function <code>isomorphism</code>, or for <code>EuclideanProduct</code> spaces, <code>unitary</code>. Hence, we can join or fuse two indices of a tensor by first constructing <code>u = unitary(fuse(space(t, i) ‚äó space(t, j)), space(t, i) ‚äó space(t, j))</code> and then contracting this map with indices <code>i</code> and <code>j</code> of <code>t</code>, as explained in the section on <a href="#ss_tensor_contraction">contracting tensors</a>. Note, however, that a typical algorithm is not expected to often need to fuse and split indices, as e.g. tensor factorizations can easily be applied without needing to <code>reshape</code> or fuse indices first, as explained in the next section.</p><h2 id="ss_tensor_factorization"><a class="docs-heading-anchor" href="#ss_tensor_factorization">Tensor factorizations</a><a id="ss_tensor_factorization-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_factorization" title="Permalink"></a></h2><p>As tensors are linear maps, they suport various kinds of factorizations. These functions all interpret the provided <code>AbstractTensorMap</code> instances as a map from <code>domain</code> to <code>codomain</code>, which can be thought of as reshaping the tensor into a matrix according to the current bipartition of the indices.</p><p>TensorKit&#39;s factorizations are provided by <a href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl">MatrixAlgebraKit.jl</a>, which is used to supply both the interface, as well as the implementation of the various operations on the blocks of data. For specific details on the provided functionality, we refer to its <a href="https://quantumkithub.github.io/MatrixAlgebraKit.jl/stable/user_interface/decompositions/">documentation page</a>.</p><p>Finally, note that each of the factorizations takes the current partition of <code>domain</code> and <code>codomain</code> as the <em>axis</em> along which to matricize and perform the factorization. In order to obtain factorizations according to a different bipartition of the indices, we can use any of the previously mentioned <a href="#ss_indexmanipulation">index manipulations</a> before the factorization.</p><p>Some examples to conclude this section</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = SU‚ÇÇSpace(0 =&gt; 2, 1/2 =&gt; 1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](‚Ä¶) of dim 4:
   0 =&gt; 2
 1/2 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU‚ÇÇSpace(0 =&gt; 1, 1/2 =&gt; 1, 1 =&gt; 1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](‚Ä¶) of dim 6:
   0 =&gt; 1
 1/2 =&gt; 1
   1 =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = randn(V1 ‚äó V1, V2);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U, S, Vh = svd_compact(t);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t ‚âà U * S * Vh</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D, V = eigh_full(t&#39; * t);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D ‚âà S * S</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U&#39; * U ‚âà id(domain(U))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; S</code><code class="nohighlight hljs ansi" style="display:block;">6‚Üê6 DiagonalTensorMap{Float64, Rep[SU‚ÇÇ], Vector{Float64}}:
 codomain: ‚äó(Rep[SU‚ÇÇ](0 =&gt; 1, 1/2 =&gt; 1, 1 =&gt; 1))
 domain: ‚äó(Rep[SU‚ÇÇ](0 =&gt; 1, 1/2 =&gt; 1, 1 =&gt; 1))
 blocks:
 * Irrep[SU‚ÇÇ](0) =&gt; 1√ó1 LinearAlgebra.Diagonal{Float64, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}}:
 3.2044222054092044

 * Irrep[SU‚ÇÇ](1/2) =&gt; 1√ó1 LinearAlgebra.Diagonal{Float64, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}}:
 2.2754445739861358

 * Irrep[SU‚ÇÇ](1) =&gt; 1√ó1 LinearAlgebra.Diagonal{Float64, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}}:
 0.09575112978523569</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q, R = left_orth(t; alg = :svd);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q&#39; * Q ‚âà id(domain(Q))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t ‚âà Q * R</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U2, S2, Vh2, Œµ = svd_trunc(t; trunc = truncspace(V1));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vh2 * Vh2&#39; ‚âà id(codomain(Vh2))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; S2</code><code class="nohighlight hljs ansi" style="display:block;">3‚Üê3 DiagonalTensorMap{Float64, Rep[SU‚ÇÇ], Vector{Float64}}:
 codomain: ‚äó(Rep[SU‚ÇÇ](0 =&gt; 1, 1/2 =&gt; 1))
 domain: ‚äó(Rep[SU‚ÇÇ](0 =&gt; 1, 1/2 =&gt; 1))
 blocks:
 * Irrep[SU‚ÇÇ](0) =&gt; 1√ó1 LinearAlgebra.Diagonal{Float64, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}}:
 3.2044222054092044

 * Irrep[SU‚ÇÇ](1/2) =&gt; 1√ó1 LinearAlgebra.Diagonal{Float64, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}}:
 2.2754445739861358</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Œµ ‚âà norm(block(S, Irrep[SU‚ÇÇ](1))) * sqrt(dim(Irrep[SU‚ÇÇ](1)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; L, Q = right_orth(permute(t, ((1,), (2, 3))));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(L), domain(L), domain(Q)</code><code class="nohighlight hljs ansi" style="display:block;">(‚äó(Rep[SU‚ÇÇ](0 =&gt; 2, 1/2 =&gt; 1)), ‚äó(Rep[SU‚ÇÇ](0 =&gt; 2, 1/2 =&gt; 1)), (Rep[SU‚ÇÇ](0 =&gt; 2, 1/2 =&gt; 1)&#39; ‚äó Rep[SU‚ÇÇ](0 =&gt; 1, 1/2 =&gt; 1, 1 =&gt; 1)))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q * Q&#39;</code><code class="nohighlight hljs ansi" style="display:block;">4‚Üê4 TensorMap{Float64, Rep[SU‚ÇÇ], 1, 1, Vector{Float64}}:
 codomain: ‚äó(Rep[SU‚ÇÇ](0 =&gt; 2, 1/2 =&gt; 1))
 domain: ‚äó(Rep[SU‚ÇÇ](0 =&gt; 2, 1/2 =&gt; 1))
 blocks:
 * Irrep[SU‚ÇÇ](0) =&gt; 2√ó2 reshape(view(::Vector{Float64}, 1:4), 2, 2) with eltype Float64:
  1.0          -1.23853e-16
 -1.23853e-16   1.0

 * Irrep[SU‚ÇÇ](1/2) =&gt; 1√ó1 reshape(view(::Vector{Float64}, 5:5), 1, 1) with eltype Float64:
 0.9999999999999999</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = Q&#39; * Q;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P ‚âà P * P</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤ = permute(t, ((1,), (2, 3)));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤ ‚âà t‚Ä≤ * P</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="ss_tensor_contraction"><a class="docs-heading-anchor" href="#ss_tensor_contraction">Bosonic tensor contractions and tensor networks</a><a id="ss_tensor_contraction-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_contraction" title="Permalink"></a></h2><p>One of the most important operation with tensor maps is to compose them, more generally known as contracting them. As mentioned in the section on <a href="../../appendix/categories/#s_categories">category theory</a>, a typical composition of maps in a ribbon category can graphically be represented as a planar arrangement of the morphisms (i.e. tensor maps, boxes with lines eminating from top and bottom, corresponding to source and target, i.e. domain and codomain), where the lines connecting the source and targets of the different morphisms should be thought of as ribbons, that can braid over or underneath each other, and that can twist. Technically, we can embed this diagram in <span>$‚Ñù √ó [0,1]$</span> and attach all the unconnected line endings corresponding objects in the source at some position <span>$(x,0)$</span> for <span>$x‚àà‚Ñù$</span>, and all line endings corresponding to objects in the target at some position <span>$(x,1)$</span>. The resulting morphism is then invariant under what is known as <em>framed three-dimensional isotopy</em>, i.e. three-dimensional rearrangements of the morphism that respect the rules of boxes connected by ribbons whose open endings are kept fixed. Such a two-dimensional diagram cannot easily be encoded in a single line of code.</p><p>However, things simplify when the braiding is symmetric (such that over- and under- crossings become equivalent, i.e. just crossings), and when twists, i.e. self-crossings in this case, are trivial. This amounts to <code>BraidingStyle(I) == Bosonic()</code> in the language of TensorKit.jl, and is true for any subcategory of <span>$\mathbf{Vect}$</span>, i.e. ordinary tensors, possibly with some symmetry constraint. The case of <span>$\mathbf{SVect}$</span> and its subcategories, and more general categories, are discussed below.</p><p>In the case of trivial twists, we can deform the diagram such that we first combine every morphism with a number of coevaluations <span>$Œ∑$</span> so as to represent it as a tensor, i.e. with a trivial domain. We can then rearrange the morphism to be all ligned up horizontally, where the original morphism compositions are now being performed by evaluations <span>$œµ$</span>. This process will generate a number of crossings and twists, where the latter can be omitted because they act trivially. Similarly, double crossings can also be omitted. As a consequence, the diagram, or the morphism it represents, is completely specified by the tensors it is composed of, and which indices between the different tensors are connect, via the evaluation <span>$œµ$</span>, and which indices make up the source and target of the resulting morphism. If we also compose the resulting morphisms with coevaluations so that it has a trivial domain, we just have one type of unconnected lines, henceforth called open indices. We sketch such a rearrangement in the following picture</p><img src="../img/tensor-bosoniccontraction.svg" alt="tensor unitary" class="color-invertible"/><p>Hence, we can now specify such a tensor diagram, henceforth called a tensor contraction or also tensor network, using a one-dimensional syntax that mimicks <a href="https://en.wikipedia.org/wiki/Abstract_index_notation">abstract index notation</a> and specifies which indices are connected by the evaluation map using Einstein&#39;s summation conventation. Indeed, for <code>BraidingStyle(I) == Bosonic()</code>, such a tensor contraction can take the same format as if all tensors were just multi-dimensional arrays. For this, we rely on the interface provided by the package <a href="https://github.com/QuantumKitHub/TensorOperations.jl">TensorOperations.jl</a>.</p><p>The above picture would be encoded as</p><pre><code class="language-julia hljs">@tensor E[a, b, c, d, e] := A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]</code></pre><p>or</p><pre><code class="language-julia hljs">@tensor E[:] := A[1, 2, -4, 3] * B[4, 5, -3, 3] * C[1, -5, 4, -2] * D[-1, 2, 5]</code></pre><p>where the latter syntax is known as NCON-style, and labels the unconnected or outgoing indices with negative integers, and the contracted indices with positive integers.</p><p>A number of remarks are in order. TensorOperations.jl accepts both integers and any valid variable name as dummy label for indices, and everything in between <code>[ ]</code> is not resolved in the current context but interpreted as a dummy label. Here, we label the indices of a <code>TensorMap</code>, like <code>A::TensorMap{T, S, N‚ÇÅ, N‚ÇÇ}</code>, in a linear fashion, where the first position corresponds to the first space in <code>codomain(A)</code>, and so forth, up to position <code>N‚ÇÅ</code>. Index <code>N‚ÇÅ + 1</code> then corresponds to the first space in <code>domain(A)</code>. However, because we have applied the coevaluation <span>$Œ∑$</span>, it actually corresponds to the corresponding dual space, in accordance with the interface of <a href="../../lib/spaces/#TensorKit.space"><code>space(A, i)</code></a> that we introduced <a href="../tensors/#ss_tensor_properties">above</a>, and as indiated by the dotted box around <span>$A$</span> in the above picture. The same holds for the other tensor maps. Note that our convention also requires that we braid indices that we brought from the domain to the codomain, and so this is only unambiguous for a symmetric braiding, where there is a unique way to permute the indices.</p><p>With the current syntax, we create a new object <code>E</code> because we use the definition operator <code>:=</code>. Furthermore, with the current syntax, it will be a <code>Tensor</code>, i.e. it will have a trivial domain, and correspond to the dotted box in the picture above, rather than the actual morphism <code>E</code>. We can also directly define <code>E</code> with the correct codomain and domain by rather using</p><pre><code class="language-julia hljs">@tensor E[a b c;d e] := A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]</code></pre><p>or</p><pre><code class="language-julia hljs">@tensor E[(a, b, c);(d, e)] := A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]</code></pre><p>where the latter syntax can also be used when the codomain is empty. When using the assignment operator <code>=</code>, the <code>TensorMap</code> <code>E</code> is assumed to exist and the contents will be written to the currently allocated memory. Note that for existing tensors, both on the left hand side and right hand side, trying to specify the indices in the domain and the codomain seperately using the above syntax, has no effect, as the bipartition of indices are already fixed by the existing object. Hence, if <code>E</code> has been created by the previous line of code, all of the following lines are now equivalent</p><pre><code class="language-julia hljs">@tensor E[(a, b, c);(d, e)] = A[v, w, d, x] * B[y, z, c, x] * C[v, e, y, b] * D[a, w, z]
@tensor E[a, b, c, d, e] = A[v w d; x] * B[(y, z, c); (x, )] * C[v e y; b] * D[a, w, z]
@tensor E[a b; c d e] = A[v; w d x] * B[y, z, c, x] * C[v, e, y, b] * D[a w; z]</code></pre><p>and none of those will or can change the partition of the indices of <code>E</code> into its codomain and its domain.</p><p>Two final remarks are in order. Firstly, the order of the tensors appearing on the right hand side is irrelevant, as we can reorder them by using the allowed moves of the Penrose graphical calculus, which yields some crossings and a twist. As the latter is trivial, it can be omitted, and we just use the same rules to evaluate the newly ordered tensor network. For the particular case of matrix-matrix multiplication, which also captures more general settings by appropriotely combining spaces into a single line, we indeed find</p><img src="../img/tensor-contractionreorder.svg" alt="tensor contraction reorder" class="color-invertible"/><p>or thus, the following two lines of code yield the same result</p><pre><code class="language-julia hljs">@tensor C[i, j] := B[i, k] * A[k, j]
@tensor C[i, j] := A[k, j] * B[i, k]</code></pre><p>Reordering of tensors can be used internally by the <code>@tensor</code> macro to evaluate the contraction in a more efficient manner. In particular, the NCON-style of specifying the contraction gives the user control over the order, and there are other macros, such as <code>@tensoropt</code>, that try to automate this process. There is also an <code>@ncon</code> macro and <code>ncon</code> function, an we recommend reading the <a href="https://quantumkithub.github.io/TensorOperations.jl/stable/">manual of TensorOperations.jl</a> to learn more about the possibilities and how they work.</p><p>A final remark involves the use of adjoints of tensors. The current framework is such that the user should not be too worried about the actual bipartition into codomain and domain of a given <code>TensorMap</code> instance. Indeed, for tensor contractions the <code>@tensor</code> macro figures out the correct manipulations automatically. However, when wanting to use the <code>adjoint</code> of an instance <code>t::TensorMap{T, S, N‚ÇÅ, N‚ÇÇ}</code>, the resulting <code>adjoint(t)</code> is an <code>AbstractTensorMap{T, S, N‚ÇÇ, N‚ÇÅ}</code> and one needs to know the values of <code>N‚ÇÅ</code> and <code>N‚ÇÇ</code> to know exactly where the <code>i</code>th index of <code>t</code> will end up in <code>adjoint(t)</code>, and hence the index order of <code>t&#39;</code>. Within the <code>@tensor</code> macro, one can instead use <code>conj()</code> on the whole index expression so as to be able to use the original index ordering of <code>t</code>. For example, for <code>TensorMap{T, S, 1, 1}</code> instances, this yields exactly the equivalence one expects, namely one between the following two expressions:</p><pre><code class="language-julia hljs">@tensor C[i, j] := B&#39;[i, k] * A[k, j]
@tensor C[i, j] := conj(B[k, i]) * A[k, j]</code></pre><p>For e.g. an instance <code>A::TensorMap{T, S, 3, 2}</code>, the following two syntaxes have the same effect within an <code>@tensor</code> expression: <code>conj(A[a, b, c, d, e])</code> and <code>A&#39;[d, e, a, b, c]</code>.</p><p>Some examples:</p><h2 id="Fermionic-tensor-contractions"><a class="docs-heading-anchor" href="#Fermionic-tensor-contractions">Fermionic tensor contractions</a><a id="Fermionic-tensor-contractions-1"></a><a class="docs-heading-anchor-permalink" href="#Fermionic-tensor-contractions" title="Permalink"></a></h2><p>TODO</p><h2 id="Anyonic-tensor-contractions"><a class="docs-heading-anchor" href="#Anyonic-tensor-contractions">Anyonic tensor contractions</a><a id="Anyonic-tensor-contractions-1"></a><a class="docs-heading-anchor-permalink" href="#Anyonic-tensor-contractions" title="Permalink"></a></h2><p>TODO</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tensors/">¬´ Constructing tensors and the <code>TensorMap</code> type</a><a class="docs-footer-nextpage" href="../../lib/sectors/">Symmetry sectors ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 21 February 2026 05:52">Saturday 21 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
