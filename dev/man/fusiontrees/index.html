<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fusion trees · TensorKit.jl</title><meta name="title" content="Fusion trees · TensorKit.jl"/><meta property="og:title" content="Fusion trees · TensorKit.jl"/><meta property="twitter:title" content="Fusion trees · TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../symmetries/">Symmetries</a></li><li><a class="tocitem" href="../sectors/">Sectors</a></li><li><a class="tocitem" href="../gradedspaces/">Graded spaces</a></li><li class="is-active"><a class="tocitem" href>Fusion trees</a><ul class="internal"><li><a class="tocitem" href="#Canonical-representation"><span>Canonical representation</span></a></li><li><a class="tocitem" href="#Manipulations-on-a-fusion-tree"><span>Manipulations on a fusion tree</span></a></li><li><a class="tocitem" href="#Manipulations-on-a-splitting-fusion-tree-pair"><span>Manipulations on a splitting - fusion tree pair</span></a></li><li><a class="tocitem" href="#Inspecting-fusion-trees-as-tensors"><span>Inspecting fusion trees as tensors</span></a></li></ul></li><li><a class="tocitem" href="../tensors/">Constructing tensors and the <code>TensorMap</code> type</a></li><li><a class="tocitem" href="../tensormanipulations/">Manipulating tensors</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors</a></li><li><a class="tocitem" href="../../lib/fusiontrees/">Fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../appendix/symmetric_tutorial/">A symmetric tensor deep dive: constructing your first tensor map</a></li><li><a class="tocitem" href="../../appendix/categories/">Optional introduction to category theory</a></li></ul></li><li><a class="tocitem" href="../../Changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Fusion trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fusion trees</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/TensorKit.jl/blob/main/docs/src/man/fusiontrees.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="s_fusiontrees"><a class="docs-heading-anchor" href="#s_fusiontrees">Fusion trees</a><a id="s_fusiontrees-1"></a><a class="docs-heading-anchor-permalink" href="#s_fusiontrees" title="Permalink"></a></h1><p>The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric (equivariant) tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors, i.e. they exhibit block sparsity. To exploit this block diagonal form, it is however essential that we know the basis transformation from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section <a href="../../lib/spaces/#TensorKit.blocksectors-Union{Tuple{ProductSpace{S, N}}, Tuple{N}, Tuple{S}} where {S, N}"><code>blocksectors</code></a> and <a href="../../lib/spaces/#TensorKit.blockdim"><code>blockdim</code></a> defined on the type <a href="../../lib/spaces/#TensorKit.ProductSpace"><code>ProductSpace</code></a>.</p><p>This basis transformation consists of a basis of inclusion and projection maps, denoted as <span>$X^{a_1a_2…a_N}_{c,α}: R_c → R_{a_1} ⊗ R_{a_2} ⊗ … ⊗ R_{a_N}$</span> and their adjoints <span>$(X^{a_1a_2…a_N}_{c,α})^†$</span>, such that</p><p class="math-container">\[(X^{a_1a_2…a_N}_{c,α})^† ∘ X^{a_1a_2…a_N}_{c′,α′} = δ_{c,c′} δ_{α,α′} \mathrm{id}_c\]</p><p>and</p><p class="math-container">\[∑_{c,α} X^{a_1a_2…a_N}_{c,α} ∘ (X^{a_1a_2…a_N}_{c,α})^†  = \mathrm{id}_{a_1 ⊗ a_2 ⊗ … ⊗ a_N} = \mathrm{id}_{a_1} ⊗ \mathrm{id}_{a_2} ⊗ … ⊗ \mathrm{id}_{a_N}\]</p><p>Fusion trees provide a particular way to construct such a basis. It is useful to know about the existence of fusion trees and how they are represented, as discussed in the first subsection. The next two subsections discuss possible manipulations that can be performed with fusion trees. These are used under the hood when manipulating the indices of tensors, but a typical user would not need to use these manipulations on fusion trees directly. Hence, these last two sections can safely be skipped.</p><h2 id="Canonical-representation"><a class="docs-heading-anchor" href="#Canonical-representation">Canonical representation</a><a id="Canonical-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Canonical-representation" title="Permalink"></a></h2><p>To couple or fuse the different sectors together into a single block sector, we can sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector, using the splitting tensors <span>$X_{a,b}^{c,μ} : R_c → R_a ⊗ R_b$</span> and their adjoints. This amounts to the canonical choice of our tensor product, and for a given tensor mapping from <span>$(((W_1 ⊗ W_2) ⊗ W_3) ⊗ … )⊗ W_{N_2})$</span> to <span>$(((V_1 ⊗ V_2) ⊗ V_3) ⊗ … )⊗ V_{N_1})$</span>, the corresponding fusion and splitting trees take the form</p><img src="../img/tree-simple.svg" alt="double fusion tree" class="color-invertible"/><p>for the specific case <span>$N_1 = 4$</span> and <span>$N_2 = 3$</span>. We can separate this tree into the fusing part <span>$(b_1 ⊗ b_2) ⊗ b_3 → c$</span> and the splitting part <span>$c→(((a_1 ⊗ a_2) ⊗ a_3) ⊗ a_4)$</span>. Given that the fusion tree can be considered to be the adjoint of a corresponding splitting tree <span>$c → (b_1 ⊗ b_2) ⊗ b_3$</span>, we now first consider splitting trees in isolation. A splitting tree which goes from one coupled sector <span>$c$</span> to <span>$N$</span> uncoupled sectors <span>$a_1$</span>, <span>$a_2$</span>, …, <span>$a_N$</span> needs <span>$N-2$</span> additional internal sector labels <span>$e_1$</span>, …, <span>$e_{N-2}$</span>, and, if <code>FusionStyle(I) isa GenericFusion</code>, <span>$N-1$</span> additional multiplicity labels <span>$μ_1$</span>, …, <span>$μ_{N-1}$</span>. We henceforth refer to them as vertex labels, as they are associated with the vertices of the splitting tree. In the case of <code>FusionStyle(I) isa UniqueFusion</code>, the internal sectors <span>$e_1$</span>, …, <span>$e_{N-2}$</span> are completely fixed, for <code>FusionStyle(I) isa MultipleFusion</code> they can also take different values. In our abstract notation of the splitting basis <span>$X^{a_1a_2…a_N}_{c,α}$</span> used above, <span>$α$</span> can be considered a collective label, i.e. <span>$α = (e_1, …, e_{N-2}; μ₁, … ,μ_{N-1})$</span>. Indeed, we can check the orthogonality condition <span>$(X^{a_1a_2…a_N}_{c,α})^† ∘ X^{a_1a_2…a_N}_{c′,α′} = δ_{c,c′} δ_{α,α′} \mathrm{id}_c$</span>, which now forces all internal lines <span>$e_k$</span> and vertex labels <span>$μ_l$</span> to be the same.</p><p>There is one subtle remark that we have so far ignored. Within the specific subtypes of <code>Sector</code>, we do not explicitly distinguish between <span>$R_a^*$</span> (simply denoted as <span>$a^*$</span> and graphically depicted as an upgoing arrow <span>$a$</span>) and <span>$R_{\bar{a}}$</span> (simply denoted as <span>$\bar{a}$</span> and depicted with a downgoing arrow), i.e. between the dual space of <span>$R_a$</span> on which the conjugated irrep acts, or the irrep <span>$\bar{a}$</span> to which the complex conjugate of irrep <span>$a$</span> is isomorphic. This distinction is however important, when certain uncoupled sectors in the fusion tree actually originate from a dual space. We use the isomorphisms <span>$Z_a : R_a^* → R_{\bar{a}}$</span> and its adjoint <span>$Z_a^† : R_{\bar{a}} → R_a^*$</span>, as introduced in the section on <a href="../../appendix/categories/#ss_topologicalfusion">topological data of a fusion category</a>, to build fusion and splitting trees that take the distinction between irreps and their conjugates into account. Hence, in the previous example, if e.g. the first and third space in the codomain and the second space in the domain of the tensor were dual spaces, the actual pair of splitting and fusion tree would look as</p><img src="../img/tree-extended.svg" alt="extended double fusion tree" class="color-invertible"/><p>The presence of these isomorphisms will be important when we start to bend lines, to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. Note that we can still represent the fusion tree as the adjoint of a corresponding splitting tree, because we also use the adjoint of the <span>$Z$</span> isomorphisms in the splitting part, and the <span>$Z$</span> isomorphism in the fusion part. Furthermore, the presence of the <span>$Z$</span> isomorphisms does not affect the orthonormality.</p><p>We represent splitting trees and their adjoints using a specific immutable type called <code>FusionTree</code> (which actually represents a splitting tree, but fusion tree is a more common term), defined as</p><pre><code class="language-julia hljs">struct FusionTree{I&lt;:Sector,N,M,L}
    uncoupled::NTuple{N,I}
    coupled::I
    isdual::NTuple{N,Bool}
    innerlines::NTuple{M,I} # fixed to M = N-2
    vertices::NTuple{L,Int} # fixed to L = N-1
end</code></pre><p>Here, the fields are probably self-explanatory. The <code>isdual</code> field indicates whether an isomorphism is present (if the corresponding value is <code>true</code>) or not. Note that the field <code>uncoupled</code> contains the sectors coming out of the splitting trees, before the possible <span>$Z$</span> isomorphism, i.e. the splitting tree in the above example would have <code>sectors = (a₁, a₂, a₃, a₄)</code>. The <code>FusionTree</code> type has a number of basic properties and capabilities, such as checking for equality with <code>==</code> and support for <code>hash(f::FusionTree, h::UInt)</code>, as splitting and fusion trees are used as keys in look-up tables (i.e. <code>AbstractDictionary</code> instances) to look up certain parts of the data of a tensor.</p><p><code>FusionTree</code> instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. The most natural way to create them is by using the <code>fusiontrees(uncoupled::NTuple{N, I}, coupled::I = unit(I))</code> method, which returns an iterator over all possible fusion trees from a set of <code>N</code> uncoupled sectors to a given coupled sector, which by default is assumed to be the trivial sector of that group or fusion category (i.e. the identity object in categorical nomenclature). The return type of <code>fusiontrees</code> is a custom type <code>FusionTreeIterator</code> which conforms to the complete interface of an iterator, and has a custom <code>length</code> function that computes the number of possible fusion trees without iterating over all of them explicitly. This is best illustrated with some examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Irrep[SU₂](1/2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s, s, s, s)))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{FusionTree{SU2Irrep, 4, 2, 3}}:
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (0, 1/2))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (1, 1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s, s, s, s, s), s, (true, false, false, true, false)))</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{FusionTree{SU2Irrep, 5, 3, 4}}:
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 0))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 0))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 1))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 1))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 3/2, 1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iter = fusiontrees(ntuple(n -&gt; s, 16))</code><code class="nohighlight hljs ansi" style="display:block;">TensorKit.FusionTreeIterator{SU2Irrep, 16, NTuple{16, Tuple{SU2Irrep}}}(((Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),)), Irrep[SU₂](0), (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(n -&gt; 1, iter)</code><code class="nohighlight hljs ansi" style="display:block;">1430</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(iter)</code><code class="nohighlight hljs ansi" style="display:block;">1430</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @elapsed sum(n -&gt; 1, iter)</code><code class="nohighlight hljs ansi" style="display:block;">0.046137193</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @elapsed length(iter)</code><code class="nohighlight hljs ansi" style="display:block;">3.8331e-5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = s ⊠ s</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂ × SU₂](1/2, 1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s2, s2, s2, s2)))</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{FusionTree{ProductSector{Tuple{SU2Irrep, SU2Irrep}}, 4, 2, 3}}:
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((0, 0), (1/2, 1/2)))
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((1, 0), (1/2, 1/2)))
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((0, 1), (1/2, 1/2)))
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((1, 1), (1/2, 1/2)))</code></pre><p>Note that <code>FusionTree</code> instances are shown (printed) in a way that is valid code to reproduce them, a property which also holds for both instances of <code>Sector</code> and instances of <code>VectorSpace</code>. All of those should be displayed in a way that can be copy pasted as valid code. Furthermore, we use context to determine how to print e.g. a sector. In isolation, <code>s2</code> is printed as <code>(Irrep[SU₂](1/2) ⊠ Irrep[SU₂](1/2))</code>, however, within the fusion tree, it is simply printed as <code>(1/2, 1/2)</code>, because it will be converted back into a <code>ProductSector</code>, namely <code>Irrep[SU₂] ⊠ Irrep[SU₂]</code> by the constructor of <code>FusionTree{Irrep[SU₂] ⊠ Irrep[SU₂]}</code>.</p><h2 id="Manipulations-on-a-fusion-tree"><a class="docs-heading-anchor" href="#Manipulations-on-a-fusion-tree">Manipulations on a fusion tree</a><a id="Manipulations-on-a-fusion-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulations-on-a-fusion-tree" title="Permalink"></a></h2><p>We now discuss elementary manipulations that we want to perform on or between fusion trees (where we actually mean splitting trees), which will form the building block for more general manipulations on a pair of a fusion and splitting tree discussed in the next subsection, and then for casting a general index manipulation of a tensor map as a linear operation in the basis of canonically ordered splitting and fusion trees. In this section, we will ignore the <span>$Z$</span> isomorphisms, as they are just trivially reshuffled under the different operations that we describe. These manipulations are used as low-level methods by the <code>TensorMap</code> methods discussed on the next page. As such, they are not exported by TensorKit.jl, nor do they overload similarly named methods from Julia Base (see <code>split</code> and <code>merge</code> below).</p><p>The first operation we discuss is an elementary braid of two neighbouring sectors (indices), i.e. a so-called Artin braid or Artin generator of the braid group. Because these two sectors do not appear on the same fusion vertex, some recoupling is necessary. The following represents two different ways to compute the result of such a braid as a linear combination of new fusion trees in canonical order:</p><img src="../img/tree-artinbraid.svg" alt="artin braid" class="color-invertible"/><p>While the upper path is the most intuitive, it requires two recouplings or F-moves (one forward and one reverse). On the other hand, the lower path requires only one (reverse) F- move, and two R-moves. The latter are less expensive to compute, and so the lower path is computationally more efficient. However, the end result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any new subtype of <code>Sector</code>, and it is up to the user to verify that they are when implementing new custom <code>Sector</code> types. This result is implemented in the function <a href="../../lib/fusiontrees/#TensorKit.artin_braid"><code>artin_braid(f::FusionTree, i; inv = false)</code></a> where <code>i</code> denotes the position of the first sector (i.e. labeled <code>b</code> in the above graph) which is then braided with the sector at position <code>i+1</code> in the fusion tree <code>f</code>. The keyword argument <code>inv</code> allows to select the inverse braiding operation, which amounts to replacing the R-matrix with its inverse (or thus, adjoint) in the above steps. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as value. In the case of <code>FusionStyle(I) isa UniqueFusion</code>, their is only one resulting fusion tree, with corresponding coefficient a complex phase (which is one for the bosonic representation theory of an Abelian group), and the result is a special <code>SingletonDict&lt;:AbstractDict</code>, a <code>struct</code> type defined in TensorKit.jl to hold a single key value pair.</p><p>With the elementary <code>artin_braid</code>, we can then compute a more general braid. For this, we provide an interface</p><p><a href="../../lib/fusiontrees/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>braid(f::FusionTree{I, N}, levels::NTuple{N, Int}, permutation::NTuple{N, Int})</code></a></p><p>where the braid is specified as a permutation, such that the new sector at position <code>i</code> was originally at position <code>permutation[i]</code>, and where every uncoupled sector is also assigned a level or depth. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor. This interface does not allow to specify the most general braid, and in particular will never wind one line around another, but can be used as a more general building block for arbitrary braids than the elementary Artin generators. A graphical example makes this probably more clear, i.e for <code>levels = (1, 2, 3, 4, 5)</code> and <code>permutation = (5, 3, 1, 4, 2)</code>, the corresponding braid is given by</p><img src="../img/tree-braidinterface.svg" alt="braid interface" class="color-invertible"/><p>that is, the first sector or space goes to position 3, and crosses over all other lines, because it has the lowest level (i.e. think of level as depth in the third dimension), and so forth. We sketch this operation both as a general braid on the left hand side, and as a particular composition of Artin braids on the right hand side.</p><p>When <code>BraidingStyle(I) == SymmetricBraiding()</code>, there is no distinction between applying the braiding or its inverse (i.e. lines crossing over or under each other in the graphical notation) and the whole operation simplifies down to a permutation. We then also support the interface</p><p><a href="../../lib/fusiontrees/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute(f::FusionTree{I, N}, permutation::NTuple{N, Int})</code></a></p><p>Other manipulations which are sometimes needed are</p><ul><li><a href="../../lib/fusiontrees/#TensorKit.insertat"><code>insertat(f1::FusionTree{I,N₁}, i::Int, f2::FusionTree{I,N₂})</code></a> : inserts a fusion tree <code>f2</code> at the <code>i</code>th uncoupled sector of fusion tree <code>f1</code> (this requires that the coupled sector <code>f2</code> matches with the <code>i</code>th uncoupled sector of <code>f1</code>, and that <code>!f1.isdual[i]</code>, i.e. that there is no <span>$Z$</span>-isomorphism on the <code>i</code>th line of <code>f1</code>), and recouple this into a linear combination of trees in canonical order, with <code>N₁ + N₂ - 1</code> uncoupled sectors, i.e. diagrammatically for <code>i = 3</code></li></ul><img src="../img/tree-insertat.svg" alt="insertat" class="color-invertible"/><ul><li><p><a href="../../lib/fusiontrees/#TensorKit.split"><code>split(f::FusionTree{I,N}, M::Int)</code></a> : splits a fusion tree <code>f</code> into two trees <code>f1</code> and <code>f2</code>, such that <code>f1</code> has the first <code>M</code> uncoupled sectors of <code>f</code>, and <code>f2</code> the remaining <code>N - M</code>.   This function is type stable if <code>M</code> is a compile time constant.</p><p><code>split(f, M)</code> is the inverse of <code>insertat</code> in the sense that <code>insertat(f2, 1, f1)</code> should return a dictionary with a single key-value pair <code>f=&gt;1</code>.   Diagrammatically, for <code>M = 4</code>, the function <code>split</code> returns</p></li></ul><img src="../img/tree-split.svg" alt="split" class="color-invertible"/><ul><li><a href="../../lib/fusiontrees/#TensorKit.merge"><code>merge(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, c::I, [μ=1])</code></a> : merges two fusion trees <code>f1</code> and <code>f2</code> by fusing the coupled sectors of <code>f1</code> and <code>f2</code> into a sector <code>c</code> (with vertex label <code>μ</code> if <code>FusionStyle(I) == GenericFusion()</code>), and reexpressing the result as a linear combination of fusion trees with <code>N₁ + N₂</code> uncoupled sectors in canonical order.   This is a simple application of <code>insertat</code>.   Diagrammatically, this operation is represented as:</li></ul><img src="../img/tree-merge.svg" alt="merge" class="color-invertible"/><h2 id="Manipulations-on-a-splitting-fusion-tree-pair"><a class="docs-heading-anchor" href="#Manipulations-on-a-splitting-fusion-tree-pair">Manipulations on a splitting - fusion tree pair</a><a id="Manipulations-on-a-splitting-fusion-tree-pair-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulations-on-a-splitting-fusion-tree-pair" title="Permalink"></a></h2><p>In this subsection we discuss manipulations that act on a splitting and fusion tree pair, which we will always as two separate trees <code>f1, f2</code>, where <code>f1</code> is the splitting tree and <code>f2</code> represents the fusion tree, and they should have <code>f1.coupled == f2.coupled</code>.</p><p>The most important manipulation on such a pair is to move sectors from one to the other. Given the canonical order of these trees, we exclusively use the <em>left duality</em> (see the section on <a href="../../appendix/categories/#s_categories">categories</a>), for which the evaluation and coevaluation maps establish isomorphisms between</p><p class="math-container">\[\begin{aligned}
&amp;\mathrm{Hom}((((b_1 ⊗ b_2) ⊗ …) ⊗ b_{N_2}), (((a_1 ⊗ a_2) ⊗ …) ⊗ a_{N_1}))\\
&amp;≂\mathrm{Hom}((((b_1 ⊗ b_2) ⊗ ...) ⊗ b_{N_2-1}), ((((a_1 ⊗ a_2) ⊗ ...) ⊗ a_{N_1}) ⊗ b_{N_2}^*))\\
&amp;≂\mathrm{Hom}(1, (((((((a_1 ⊗ a_2) ⊗ ...) ⊗ a_{N_1}) ⊗ b_{N_2}^*) ⊗ …) ⊗ b_2^*) ⊗ b_1^*) )
\end{aligned}\]</p><p>where the last morphism space is then labeled by the basis of only splitting trees. We can then use the manipulations from the previous section, and then again use the left duality to bring this back to a pair of splitting and fusion tree with <code>N₂′</code> incoming and <code>N₁′</code> incoming sectors (with <code>N₁′ + N₂′ == N₁ + N₂</code>).</p><p>We now discuss how to actually bend lines, and thus, move sectors from the incoming part (fusion tree) to the outgoing part (splitting tree). Hereby, we exploit the relations between the (co)evaluation (exact pairing) and the fusion tensors, discussed in <a href="../../appendix/categories/#ss_topologicalfusion">topological data of a fusion category</a>. The main ingredient that we need is summarized in</p><img src="../img/tree-linebending.svg" alt="line bending" class="color-invertible"/><p>We will only need the B-symbol and not the A-symbol. Applying the left evaluation on the second sector of a splitting tensor thus yields a linear combination of fusion tensors (when <code>FusionStyle(I) == GenericFusion()</code>, or just a scalar times the corresponding fusion tensor otherwise), with corresponding <span>$Z$</span> ismorphism. Taking the adjoint of this relation yields the required relation to transform a fusion tensor into a splitting tensor with an added <span>$Z^†$</span> isomorphism.</p><p>However, we have to be careful if we bend a line on which a <span>$Z$</span> isomorphism (or its adjoint) is already present. Indeed, it is exactly for this operation that we explicitly need to take the presence of these isomorphisms into account. Indeed, we obtain the relation</p><img src="../img/tree-linebending2.svg" alt="dual line bending" class="color-invertible"/><p>Hence, bending an <code>isdual</code> sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and of course leads to a normal sector (which is no longer <code>isdual</code> and does thus not come with a <span>$Z$</span>-isomorphism) on the fusion side. We again use the adjoint of this relation to bend an <code>isdual</code> sector from the fusion tree to the splitting tree.</p><p>The <code>FusionTree</code> interface to duality and line bending is given by</p><p><a href="../../lib/fusiontrees/#TensorKit.repartition-Union{Tuple{N₂}, Tuple{N₁}, Tuple{I}, Tuple{FusionTree{I, N₁}, FusionTree{I, N₂}, Int64}} where {I&lt;:Sector, N₁, N₂}"><code>repartition(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, N::Int)</code></a></p><p>which takes a splitting tree <code>f1</code> with <code>N₁</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N₂</code> incoming sectors, and applies line bending such that the resulting splitting and fusion trees have <code>N</code> outgoing sectors, corresponding to the first <code>N</code> sectors out of the list <span>$(a_1, a_2, …, a_{N_1}, b_{N_2}^*, …, b_{1}^*)$</span> and <code>N₁ + N₂ - N</code> incoming sectors, corresponding to the dual of the last <code>N₁ + N₂ - N</code> sectors from the previous list, in reverse. This return values are correctly inferred if <code>N</code> is a compile time constant.</p><p>Graphically, for <code>N₁ = 4</code>, <code>N₂ = 3</code>, <code>N = 2</code> and some particular choice of <code>isdual</code> in both the fusion and splitting tree:</p><img src="../img/tree-repartition.svg" alt="repartition" class="color-invertible"/><p>The result is returned as a dictionary with keys <code>(f1′, f2′)</code> and the corresponding <code>coeff</code> as value. Note that the summation is only over the <span>$κ_j$</span> labels, such that, in the case of <code>FusionStyle(I) isa MultiplicityFreeFusion</code>, the linear combination simplifies to a single term with a scalar coefficient.</p><p>With this basic function, we can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear. The interface provided for this is given by</p><p><a href="@ref braid(::FusionTree{I}, ::FusionTree{I}, ::IndexTuple, ::IndexTuple, ::IndexTuple{N₁}, ::IndexTuple{N₂}) where {I&lt;:Sector,N₁,N₂}"><code>braid(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, levels1::NTuple{N₁,Int}, levels2::NTuple{N₂,Int}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})</code></a></p><p>where we now have splitting tree <code>f1</code> with <code>N₁</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N₂</code> incoming sectors, <code>levels1</code> and <code>levels2</code> assign a level or depth to the corresponding uncoupled sectors in <code>f1</code> and <code>f2</code>, and we represent the new configuration as a pair <code>p1</code> and <code>p2</code>. Together, <code>(p1..., p2...)</code> represents a permutation of length <code>N₁ + N₂ = N₁′ + N₂′</code>, where <code>p1</code> indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and <code>p2</code> indicates which appear as incoming sectors in the new fusion tree. Hereto, we label the uncoupled sectors of <code>f1</code> from <code>1</code> to <code>N₁</code>, followed by the uncoupled sectors of <code>f2</code> from <code>N₁ + 1</code> to <code>N₁ + N₂</code>. Note that simply repartitioning the splitting and fusion tree such that e.g. all sectors appear in the new splitting tree (i.e. are outgoing), amounts to chosing <code>p1 = (1,..., N₁, N₁ + N₂, N₁ + N₂ - 1, ... , N₁ + 1)</code> and <code>p2 = ()</code>, because the duality isomorphism reverses the order of the tensor product.</p><p>This routine is implemented by indeed first making all sectors outgoing using the <code>repartition</code> function discussed above, such that only splitting trees remain, then braiding those using the routine from the previous subsection such that the new outgoing sectors appear first, followed by the new incoming sectors (in reverse order), and then again invoking the <code>repartition</code> routine to bring everything in final form. The result is again returned as a dictionary where the keys are <code>(f1′, f2′)</code> and the values the corresponding coefficients.</p><p>As before, there is a simplified interface for the case where <code>BraidingStyle(I) isa SymmetricBraiding</code> and the levels are not needed. This is simply given by</p><p><a href="@ref permute(::FusionTree{I}, ::FusionTree{I}, ::IndexTuple{N₁}, ::IndexTuple{N₂}) where {I&lt;:Sector,N₁,N₂}"><code>permute(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})</code></a></p><p>The <code>braid</code> and <code>permute</code> routines for double fusion trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memoized, i.e. they are stored in some package wide &#39;least-recently used&#39; cache (from <a href="https://github.com/JuliaCollections/LRUCache.jl">LRUCache.jl</a>) that can be accessed as <code>TensorKit. raidcache</code>. By default, this cache stores up to <code>10^5</code> different <code>braid</code> or <code>permute</code> resuls, where one result corresponds to one particular combination of <code>(f1, f2, p1, p2, levels1, levels2)</code>. This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to <code>resize!(TensorKit.permutecache)</code> and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type <code>RefValue{Bool}</code>, namely <code>usebraidcache_abelian</code> and <code>usebraidcache_nonabelian</code>. The default values are given by <code>TensorKit.usebraidcache_abelian[] = false</code> and <code>TensorKit.usebraidcache_nonabelian[] = true</code>, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with <code>FusionStyle(f) isa UniqueFusion</code>, but is probably useful for fusion trees with <code>FusionStyle(f) isa MultipleFusion</code>. One can change these values and test the effect on their application.</p><p>The existence of <code>braidcache</code> also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.</p><h2 id="Inspecting-fusion-trees-as-tensors"><a class="docs-heading-anchor" href="#Inspecting-fusion-trees-as-tensors">Inspecting fusion trees as tensors</a><a id="Inspecting-fusion-trees-as-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-fusion-trees-as-tensors" title="Permalink"></a></h2><p>For those cases where the fusion and splitting tensors have an explicit representation as a tensor, i.e. a morphism in the category <code>Vect</code> (this essentially coincides with the case of group representations), this explicit representation can be created, which can be useful for checking purposes. Hereto, it is necessary that the <em>splitting tensor</em> <span>$X^{ab}_{c,μ}$</span>, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine <code>fusiontensor(a, b, c, μ = nothing)</code>, where the last argument is only necessary in the case of <code>FusionStyle(I) == GenericFusion()</code>. We can then convert a <code>FusionTree{I, N}</code> into an <code>Array</code>, which will yield a rank <code>N + 1</code> array where the first <code>N</code> dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector. Note that this is mostly useful for the case of <code>FusionStyle(I) isa MultipleFusion</code> groups, as in the case of abelian groups, all irreps are one-dimensional.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Irrep[SU₂](1/2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iter = fusiontrees((s, s, s, s), SU2Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">TensorKit.FusionTreeIterator{SU2Irrep, 4, NTuple{4, Tuple{SU2Irrep}}}(((Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),), (Irrep[SU₂](1/2),)), Irrep[SU₂](1), (false, false, false, false))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = first(iter)</code><code class="nohighlight hljs ansi" style="display:block;">FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, f)</code><code class="nohighlight hljs ansi" style="display:block;">2×2×2×2×3 Array{Float64, 5}:
[:, :, 1, 1, 1] =
  0.0       0.707107
 -0.707107  0.0

[:, :, 2, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 1, 2, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 2, 2, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 3] =
  0.0       0.707107
 -0.707107  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; LinearAlgebra.I ≈ convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (false,), ()))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z = adjoint(convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (true,), ())))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 adjoint(::Matrix{Float64}) with eltype Float64:
 0.0  -1.0
 1.0   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(Z) ≈ frobenius_schur_phase(SU2Irrep(1/2)) * Z</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; LinearAlgebra.I ≈ convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (false,), ()))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z = adjoint(convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (true,), ())))</code><code class="nohighlight hljs ansi" style="display:block;">3×3 adjoint(::Matrix{Float64}) with eltype Float64:
 0.0   0.0  1.0
 0.0  -1.0  0.0
 1.0   0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(Z) ≈ frobenius_schur_phase(Irrep[SU₂](1)) * Z</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; #check orthogonality
       for f1 in iter
         for f2 in iter
           dotproduct  = dot(convert(Array, f1), convert(Array, f2))
           println(&quot;&lt;$f1, $f2&gt; = $dotproduct&quot;)
         end
       end</code><code class="nohighlight hljs ansi" style="display:block;">&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 3.000000000000001
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 2.999999999999999
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 1.1102230246251565e-16
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 1.1102230246251565e-16
&lt;FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 2.9999999999999982</code></pre><p>Note that we take the adjoint when computing <code>Z</code>, because <code>convert(Array, f)</code> assumes <code>f</code> to be splitting tree, which is built using <span>$Z^†$</span>. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the <span>$\mathrm{id}_c$</span> when checking the orthogonality by computing <code>dot</code> of the corresponding tensors.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gradedspaces/">« Graded spaces</a><a class="docs-footer-nextpage" href="../tensors/">Constructing tensors and the <code>TensorMap</code> type »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Monday 23 February 2026 19:53">Monday 23 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
